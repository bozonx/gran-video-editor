[{"filePath":"/mnt/disk2/workspace/gran-video-editor/eslint.config.mjs","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `,`","line":15,"column":39,"messageId":"insert","endLine":15,"endColumn":39,"fix":{"range":[700,700],"text":","}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `,`","line":16,"column":4,"messageId":"insert","endLine":16,"endColumn":4,"fix":{"range":[704,704],"text":","}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import withNuxt from './.nuxt/eslint.config.mjs';\nimport eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';\n\nexport default withNuxt(eslintPluginPrettierRecommended).append({\n  rules: {\n    '@typescript-eslint/no-explicit-any': 'warn',\n    '@typescript-eslint/no-unsafe-function-type': 'warn',\n    '@typescript-eslint/no-unused-vars': 'warn',\n    '@typescript-eslint/no-extraneous-class': 'warn',\n    '@typescript-eslint/no-dynamic-delete': 'warn',\n    '@typescript-eslint/no-useless-constructor': 'warn',\n    '@typescript-eslint/unified-signatures': 'warn',\n    'no-useless-escape': 'warn',\n    'vue/multi-word-component-names': 'warn',\n    'vue/require-default-prop': 'warn'\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/nuxt.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/app.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/EditorSettingsModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/FileManager.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isEditableTarget' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"messageId":"unusedVar","endLine":19,"endColumn":26,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"isEditableTarget"},"fix":{"range":[1135,1199],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":32,"column":3,"messageId":"unusedVar","endLine":32,"endColumn":8},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":35,"messageId":"unexpectedAny","endLine":211,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6323,6326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6323,6326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":35,"messageId":"unexpectedAny","endLine":221,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6634,6637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6634,6637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, watch } from 'vue';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useFileManager } from '~/composables/fileManager/useFileManager';\nimport type { FsEntry } from '~/types/fs';\nimport CreateFolderModal from '~/components/common/CreateFolderModal.vue';\nimport FileInfoModal, { type FileInfo } from '~/components/common/FileInfoModal.vue';\nimport UiConfirmModal from '~/components/ui/UiConfirmModal.vue';\nimport RenameModal from '~/components/common/RenameModal.vue';\nimport FileManagerFiles from '~/components/file-manager/FileManagerFiles.vue';\nimport FileManagerEffects from '~/components/file-manager/FileManagerEffects.vue';\nimport FileManagerHistory from '~/components/file-manager/FileManagerHistory.vue';\nimport { useProxyStore } from '~/stores/proxy.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useSelectionStore } from '~/stores/selection.store';\nimport { useTimelineMediaUsageStore } from '~/stores/timeline-media-usage.store';\nimport { isEditableTarget } from '~/utils/hotkeys/hotkeyUtils';\n\nconst { t } = useI18n();\nconst projectStore = useProjectStore();\nconst mediaStore = useMediaStore();\nconst timelineStore = useTimelineStore();\nconst focusStore = useFocusStore();\nconst timelineMediaUsageStore = useTimelineMediaUsageStore();\n\nconst fileManager = useFileManager();\nconst {\n  rootEntries,\n  isLoading,\n  error,\n  isApiSupported,\n  getProjectRootDirHandle,\n  loadProjectDirectory,\n  toggleDirectory,\n  handleFiles,\n  createFolder,\n  deleteEntry,\n  renameEntry,\n  findEntryByPath,\n  moveEntry,\n  createTimeline,\n  getFileIcon,\n  sortMode,\n  setSortMode,\n} = fileManager;\n\nconst activeTab = ref('files');\nconst isDragging = ref(false);\nconst fileInput = ref<HTMLInputElement | null>(null);\n\n// Modals state\nconst isCreateFolderModalOpen = ref(false);\nconst folderCreationTarget = ref<FileSystemDirectoryHandle | null>(null);\n\nconst isRenameModalOpen = ref(false);\nconst renameTarget = ref<FsEntry | null>(null);\n\nconst isFileInfoModalOpen = ref(false);\nconst currentFileInfo = ref<FileInfo | null>(null);\n\nconst isDeleteConfirmModalOpen = ref(false);\nconst deleteTarget = ref<FsEntry | null>(null);\n\nconst directoryUploadTarget = ref<FsEntry | null>(null);\nconst directoryUploadInput = ref<HTMLInputElement | null>(null);\n\nconst uiStore = useUiStore();\nconst selectionStore = useSelectionStore();\n\nconst timelinesUsingDeleteTarget = computed(() => {\n  const entry = deleteTarget.value;\n  if (!entry || entry.kind !== 'file' || !entry.path) return [];\n  return timelineMediaUsageStore.mediaPathToTimelines[entry.path] ?? [];\n});\n\nconst toast = useToast();\n\ninterface FsDirectoryHandleWithIteration extends FileSystemDirectoryHandle {\n  values?: () => AsyncIterable<FileSystemHandle>;\n  entries?: () => AsyncIterable<[string, FileSystemHandle]>;\n}\n\nasync function computeDirectorySize(\n  dirHandle: FileSystemDirectoryHandle,\n  options?: { maxEntries?: number },\n): Promise<number | undefined> {\n  const maxEntries = options?.maxEntries ?? 25_000;\n  let seen = 0;\n\n  async function walk(handle: FileSystemDirectoryHandle): Promise<number> {\n    const iterator =\n      (handle as FsDirectoryHandleWithIteration).values?.() ??\n      (handle as FsDirectoryHandleWithIteration).entries?.();\n    if (!iterator) return 0;\n\n    let total = 0;\n    for await (const value of iterator) {\n      if (seen >= maxEntries) {\n        throw new Error('Directory too large');\n      }\n      seen += 1;\n\n      const entryHandle = (Array.isArray(value) ? value[1] : value) as\n        | FileSystemFileHandle\n        | FileSystemDirectoryHandle;\n\n      if (entryHandle.kind === 'file') {\n        try {\n          const file = await (entryHandle as FileSystemFileHandle).getFile();\n          total += file.size;\n        } catch {\n          // ignore\n        }\n      } else {\n        total += await walk(entryHandle as FileSystemDirectoryHandle);\n      }\n    }\n    return total;\n  }\n\n  try {\n    return await walk(dirHandle);\n  } catch {\n    return undefined;\n  }\n}\n\nwatch(\n  () => uiStore.pendingFsEntryDelete,\n  (entry) => {\n    if (entry) {\n      openDeleteConfirmModal(entry);\n      uiStore.pendingFsEntryDelete = null;\n    }\n  },\n);\n\nwatch(\n  () => projectStore.currentProjectName,\n  async (name) => {\n    if (name) {\n      uiStore.restoreFileTreeStateOnce(name);\n    }\n    await loadProjectDirectory();\n  },\n  { immediate: true },\n);\n\nfunction onDragOver(e: DragEvent) {\n  if (e.dataTransfer?.types.includes('Files')) {\n    isDragging.value = true;\n    uiStore.isFileManagerDragging = true;\n  }\n}\n\nfunction onDragLeave(e: DragEvent) {\n  const currentTarget = e.currentTarget as HTMLElement | null;\n  const relatedTarget = e.relatedTarget as Node | null;\n  if (!currentTarget?.contains(relatedTarget)) {\n    isDragging.value = false;\n    uiStore.isFileManagerDragging = false;\n  }\n}\n\nfunction onDrop(e: DragEvent) {\n  isDragging.value = false;\n  uiStore.isFileManagerDragging = false;\n  uiStore.isGlobalDragging = false;\n\n  if (e.dataTransfer?.files) {\n    handleFiles(e.dataTransfer.files);\n  }\n}\n\nfunction openCreateFolderModal(targetEntry: FsEntry | null = null) {\n  folderCreationTarget.value =\n    targetEntry?.kind === 'directory' ? (targetEntry.handle as FileSystemDirectoryHandle) : null;\n  isCreateFolderModalOpen.value = true;\n}\n\nasync function handleCreateFolder(name: string) {\n  await createFolder(name, folderCreationTarget.value);\n}\n\nasync function onCreateTimeline() {\n  const createdPath = await createTimeline();\n  if (!createdPath) return;\n\n  await projectStore.openTimelineFile(createdPath);\n  await timelineStore.loadTimeline();\n  void timelineStore.loadTimelineMetadata();\n}\n\nasync function openFileInfoModal(entry: FsEntry) {\n  let size: number | undefined;\n  let lastModified: number | undefined;\n  let fileType: string | undefined;\n\n  if (entry.kind === 'file') {\n    try {\n      const file = await (entry.handle as FileSystemFileHandle).getFile();\n      size = file.size;\n      lastModified = file.lastModified;\n      fileType = file.type;\n    } catch (e) {\n      toast.add({\n        color: 'red',\n        title: t('videoEditor.fileManager.info.error', 'Information error'),\n        description: String((e as any)?.message ?? e),\n      });\n    }\n  } else {\n    try {\n      size = await computeDirectorySize(entry.handle as FileSystemDirectoryHandle);\n    } catch (e) {\n      toast.add({\n        color: 'red',\n        title: t('videoEditor.fileManager.info.error', 'Information error'),\n        description: String((e as any)?.message ?? e),\n      });\n    }\n  }\n\n  currentFileInfo.value = {\n    name: entry.name,\n    kind: entry.kind,\n    size,\n    lastModified,\n    path: entry.path,\n    metadata:\n      entry.kind === 'file' &&\n      entry.path &&\n      typeof fileType === 'string' &&\n      (fileType.startsWith('video/') || fileType.startsWith('audio/'))\n        ? await mediaStore.getOrFetchMetadata(entry.handle as FileSystemFileHandle, entry.path, {\n            forceRefresh: true,\n          })\n        : undefined,\n  };\n  isFileInfoModalOpen.value = true;\n}\n\nfunction openDeleteConfirmModal(entry: FsEntry) {\n  deleteTarget.value = entry;\n  isDeleteConfirmModalOpen.value = true;\n}\n\nasync function handleDeleteConfirm() {\n  if (!deleteTarget.value) return;\n  const deletePath = deleteTarget.value.path;\n  await deleteEntry(deleteTarget.value);\n\n  if (deletePath && uiStore.selectedFsEntry?.path === deletePath) {\n    uiStore.selectedFsEntry = null;\n  }\n\n  if (\n    selectionStore.selectedEntity?.source === 'fileManager' &&\n    (selectionStore.selectedEntity.path\n      ? selectionStore.selectedEntity.path === deletePath\n      : selectionStore.selectedEntity.name === deleteTarget.value.name)\n  ) {\n    selectionStore.clearSelection();\n  }\n\n  // Delay closing the modal for a tick to allow the click event loop to finish\n  // This prevents Nuxt UI / Vue from crashing when trying to find nextSibling of the clicked button\n  // during the modal's unmount phase\n  setTimeout(() => {\n    isDeleteConfirmModalOpen.value = false;\n\n    // Wait for the modal transition to finish before clearing the reference\n    setTimeout(() => {\n      deleteTarget.value = null;\n    }, 300);\n  }, 0);\n}\n\nasync function handleRename(newName: string) {\n  if (!renameTarget.value) return;\n\n  const trimmed = newName.trim();\n  if (!trimmed) {\n    toast.add({\n      color: 'red',\n      title: t('common.rename', 'Rename'),\n      description: t('common.validation.required', 'Name is required.'),\n    });\n    return;\n  }\n\n  if (trimmed.includes('/')) {\n    toast.add({\n      color: 'red',\n      title: t('common.rename', 'Rename'),\n      description: t('common.validation.invalidName', 'Name contains invalid characters.'),\n    });\n    return;\n  }\n\n  if (trimmed === '.' || trimmed === '..') {\n    toast.add({\n      color: 'red',\n      title: t('common.rename', 'Rename'),\n      description: t('common.validation.invalidName', 'Name contains invalid characters.'),\n    });\n    return;\n  }\n\n  await renameEntry(renameTarget.value, trimmed);\n  renameTarget.value = null;\n}\n\nfunction onFileAction(\n  action:\n    | 'createFolder'\n    | 'rename'\n    | 'info'\n    | 'delete'\n    | 'createProxy'\n    | 'cancelProxy'\n    | 'deleteProxy'\n    | 'upload'\n    | 'createProxyForFolder',\n  entry: FsEntry,\n) {\n  if (action === 'createFolder') {\n    openCreateFolderModal(entry);\n  } else if (action === 'upload') {\n    if (entry.kind !== 'directory') return;\n    directoryUploadTarget.value = entry;\n    directoryUploadInput.value?.click();\n  } else if (action === 'rename') {\n    renameTarget.value = entry;\n    isRenameModalOpen.value = true;\n  } else if (action === 'info') {\n    openFileInfoModal(entry);\n  } else if (action === 'delete') {\n    openDeleteConfirmModal(entry);\n  } else if (action === 'createProxy') {\n    const proxyStore = useProxyStore();\n    if (entry.kind === 'file' && entry.path) {\n      void proxyStore.generateProxy(entry.handle as FileSystemFileHandle, entry.path);\n    }\n  } else if (action === 'cancelProxy') {\n    const proxyStore = useProxyStore();\n    if (entry.kind === 'file' && entry.path) {\n      void proxyStore.cancelProxyGeneration(entry.path);\n    }\n  } else if (action === 'deleteProxy') {\n    const proxyStore = useProxyStore();\n    if (entry.kind === 'file' && entry.path) {\n      void proxyStore.deleteProxy(entry.path);\n    }\n  } else if (action === 'createProxyForFolder') {\n    const proxyStore = useProxyStore();\n    if (entry.kind === 'directory' && entry.path !== undefined) {\n      const dirPath = entry.path;\n      const dirHandle = entry.handle as FileSystemDirectoryHandle;\n\n      (async () => {\n        const collect = async (dir: FileSystemDirectoryHandle, bPath: string) => {\n          const iterator =\n            (dir as FsDirectoryHandleWithIteration).values?.() ??\n            (dir as FsDirectoryHandleWithIteration).entries?.();\n          if (!iterator) return;\n\n          for await (const value of iterator) {\n            const handle = (Array.isArray(value) ? value[1] : value) as\n              | FileSystemFileHandle\n              | FileSystemDirectoryHandle;\n\n            const fullPath = bPath ? `${bPath}/${handle.name}` : handle.name;\n\n            if (handle.kind === 'file') {\n              const ext = handle.name.split('.').pop()?.toLowerCase() ?? '';\n              if (['mp4', 'mov', 'avi', 'mkv', 'webm'].includes(ext)) {\n                if (\n                  !proxyStore.existingProxies.has(fullPath) &&\n                  !proxyStore.generatingProxies.has(fullPath)\n                ) {\n                  void proxyStore.generateProxy(handle as FileSystemFileHandle, fullPath);\n                }\n              }\n            } else if (handle.kind === 'directory') {\n              await collect(handle as FileSystemDirectoryHandle, fullPath);\n            }\n          }\n        };\n\n        try {\n          // If tree children are already loaded, we can skip existing/generating even faster\n          // but walking handles is more accurate if the tree is not fully expanded.\n          // We walk handles starting from the current directory\n          await collect(dirHandle, dirPath);\n        } catch (e) {\n          console.error('Failed to walk folder for proxy creation', e);\n        }\n      })();\n    }\n  }\n}\n\nfunction triggerFileUpload() {\n  fileInput.value?.click();\n}\n\nfunction onSortModeChange(v: 'name' | 'modified') {\n  setSortMode(v);\n  const selectedPath = uiStore.selectedFsEntry?.path;\n  void loadProjectDirectory().then(() => {\n    if (!selectedPath) return;\n    if (uiStore.selectedFsEntry?.path !== selectedPath) return;\n    focusStore.setTempFocus('left');\n  });\n}\n\nfunction onFileSelect(e: Event) {\n  const target = e.target as HTMLInputElement;\n  if (target.files) {\n    const files = Array.from(target.files);\n    target.value = '';\n    handleFiles(files);\n  }\n}\n\nasync function onDirectoryFileSelect(e: Event) {\n  const input = e.target as HTMLInputElement;\n  const files = input.files ? Array.from(input.files) : [];\n  input.value = '';\n\n  const entry = directoryUploadTarget.value;\n  directoryUploadTarget.value = null;\n  if (!entry || entry.kind !== 'directory') return;\n  if (!files || files.length === 0) return;\n\n  await handleFiles(files, entry.handle as FileSystemDirectoryHandle, entry.path);\n  await loadProjectDirectory();\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col h-full bg-ui-bg-elevated border-r border-ui-border transition-colors duration-200 min-w-0 overflow-hidden relative\"\n    :class=\"{\n      'bg-ui-bg-accent outline-2 outline-primary-500/50 -outline-offset-2 z-10': isDragging,\n      'outline-2 outline-primary-500/60 -outline-offset-2 z-10': focusStore.isPanelFocused('left'),\n    }\"\n    @pointerdown.capture=\"focusStore.setTempFocus('left')\"\n    @dragover.prevent=\"onDragOver\"\n    @dragleave.prevent=\"onDragLeave\"\n    @drop.prevent=\"onDrop\"\n  >\n    <!-- Hidden file input -->\n    <input ref=\"fileInput\" type=\"file\" multiple class=\"hidden\" @change=\"onFileSelect\" />\n    <input\n      ref=\"directoryUploadInput\"\n      type=\"file\"\n      multiple\n      class=\"hidden\"\n      @change=\"onDirectoryFileSelect\"\n    />\n\n    <!-- Header / Tabs -->\n    <div class=\"flex items-center gap-4 px-3 py-2 border-b border-ui-border shrink-0 select-none\">\n      <button\n        class=\"text-xs font-semibold uppercase tracking-wider transition-colors outline-none\"\n        :class=\"\n          activeTab === 'files' ? 'text-primary-400' : 'text-ui-text-muted hover:text-ui-text'\n        \"\n        @click=\"activeTab = 'files'\"\n      >\n        {{ t('videoEditor.fileManager.tabs.files', 'Files') }}\n      </button>\n      <button\n        class=\"text-xs font-semibold uppercase tracking-wider transition-colors outline-none\"\n        :class=\"\n          activeTab === 'effects' ? 'text-primary-400' : 'text-ui-text-muted hover:text-ui-text'\n        \"\n        @click=\"activeTab = 'effects'\"\n      >\n        {{ t('videoEditor.fileManager.tabs.effects', 'Effects') }}\n      </button>\n      <button\n        class=\"text-xs font-semibold uppercase tracking-wider transition-colors outline-none\"\n        :class=\"\n          activeTab === 'history' ? 'text-primary-400' : 'text-ui-text-muted hover:text-ui-text'\n        \"\n        @click=\"activeTab = 'history'\"\n      >\n        {{ t('videoEditor.fileManager.tabs.history', 'History') }}\n      </button>\n    </div>\n\n    <!-- Actions Toolbar (only for Files tab) -->\n    <div\n      v-if=\"activeTab === 'files' && projectStore.currentProjectName\"\n      class=\"flex items-center gap-1 px-2 py-1 bg-ui-bg-accent/30 border-b border-ui-border/50\"\n    >\n      <UButton\n        icon=\"i-heroicons-folder-plus\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        size=\"xs\"\n        :title=\"t('videoEditor.fileManager.actions.createFolder')\"\n        @click=\"openCreateFolderModal(null)\"\n      />\n      <UButton\n        icon=\"i-heroicons-document-plus\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        size=\"xs\"\n        :title=\"t('videoEditor.fileManager.actions.createTimeline', 'Create Timeline')\"\n        @click=\"onCreateTimeline\"\n      />\n      <UButton\n        icon=\"i-heroicons-arrow-up-tray\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        size=\"xs\"\n        :title=\"t('videoEditor.fileManager.actions.uploadFiles')\"\n        @click=\"triggerFileUpload\"\n      />\n      <UButton\n        :icon=\"uiStore.showHiddenFiles ? 'i-heroicons-eye' : 'i-heroicons-eye-slash'\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        size=\"xs\"\n        :title=\"t('videoEditor.fileManager.actions.toggleHiddenFiles', 'Show/Hide hidden files')\"\n        @click=\"uiStore.showHiddenFiles = !uiStore.showHiddenFiles\"\n      />\n      <UButton\n        icon=\"i-heroicons-arrow-path\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        size=\"xs\"\n        :title=\"t('videoEditor.fileManager.actions.syncTreeTooltip', 'Refresh file tree')\"\n        :disabled=\"isLoading || !projectStore.currentProjectName\"\n        @click=\"loadProjectDirectory\"\n      />\n\n      <div class=\"ml-auto w-20\">\n        <USelectMenu\n          :model-value=\"sortMode\"\n          :items=\"[\n            { value: 'name', label: t('videoEditor.fileManager.sort.name', 'Name') },\n            { value: 'modified', label: t('videoEditor.fileManager.sort.modified', 'Modified') },\n          ]\"\n          value-key=\"value\"\n          label-key=\"label\"\n          size=\"xs\"\n          class=\"w-full\"\n          @update:model-value=\"(v: any) => onSortModeChange(v?.value ?? v)\"\n        />\n      </div>\n    </div>\n\n    <!-- Content -->\n    <FileManagerFiles\n      v-if=\"activeTab === 'files'\"\n      :is-dragging=\"isDragging\"\n      :is-loading=\"isLoading\"\n      :is-api-supported=\"isApiSupported\"\n      :root-entries=\"rootEntries\"\n      :get-file-icon=\"getFileIcon\"\n      :find-entry-by-path=\"findEntryByPath\"\n      :move-entry=\"moveEntry\"\n      :get-project-root-dir-handle=\"getProjectRootDirHandle\"\n      :handle-files=\"handleFiles\"\n      @toggle=\"toggleDirectory\"\n      @action=\"onFileAction\"\n      @create-folder=\"openCreateFolderModal\"\n    />\n    <FileManagerEffects v-else-if=\"activeTab === 'effects'\" />\n    <FileManagerHistory v-else-if=\"activeTab === 'history'\" />\n\n    <CreateFolderModal v-model:open=\"isCreateFolderModalOpen\" @create=\"handleCreateFolder\" />\n\n    <RenameModal\n      v-model:open=\"isRenameModalOpen\"\n      :initial-name=\"renameTarget?.name\"\n      @rename=\"handleRename\"\n    />\n\n    <FileInfoModal v-model:open=\"isFileInfoModalOpen\" :info=\"currentFileInfo\" />\n\n    <UiConfirmModal\n      v-model:open=\"isDeleteConfirmModalOpen\"\n      :title=\"t('common.delete', 'Delete')\"\n      :description=\"\n        t(\n          'common.confirmDelete',\n          'Are you sure you want to delete this? This action cannot be undone.',\n        )\n      \"\n      color=\"error\"\n      icon=\"i-heroicons-exclamation-triangle\"\n      @confirm=\"handleDeleteConfirm\"\n    >\n      <div>\n        <div v-show=\"deleteTarget\" class=\"mt-2 text-sm font-medium text-ui-text\">\n          {{ deleteTarget?.name }}\n        </div>\n        <div v-if=\"deleteTarget?.path\" class=\"mt-1 text-xs text-ui-text-muted break-all\">\n          {{\n            deleteTarget.kind === 'directory'\n              ? t('common.folder', 'Folder')\n              : t('common.file', 'File')\n          }}\n          Â·\n          {{ deleteTarget.path }}\n        </div>\n\n        <div\n          v-if=\"deleteTarget?.kind === 'file' && timelinesUsingDeleteTarget.length > 0\"\n          class=\"mt-3 p-2 rounded border border-red-500/40 bg-red-500/10\"\n        >\n          <div class=\"text-xs font-semibold text-red-400\">\n            {{ t('videoEditor.fileManager.delete.usedWarning', 'This file is used in timelines:') }}\n          </div>\n          <div class=\"mt-1 flex flex-col gap-1\">\n            <div\n              v-for=\"tl in timelinesUsingDeleteTarget\"\n              :key=\"tl.timelinePath\"\n              class=\"text-xs text-ui-text break-all\"\n            >\n              {{ tl.timelineName }}\n              <span class=\"text-[10px] text-ui-text-muted\">({{ tl.timelinePath }})</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </UiConfirmModal>\n\n    <!-- Global Drag Highlight / Hint -->\n    <div\n      v-if=\"uiStore.isGlobalDragging && !isDragging\"\n      class=\"absolute inset-0 z-100 flex flex-col items-center justify-center bg-primary-500/10 border-4 border-dashed border-primary-500/50 m-2 rounded-2xl pointer-events-none transition-all duration-300\"\n    >\n      <div\n        class=\"flex flex-col items-center bg-ui-bg-elevated/90 px-6 py-4 rounded-xl border border-primary-500/30 shadow-xl\"\n      >\n        <UIcon name=\"i-heroicons-folder-arrow-down\" class=\"w-10 h-10 text-primary-400 mb-2\" />\n        <p class=\"text-sm font-bold text-primary-400 text-center uppercase tracking-wider\">\n          {{ t('videoEditor.fileManager.actions.dropZone', 'Move to folder') }}\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/MediaPlayer.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/Monitor.vue","messages":[{"ruleId":"vue/multi-word-component-names","severity":1,"message":"Component name \"Monitor\" should always be multi-word.","line":1,"column":1,"messageId":"unexpected"},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'nextTick' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":20,"messageId":"unusedVar","endLine":2,"endColumn":28,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"nextTick"},"fix":{"range":[42,52],"text":""},"desc":"Remove unused variable \"nextTick\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'playbackDirection' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":39,"column":7,"messageId":"unusedVar","endLine":39,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onViewportWheel' is defined but never used. Allowed unused vars must match /^_/u.","line":252,"column":10,"messageId":"unusedVar","endLine":252,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'togglePlayback' is defined but never used. Allowed unused vars must match /^_/u.","line":297,"column":10,"messageId":"unusedVar","endLine":297,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":335,"column":35,"messageId":"unexpectedAny","endLine":335,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8996,8999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8996,8999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getCanvasFromContainer' is defined but never used. Allowed unused vars must match /^_/u.","line":354,"column":10,"messageId":"unusedVar","endLine":354,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'canvasToWebpBlob' is defined but never used. Allowed unused vars must match /^_/u.","line":361,"column":16,"messageId":"unusedVar","endLine":361,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, nextTick, onBeforeUnmount, onMounted, ref } from 'vue';\nimport { storeToRefs } from 'pinia';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useProxyStore } from '~/stores/proxy.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useMonitorTimeline } from '~/composables/monitor/useMonitorTimeline';\nimport { useMonitorDisplay } from '~/composables/monitor/useMonitorDisplay';\nimport { useMonitorPlayback } from '~/composables/monitor/useMonitorPlayback';\nimport { useMonitorCore } from '~/composables/monitor/useMonitorCore';\nimport WheelSlider from '~/components/ui/WheelSlider.vue';\nimport { buildStopFrameBaseName } from '~/utils/stop-frames';\nimport { getExportWorkerClient, setExportHostApi } from '~/utils/video-editor/worker-client';\nimport { IMAGES_DIR_NAME } from '~/utils/constants';\n\nconst { t } = useI18n();\nconst toast = useToast();\nconst projectStore = useProjectStore();\nconst timelineStore = useTimelineStore();\nconst proxyStore = useProxyStore();\nconst focusStore = useFocusStore();\nconst workspaceStore = useWorkspaceStore();\nconst { isPlaying, currentTime, duration, audioVolume, audioMuted } = storeToRefs(timelineStore);\n\nconst playbackSpeedOptions = [\n  { label: '0.5x', value: 0.5 },\n  { label: '0.75x', value: 0.75 },\n  { label: '1x', value: 1 },\n  { label: '1.25x', value: 1.25 },\n  { label: '1.5x', value: 1.5 },\n  { label: '1.75x', value: 1.75 },\n  { label: '2x', value: 2 },\n  { label: '3x', value: 3 },\n  { label: '5x', value: 5 },\n];\n\nconst playbackDirection = computed(() =>\n  timelineStore.playbackSpeed < 0 ? 'backward' : 'forward',\n);\n\nconst selectedPlaybackSpeedOption = computed(() => {\n  const abs = Math.abs(timelineStore.playbackSpeed);\n  return playbackSpeedOptions.find((o) => o.value === abs) ?? playbackSpeedOptions[2];\n});\n\nconst {\n  videoItems,\n  workerTimelineClips,\n  workerAudioClips,\n  rawWorkerTimelineClips,\n  rawWorkerAudioClips,\n  safeDurationUs,\n  clipSourceSignature,\n  clipLayoutSignature,\n  audioClipSourceSignature,\n  audioClipLayoutSignature,\n} = useMonitorTimeline();\n\nconst {\n  containerEl,\n  viewportEl,\n  renderWidth,\n  renderHeight,\n  getCanvasWrapperStyle,\n  getCanvasInnerStyle,\n  updateCanvasDisplaySize,\n} = useMonitorDisplay();\n\nconst {\n  isLoading,\n  loadError,\n  scheduleRender,\n  scheduleBuild,\n  clampToTimeline,\n  updateStoreTime,\n  audioEngine,\n  useProxyInMonitor,\n  setCurrentTimeProvider,\n} = useMonitorCore({\n  projectStore,\n  timelineStore,\n  proxyStore,\n  monitorTimeline: {\n    videoItems,\n    workerTimelineClips,\n    workerAudioClips,\n    rawWorkerTimelineClips,\n    rawWorkerAudioClips,\n    safeDurationUs,\n    clipSourceSignature,\n    clipLayoutSignature,\n    audioClipSourceSignature,\n    audioClipLayoutSignature,\n  },\n  monitorDisplay: {\n    containerEl,\n    viewportEl,\n    renderWidth,\n    renderHeight,\n    updateCanvasDisplaySize,\n  },\n});\n\nconst canInteractPlayback = computed(\n  () => !isLoading.value && (safeDurationUs.value > 0 || videoItems.value.length > 0),\n);\n\nfunction blurActiveElement() {\n  (document.activeElement as HTMLElement | null)?.blur?.();\n}\n\nconst previewResolutions = computed(() => {\n  const projectHeight = projectStore.projectSettings.project.height;\n  const baseResolutions = [\n    { label: '2160p', value: 2160 },\n    { label: '1440p', value: 1440 },\n    { label: '1080p', value: 1080 },\n    { label: '720p', value: 720 },\n    { label: '480p', value: 480 },\n    { label: '360p', value: 360 },\n    { label: '240p', value: 240 },\n    { label: '144p', value: 144 },\n  ];\n\n  return baseResolutions.map((res) => ({\n    ...res,\n    isProject: res.value === projectHeight,\n  }));\n});\n\nconst timecodeEl = ref<HTMLElement | null>(null);\nconst { uiCurrentTimeUs, getLocalCurrentTimeUs, setTimecodeEl } = useMonitorPlayback({\n  isLoading,\n  loadError,\n  isPlaying,\n  currentTime,\n  duration,\n  safeDurationUs,\n  getFps: () => projectStore.projectSettings?.project?.fps,\n  clampToTimeline,\n  updateStoreTime,\n  scheduleRender,\n  audioEngine,\n});\n\nsetCurrentTimeProvider(getLocalCurrentTimeUs);\n\nonMounted(() => {\n  setTimecodeEl(timecodeEl.value);\n  timelineStore.setPlaybackGestureHandler((nextPlaying) => {\n    if (nextPlaying) {\n      audioEngine.resumeContext();\n    }\n  });\n});\n\nconst isPreviewSelected = ref(false);\n\nconst isPanning = ref(false);\nconst panStart = ref({ x: 0, y: 0 });\nconst panOrigin = ref({ x: 0, y: 0 });\n\nconst panX = computed({\n  get: () => projectStore.projectSettings.monitor?.panX ?? 0,\n  set: (v: number) => {\n    if (!projectStore.projectSettings.monitor) return;\n    projectStore.projectSettings.monitor.panX = v;\n  },\n});\n\nconst panY = computed({\n  get: () => projectStore.projectSettings.monitor?.panY ?? 0,\n  set: (v: number) => {\n    if (!projectStore.projectSettings.monitor) return;\n    projectStore.projectSettings.monitor.panY = v;\n  },\n});\n\nconst workspaceStyle = computed(() => {\n  return {\n    transform: `translate(${panX.value}px, ${panY.value}px)`,\n  };\n});\n\nfunction centerMonitor() {\n  if (!projectStore.projectSettings.monitor) return;\n  projectStore.projectSettings.monitor.panX = 0;\n  projectStore.projectSettings.monitor.panY = 0;\n}\n\nfunction onPreviewPointerDown(event: PointerEvent) {\n  if (event.button !== 0) return;\n  isPreviewSelected.value = true;\n  event.stopPropagation();\n}\n\nfunction onViewportPointerDown(event: PointerEvent) {\n  const workspaceStore = useWorkspaceStore();\n  const settings = workspaceStore.userSettings?.mouse?.monitor ?? {\n    wheel: 'zoom',\n    wheelShift: 'scroll_horizontal',\n    middleClick: 'pan',\n  };\n\n  // Middle click (button 1)\n  if (event.button === 1) {\n    if (settings?.middleClick === 'pan') {\n      isPanning.value = true;\n      panStart.value = { x: event.clientX, y: event.clientY };\n      panOrigin.value = { x: panX.value, y: panY.value };\n      (event.currentTarget as HTMLElement | null)?.setPointerCapture(event.pointerId);\n      event.preventDefault();\n    }\n    return;\n  }\n}\n\nfunction onViewportPointerMove(event: PointerEvent) {\n  if (!isPanning.value) return;\n  const dx = event.clientX - panStart.value.x;\n  const dy = event.clientY - panStart.value.y;\n  panX.value = panOrigin.value.x + dx;\n  panY.value = panOrigin.value.y + dy;\n}\n\nfunction stopPan(event?: PointerEvent) {\n  if (!isPanning.value) return;\n  isPanning.value = false;\n  if (event) {\n    try {\n      (event.currentTarget as HTMLElement | null)?.releasePointerCapture(event.pointerId);\n    } catch {\n      // ignore\n    }\n  }\n}\n\nfunction onWindowPointerUp() {\n  isPanning.value = false;\n}\n\nonMounted(() => {\n  window.addEventListener('pointerup', onWindowPointerUp);\n});\n\nonBeforeUnmount(() => {\n  window.removeEventListener('pointerup', onWindowPointerUp);\n});\n\nfunction onViewportWheel(e: WheelEvent) {\n  if (e.defaultPrevented) return;\n\n  const isShift = e.shiftKey;\n  const workspaceStore = useWorkspaceStore();\n  const settings = workspaceStore.userSettings?.mouse?.monitor ?? {\n    wheel: 'zoom',\n    wheelShift: 'scroll_horizontal',\n    middleClick: 'pan',\n  };\n\n  const action = isShift ? settings.wheelShift : settings.wheel;\n\n  if (action === 'none') {\n    e.preventDefault();\n    return;\n  }\n\n  // Calculate delta amount based on event\n  // Some browsers use deltaX for shift+wheel, some keep deltaY but set shiftKey\n  const isHorizontalScroll = e.deltaX !== 0 && Math.abs(e.deltaX) > Math.abs(e.deltaY);\n  const delta = isHorizontalScroll ? e.deltaX : e.deltaY;\n  if (!Number.isFinite(delta) || delta === 0) return;\n\n  if (action === 'zoom') {\n    e.preventDefault();\n    // Use pan properties to implement zoom later if needed,\n    // currently just center map as fallback\n    // TODO: implement actual zoom\n    return;\n  }\n\n  if (action === 'scroll_vertical') {\n    e.preventDefault();\n    panY.value -= delta;\n    return;\n  }\n\n  if (action === 'scroll_horizontal') {\n    e.preventDefault();\n    panX.value -= delta;\n    return;\n  }\n}\n\nfunction togglePlayback() {\n  if (isLoading.value) return;\n\n  // If preview build failed, attempt a rebuild instead of permanently blocking playback controls.\n  if (loadError.value) {\n    loadError.value = null;\n    scheduleBuild();\n    return;\n  }\n\n  timelineStore.togglePlayback();\n}\n\nfunction setPlayback(params: { direction: 'forward' | 'backward'; speed: number }) {\n  if (isLoading.value) return;\n  if (!canInteractPlayback.value) return;\n\n  const finalSpeed = params.direction === 'backward' ? -params.speed : params.speed;\n\n  if (timelineStore.isPlaying && timelineStore.playbackSpeed === finalSpeed) {\n    timelineStore.togglePlayback();\n    blurActiveElement();\n    return;\n  }\n\n  timelineStore.setPlaybackSpeed(finalSpeed);\n  if (!timelineStore.isPlaying) {\n    timelineStore.togglePlayback();\n  }\n\n  blurActiveElement();\n}\n\nfunction rewindToStart() {\n  timelineStore.currentTime = 0;\n  blurActiveElement();\n}\n\nfunction onPlaybackSpeedChange(v: any) {\n  if (!v) return;\n  const val = Number(v.value ?? v);\n  const isPlaying = timelineStore.isPlaying;\n  const currentSpeed = timelineStore.playbackSpeed;\n  const direction = currentSpeed < 0 ? -1 : 1;\n  timelineStore.setPlaybackSpeed(val * direction);\n  if (!isPlaying) {\n    // Only update speed state, don't start playback automatically when selecting speed\n  }\n}\n\nfunction toggleMute() {\n  timelineStore.toggleAudioMuted();\n  blurActiveElement();\n}\n\nconst isSavingStopFrame = ref(false);\n\nfunction getCanvasFromContainer(): HTMLCanvasElement | null {\n  const container = containerEl.value;\n  if (!container) return null;\n  const canvas = container.querySelector('canvas');\n  return canvas instanceof HTMLCanvasElement ? canvas : null;\n}\n\nasync function canvasToWebpBlob(canvas: HTMLCanvasElement, quality: number): Promise<Blob> {\n  return await new Promise((resolve, reject) => {\n    canvas.toBlob(\n      (blob) => {\n        if (!blob) {\n          reject(new Error('Failed to create snapshot blob'));\n          return;\n        }\n        resolve(blob);\n      },\n      'image/webp',\n      quality,\n    );\n  });\n}\n\nasync function createStopFrameSnapshot() {\n  if (isSavingStopFrame.value) return;\n  if (isLoading.value) return;\n  if (loadError.value) return;\n\n  const timelineName =\n    projectStore.currentFileName ||\n    projectStore.currentTimelinePath ||\n    timelineStore.timelineDoc?.name ||\n    'timeline';\n\n  const fps = projectStore.projectSettings?.project?.fps ?? 30;\n  const timeUs = uiCurrentTimeUs.value;\n\n  const qualityPercent = workspaceStore.userSettings.stopFrames?.qualityPercent ?? 85;\n  const quality = Math.max(0.01, Math.min(1, qualityPercent / 100));\n  const extension = 'webp';\n  const baseName = buildStopFrameBaseName({\n    timelineName,\n    timeUs,\n    fps,\n  });\n\n  let filename = `${baseName}.${extension}`;\n  let attempt = 0;\n  // Try to find next available incremental suffix if file already exists.\n  // Limits attempts to avoid infinite loop in case of unexpected errors.\n  const MAX_ATTEMPTS = 10_000;\n  while (attempt < MAX_ATTEMPTS) {\n    const existingHandle = await projectStore.getProjectFileHandleByRelativePath({\n      relativePath: `${IMAGES_DIR_NAME}/stop_frames/${filename}`,\n      create: false,\n    });\n    if (!existingHandle) {\n      break;\n    }\n    attempt += 1;\n    const suffix = String(attempt).padStart(3, '0');\n    filename = `${baseName}_${suffix}.${extension}`;\n  }\n\n  isSavingStopFrame.value = true;\n  try {\n    const exportWidth = Math.round(Number(projectStore.projectSettings?.project?.width ?? 0));\n    const exportHeight = Math.round(Number(projectStore.projectSettings?.project?.height ?? 0));\n\n    // Request export worker to render a high quality frame directly\n    const { client } = getExportWorkerClient();\n    setExportHostApi({\n      getFileHandleByPath: async (path: string) => projectStore.getFileHandleByPath(path),\n      onExportProgress: () => {},\n    });\n\n    const clipsPayload = JSON.parse(\n      JSON.stringify(rawWorkerTimelineClips.value ?? workerTimelineClips.value),\n    );\n\n    const blob = await client.extractFrameToBlob(\n      timeUs,\n      exportWidth,\n      exportHeight,\n      clipsPayload,\n      quality,\n    );\n\n    if (!blob) {\n      throw new Error('Worker returned empty blob');\n    }\n\n    const fileHandle = await projectStore.getProjectFileHandleByRelativePath({\n      relativePath: `${IMAGES_DIR_NAME}/stop_frames/${filename}`,\n      create: true,\n    });\n\n    if (!fileHandle) {\n      toast.add({\n        color: 'red',\n        title: 'Snapshot failed',\n        description: 'Could not access project folder for writing',\n      });\n      return;\n    }\n\n    const writable = await fileHandle.createWritable();\n    await writable.write(blob);\n    await writable.close();\n\n    toast.add({\n      color: 'primary',\n      title: 'Snapshot created',\n      description: `Saved to ${IMAGES_DIR_NAME}/stop_frames/${filename}`,\n    });\n  } catch (err) {\n    console.error('[Monitor] Failed to create stop frame snapshot', err);\n    toast.add({\n      color: 'red',\n      title: 'Snapshot failed',\n      description: err instanceof Error ? err.message : 'Unknown error',\n    });\n  } finally {\n    isSavingStopFrame.value = false;\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col h-full bg-ui-bg-elevated border-r border-ui-border min-w-0 min-h-0\"\n    :class=\"{\n      'outline-2 outline-primary-500/60 -outline-offset-2 z-10':\n        focusStore.isPanelFocused('monitor'),\n    }\"\n    @pointerdown.capture=\"focusStore.setMainFocus('monitor')\"\n  >\n    <!-- Header -->\n    <div\n      class=\"flex items-center justify-between px-2 py-1.5 border-b border-ui-border shrink-0 bg-ui-bg-elevated\"\n    >\n      <span class=\"text-xs font-semibold text-ui-text-muted uppercase tracking-wider\">\n        {{ t('granVideoEditor.monitor.title', 'Monitor') }}\n      </span>\n      <div class=\"flex items-center gap-2 shrink-0\">\n        <UTooltip :text=\"t('granVideoEditor.monitor.snapshot', 'Create snapshot')\">\n          <UButton\n            size=\"xs\"\n            color=\"neutral\"\n            variant=\"ghost\"\n            icon=\"i-heroicons-camera\"\n            :loading=\"isSavingStopFrame\"\n            :disabled=\"isSavingStopFrame || isLoading || Boolean(loadError)\"\n            @click=\"createStopFrameSnapshot\"\n          />\n        </UTooltip>\n\n        <UTooltip :text=\"t('granVideoEditor.monitor.center', 'Center')\">\n          <UButton\n            size=\"xs\"\n            color=\"neutral\"\n            variant=\"ghost\"\n            icon=\"i-heroicons-arrows-pointing-in\"\n            @click=\"centerMonitor\"\n          />\n        </UTooltip>\n\n        <UTooltip :text=\"t('granVideoEditor.monitor.useProxy', 'Use proxy')\">\n          <UButton\n            v-if=\"projectStore.projectSettings.monitor\"\n            size=\"xs\"\n            :color=\"useProxyInMonitor ? 'primary' : 'neutral'\"\n            :variant=\"useProxyInMonitor ? 'soft' : 'ghost'\"\n            icon=\"i-heroicons-bolt\"\n            @click=\"projectStore.projectSettings.monitor.useProxy = !useProxyInMonitor\"\n          />\n        </UTooltip>\n\n        <div class=\"w-28\">\n          <USelectMenu\n            v-if=\"projectStore.projectSettings.monitor\"\n            :model-value=\"\n              (previewResolutions.find(\n                (r) => r.value === projectStore.projectSettings.monitor.previewResolution,\n              ) || previewResolutions[2]) as any\n            \"\n            :items=\"previewResolutions\"\n            value-key=\"value\"\n            label-key=\"label\"\n            size=\"xs\"\n            class=\"w-full\"\n            @update:model-value=\"\n              (v: any) => {\n                if (v) projectStore.projectSettings.monitor.previewResolution = v.value ?? v;\n              }\n            \"\n          >\n            <template #leading=\"{ modelValue }\">\n              <UIcon\n                v-if=\"(modelValue as any)?.isProject\"\n                name=\"i-heroicons-star-20-solid\"\n                class=\"w-3 h-3 text-primary-500 shrink-0\"\n                :title=\"t('granVideoEditor.monitor.projectResolutionHint')\"\n              />\n            </template>\n            <template #item-label=\"{ item }\">\n              <span :class=\"{ 'text-primary-500 font-medium': item.isProject }\">\n                {{ item.label }}\n              </span>\n            </template>\n            <template #item-trailing=\"{ item }\">\n              <UIcon\n                v-if=\"item.isProject\"\n                name=\"i-heroicons-star-20-solid\"\n                class=\"w-3.5 h-3.5 text-primary-500 shrink-0\"\n                :title=\"t('granVideoEditor.monitor.projectResolutionHint')\"\n              />\n            </template>\n          </USelectMenu>\n        </div>\n      </div>\n    </div>\n\n    <!-- Video area -->\n    <div\n      ref=\"viewportEl\"\n      class=\"flex-1 min-h-0 min-w-0 overflow-hidden relative\"\n      @pointerdown=\"onViewportPointerDown\"\n      @pointermove=\"onViewportPointerMove\"\n      @pointerup=\"stopPan\"\n      @pointercancel=\"stopPan\"\n    >\n      <div class=\"absolute inset-0\">\n        <div class=\"absolute inset-0\" :style=\"workspaceStyle\">\n          <div class=\"absolute inset-0 flex items-center justify-center\">\n            <div\n              class=\"shrink-0 relative\"\n              :style=\"getCanvasWrapperStyle()\"\n              @pointerdown=\"onPreviewPointerDown\"\n            >\n              <div ref=\"containerEl\" :style=\"getCanvasInnerStyle()\" />\n              <svg\n                class=\"absolute inset-0 overflow-visible\"\n                :width=\"renderWidth\"\n                :height=\"renderHeight\"\n                style=\"pointer-events: none\"\n              >\n                <rect\n                  v-if=\"isPreviewSelected\"\n                  x=\"0\"\n                  y=\"0\"\n                  :width=\"renderWidth\"\n                  :height=\"renderHeight\"\n                  fill=\"none\"\n                  :stroke=\"'var(--selection-ring)'\"\n                  stroke-width=\"2\"\n                />\n              </svg>\n            </div>\n          </div>\n        </div>\n\n        <div\n          v-if=\"videoItems.length === 0\"\n          class=\"absolute inset-0 flex flex-col items-center justify-center gap-3 text-ui-text-disabled\"\n        >\n          <UIcon name=\"i-heroicons-play-circle\" class=\"w-16 h-16\" />\n          <p class=\"text-sm\">\n            {{ t('granVideoEditor.monitor.empty', 'No clip selected') }}\n          </p>\n        </div>\n\n        <div\n          v-else-if=\"isLoading\"\n          class=\"absolute inset-0 flex items-center justify-center text-ui-text-muted\"\n        >\n          <UIcon name=\"i-heroicons-arrow-path\" class=\"w-8 h-8 animate-spin\" />\n        </div>\n\n        <div\n          v-else-if=\"loadError\"\n          class=\"absolute inset-0 flex items-center justify-center text-red-500\"\n        >\n          {{ loadError }}\n        </div>\n      </div>\n    </div>\n\n    <!-- Playback controls -->\n    <div\n      class=\"flex flex-wrap items-center justify-center gap-3 px-4 py-3.5 border-t border-ui-border shrink-0 bg-ui-bg-elevated\"\n    >\n      <UButton\n        size=\"md\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-arrow-uturn-left\"\n        :aria-label=\"t('granVideoEditor.monitor.rewind', 'Rewind')\"\n        :disabled=\"!canInteractPlayback\"\n        @click=\"rewindToStart\"\n      />\n\n      <UButton\n        size=\"md\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-backward\"\n        :aria-label=\"t('granVideoEditor.monitor.playBackward', 'Play backward')\"\n        :disabled=\"!canInteractPlayback\"\n        @click=\"\n          setPlayback({ direction: 'backward', speed: selectedPlaybackSpeedOption?.value ?? 1 })\n        \"\n      />\n\n      <UButton\n        size=\"md\"\n        variant=\"solid\"\n        color=\"primary\"\n        :icon=\"timelineStore.isPlaying ? 'i-heroicons-pause' : 'i-heroicons-play'\"\n        :aria-label=\"t('granVideoEditor.monitor.play', 'Play')\"\n        :disabled=\"!canInteractPlayback\"\n        @click=\"\n          setPlayback({ direction: 'forward', speed: selectedPlaybackSpeedOption?.value ?? 1 })\n        \"\n      />\n\n      <div class=\"w-24\">\n        <USelectMenu\n          :model-value=\"selectedPlaybackSpeedOption as any\"\n          :items=\"playbackSpeedOptions\"\n          value-key=\"value\"\n          label-key=\"label\"\n          size=\"sm\"\n          class=\"w-full\"\n          :disabled=\"!canInteractPlayback\"\n          @update:model-value=\"onPlaybackSpeedChange\"\n        />\n      </div>\n\n      <div class=\"flex items-center gap-2.5\">\n        <UButton\n          size=\"sm\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          :icon=\"audioMuted ? 'i-heroicons-speaker-x-mark' : 'i-heroicons-speaker-wave'\"\n          :aria-label=\"\n            audioMuted\n              ? t('granVideoEditor.monitor.audioUnmute', 'Unmute')\n              : t('granVideoEditor.monitor.audioMute', 'Mute')\n          \"\n          @click=\"toggleMute\"\n        />\n\n        <WheelSlider\n          :min=\"0\"\n          :max=\"2\"\n          :step=\"0.05\"\n          :model-value=\"audioMuted ? 0 : audioVolume\"\n          slider-class=\"w-20\"\n          :aria-label=\"t('granVideoEditor.monitor.audioVolume', 'Audio volume')\"\n          @update:model-value=\"(v) => timelineStore.setAudioVolume(Number(v ?? 1))\"\n        />\n\n        <span class=\"text-sm text-ui-text-muted tabular-nums min-w-12\">\n          {{ Math.round((audioMuted ? 0 : audioVolume) * 100) }}%\n        </span>\n      </div>\n      <span ref=\"timecodeEl\" class=\"text-xs text-ui-text-muted ml-2 font-mono tabular-nums\">\n        00:00:00:00 / 00:00:00:00\n      </span>\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/Preview.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uiStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":25,"column":7,"messageId":"unusedVar","endLine":25,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":50,"messageId":"unexpectedAny","endLine":149,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5274,5277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5274,5277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":42,"messageId":"unexpectedAny","endLine":164,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5834,5837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5834,5837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":42,"messageId":"unexpectedAny","endLine":173,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6121,6124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6121,6124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":42,"messageId":"unexpectedAny","endLine":181,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6351,6354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6351,6354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":42,"messageId":"unexpectedAny","endLine":190,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6648,6651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6648,6651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":43,"messageId":"unexpectedAny","endLine":206,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7153,7156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7153,7156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":25,"messageId":"unexpectedAny","endLine":209,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7311,7314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7311,7314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":251,"column":40,"messageId":"unexpectedAny","endLine":251,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8917,8920],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8917,8920],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":261,"column":44,"messageId":"unexpectedAny","endLine":261,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9177,9180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9177,9180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":85,"messageId":"unexpectedAny","endLine":263,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9306,9309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9306,9309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":23,"messageId":"unexpectedAny","endLine":272,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9628,9631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9628,9631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":467,"column":62,"messageId":"unexpectedAny","endLine":467,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15801,15804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15801,15804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":570,"column":43,"messageId":"unexpectedAny","endLine":570,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18971,18974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18971,18974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":586,"column":40,"messageId":"unexpectedAny","endLine":586,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19330,19333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19330,19333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":593,"column":43,"messageId":"unexpectedAny","endLine":593,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19598,19601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19598,19601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":601,"column":40,"messageId":"unexpectedAny","endLine":601,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19839,19842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19839,19842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":610,"column":43,"messageId":"unexpectedAny","endLine":610,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20133,20136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20133,20136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":624,"column":40,"messageId":"unexpectedAny","endLine":624,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20563,20566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20563,20566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":633,"column":43,"messageId":"unexpectedAny","endLine":633,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20858,20861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20858,20861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":641,"column":40,"messageId":"unexpectedAny","endLine":641,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21130,21133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21130,21133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":650,"column":43,"messageId":"unexpectedAny","endLine":650,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21428,21431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21428,21431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":657,"column":38,"messageId":"unexpectedAny","endLine":657,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21692,21695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21692,21695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":667,"column":38,"messageId":"unexpectedAny","endLine":667,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22030,22033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22030,22033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":855,"column":44,"messageId":"unexpectedAny","endLine":855,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27235,27238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27235,27238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":855,"column":73,"messageId":"unexpectedAny","endLine":855,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27264,27267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27264,27267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":877,"column":30,"messageId":"unexpectedAny","endLine":877,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27996,27999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27996,27999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":877,"column":59,"messageId":"unexpectedAny","endLine":877,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28025,28028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28025,28028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, watch, onUnmounted, computed } from 'vue';\nimport { useUiStore } from '~/stores/ui.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport { useProxyStore } from '~/stores/proxy.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useSelectionStore } from '~/stores/selection.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useTimelineMediaUsageStore } from '~/stores/timeline-media-usage.store';\nimport type { TimelineClipItem, TimelineTrack } from '~/timeline/types';\nimport yaml from 'js-yaml';\nimport RenameModal from '~/components/common/RenameModal.vue';\nimport EffectsEditor from '~/components/common/EffectsEditor.vue';\nimport DurationSliderInput from '~/components/ui/DurationSliderInput.vue';\nimport WheelSlider from '~/components/ui/WheelSlider.vue';\nimport ClipTransitionPanel from '~/components/timeline/ClipTransitionPanel.vue';\nimport { isEditableTarget } from '~/utils/hotkeys/hotkeyUtils';\n\ndefineOptions({\n  name: 'PreviewPanel',\n});\n\nconst { t } = useI18n();\nconst uiStore = useUiStore();\nconst projectStore = useProjectStore();\nconst timelineStore = useTimelineStore();\nconst mediaStore = useMediaStore();\nconst proxyStore = useProxyStore();\nconst focusStore = useFocusStore();\nconst selectionStore = useSelectionStore();\nconst timelineMediaUsageStore = useTimelineMediaUsageStore();\n\nfunction clearAllSelection() {\n  selectionStore.clearSelection();\n  timelineStore.clearSelection();\n  timelineStore.selectTrack(null);\n}\n\nconst uploadInputRef = ref<HTMLInputElement | null>(null);\n\nfunction triggerDirectoryUpload() {\n  uploadInputRef.value?.click();\n}\n\nasync function onDirectoryFileSelect(e: Event) {\n  const entry = selectedFsEntry.value;\n  if (!entry || entry.kind !== 'directory') return;\n\n  const input = e.target as HTMLInputElement;\n  const files = input.files ? Array.from(input.files) : [];\n  input.value = '';\n  if (!files || files.length === 0) return;\n\n  const { useFileManager } = await import('~/composables/fileManager/useFileManager');\n  const fm = useFileManager();\n  await fm.handleFiles(files, entry.handle as FileSystemDirectoryHandle, entry.path);\n  await fm.loadProjectDirectory();\n}\n\nconst currentUrl = ref<string | null>(null);\nconst mediaType = ref<'image' | 'video' | 'audio' | 'text' | 'unknown' | null>(null);\nconst textContent = ref<string>('');\nconst previewMode = ref<'original' | 'proxy'>('original');\n\nconst fileInfo = ref<{\n  name: string;\n  kind: string;\n  size?: number;\n  lastModified?: number;\n  metadata?: unknown;\n} | null>(null);\n\ninterface FsDirectoryHandleWithIteration extends FileSystemDirectoryHandle {\n  values?: () => AsyncIterable<FileSystemHandle>;\n  entries?: () => AsyncIterable<[string, FileSystemHandle]>;\n}\n\nasync function computeDirectorySize(\n  dirHandle: FileSystemDirectoryHandle,\n  options?: { maxEntries?: number },\n): Promise<number | undefined> {\n  const maxEntries = options?.maxEntries ?? 25_000;\n  let seen = 0;\n\n  async function walk(handle: FileSystemDirectoryHandle): Promise<number> {\n    const iterator =\n      (handle as FsDirectoryHandleWithIteration).values?.() ??\n      (handle as FsDirectoryHandleWithIteration).entries?.();\n    if (!iterator) return 0;\n\n    let total = 0;\n    for await (const value of iterator) {\n      if (seen >= maxEntries) {\n        throw new Error('Directory too large');\n      }\n      seen += 1;\n\n      const entryHandle = (Array.isArray(value) ? value[1] : value) as\n        | FileSystemFileHandle\n        | FileSystemDirectoryHandle;\n\n      if (entryHandle.kind === 'file') {\n        try {\n          const f = await (entryHandle as FileSystemFileHandle).getFile();\n          total += f.size;\n        } catch {\n          // ignore\n        }\n      } else {\n        total += await walk(entryHandle as FileSystemDirectoryHandle);\n      }\n    }\n    return total;\n  }\n\n  try {\n    return await walk(dirHandle);\n  } catch {\n    return undefined;\n  }\n}\n\nconst selectedClip = computed<TimelineClipItem | null>(() => {\n  const entity = selectionStore.selectedEntity;\n  if (entity?.source !== 'timeline' || entity.kind !== 'clip') return null;\n  const track = timelineStore.timelineDoc?.tracks.find((t) => t.id === entity.trackId);\n  const item = track?.items.find((it) => it.id === entity.itemId);\n  return item && item.kind === 'clip' ? (item as TimelineClipItem) : null;\n});\n\nconst selectedTransition = computed(() => {\n  const entity = selectionStore.selectedEntity;\n  if (entity?.source !== 'timeline' || entity.kind !== 'transition') return null;\n  return { trackId: entity.trackId, itemId: entity.itemId, edge: entity.edge };\n});\n\nconst selectedTransitionClip = computed<TimelineClipItem | null>(() => {\n  const sel = selectedTransition.value;\n  if (!sel) return null;\n  const track = timelineStore.timelineDoc?.tracks.find((t) => t.id === sel.trackId);\n  const item = track?.items.find((it) => it.id === sel.itemId);\n  return item && item.kind === 'clip' ? (item as TimelineClipItem) : null;\n});\n\nconst selectedTransitionValue = computed<import('~/timeline/types').ClipTransition | undefined>(\n  () => {\n    const sel = selectedTransition.value;\n    const clip = selectedTransitionClip.value as any;\n    if (!sel || !clip) return undefined;\n    return sel.edge === 'in' ? clip.transitionIn : clip.transitionOut;\n  },\n);\n\nconst selectedTrack = computed<TimelineTrack | null>(() => {\n  const entity = selectionStore.selectedEntity;\n  if (entity?.source !== 'timeline' || entity.kind !== 'track') return null;\n  const tracks = (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [];\n  return tracks.find((t) => t.id === entity.trackId) ?? null;\n});\n\nconst trackAudioGain = computed({\n  get: () => {\n    const track = selectedTrack.value as any;\n    const v =\n      typeof track?.audioGain === 'number' && Number.isFinite(track.audioGain)\n        ? track.audioGain\n        : 1;\n    return Math.max(0, Math.min(2, v));\n  },\n  set: (val: number) => {\n    if (!selectedTrack.value) return;\n    const track = selectedTrack.value as any;\n    const v = Math.max(0, Math.min(2, Number(val)));\n    timelineStore.updateTrackProperties(track.id, { audioGain: v });\n  },\n});\n\nconst trackAudioBalance = computed({\n  get: () => {\n    const track = selectedTrack.value as any;\n    const v =\n      typeof track?.audioBalance === 'number' && Number.isFinite(track.audioBalance)\n        ? track.audioBalance\n        : 0;\n    return Math.max(-1, Math.min(1, v));\n  },\n  set: (val: number) => {\n    if (!selectedTrack.value) return;\n    const track = selectedTrack.value as any;\n    const v = Math.max(-1, Math.min(1, Number(val)));\n    timelineStore.updateTrackProperties(track.id, { audioBalance: v });\n  },\n});\n\nconst isRenameModalOpen = ref(false);\n\nfunction handleUpdateOpacity(val: number | undefined) {\n  if (!selectedClip.value) return;\n  const safe = typeof val === 'number' && Number.isFinite(val) ? val : 1;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    opacity: safe,\n  });\n}\n\nfunction handleUpdateClipEffects(effects: any[]) {\n  if (!selectedClip.value) return;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    effects: effects as any,\n  });\n}\n\nfunction handleUpdateAudioGain(val: unknown) {\n  if (!selectedClip.value) return;\n  const v = typeof val === 'number' && Number.isFinite(val) ? val : Number(val);\n  const safe = Number.isFinite(v) ? Math.max(0, Math.min(2, v)) : 1;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    audioGain: safe,\n  });\n}\n\nfunction handleUpdateAudioBalance(val: unknown) {\n  if (!selectedClip.value) return;\n  const v = typeof val === 'number' && Number.isFinite(val) ? val : Number(val);\n  const safe = Number.isFinite(v) ? Math.max(-1, Math.min(1, v)) : 0;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    audioBalance: safe,\n  });\n}\n\nfunction handleUpdateBackgroundColor(val: string | undefined) {\n  if (!selectedClip.value) return;\n  if (selectedClip.value.clipType !== 'background') return;\n  const safe = typeof val === 'string' && val.trim().length > 0 ? val.trim() : '#000000';\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    backgroundColor: safe,\n  });\n}\n\nfunction handleUpdateText(val: string | undefined) {\n  if (!selectedClip.value) return;\n  if (selectedClip.value.clipType !== 'text') return;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    text: typeof val === 'string' ? val : '',\n  });\n}\n\nfunction handleUpdateTextStyle(patch: Partial<import('~/timeline/types').TextClipStyle>) {\n  if (!selectedClip.value) return;\n  if (selectedClip.value.clipType !== 'text') return;\n  const curr = ((selectedClip.value as any).style ??\n    {}) as import('~/timeline/types').TextClipStyle;\n  timelineStore.updateClipProperties(selectedClip.value.trackId, selectedClip.value.id, {\n    style: {\n      ...curr,\n      ...patch,\n    },\n  });\n}\n\nfunction handleUpdateTrackEffects(effects: any[]) {\n  if (!selectedTrack.value) return;\n  timelineStore.updateTrackProperties(selectedTrack.value.id, { effects: effects as any });\n}\n\nfunction clampNumber(value: unknown, min: number, max: number): number {\n  const n = typeof value === 'number' && Number.isFinite(value) ? value : 0;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction getSafeTransform(clip: TimelineClipItem): import('~/timeline/types').ClipTransform {\n  const tr = (clip as any).transform ?? {};\n  const scaleRaw = tr.scale ?? {};\n  const scaleX = typeof scaleRaw.x === 'number' && Number.isFinite(scaleRaw.x) ? scaleRaw.x : 1;\n  const scaleY = typeof scaleRaw.y === 'number' && Number.isFinite(scaleRaw.y) ? scaleRaw.y : 1;\n  const linked = Boolean(scaleRaw.linked);\n\n  const positionRaw = tr.position ?? {};\n  const posX =\n    typeof positionRaw.x === 'number' && Number.isFinite(positionRaw.x) ? positionRaw.x : 0;\n  const posY =\n    typeof positionRaw.y === 'number' && Number.isFinite(positionRaw.y) ? positionRaw.y : 0;\n\n  const rotationDeg =\n    typeof tr.rotationDeg === 'number' && Number.isFinite(tr.rotationDeg) ? tr.rotationDeg : 0;\n\n  const anchorRaw = tr.anchor ?? {};\n  const preset =\n    anchorRaw.preset === 'center' ||\n    anchorRaw.preset === 'topLeft' ||\n    anchorRaw.preset === 'topRight' ||\n    anchorRaw.preset === 'bottomLeft' ||\n    anchorRaw.preset === 'bottomRight' ||\n    anchorRaw.preset === 'custom'\n      ? anchorRaw.preset\n      : 'center';\n  const anchorX =\n    typeof anchorRaw.x === 'number' && Number.isFinite(anchorRaw.x) ? anchorRaw.x : 0.5;\n  const anchorY =\n    typeof anchorRaw.y === 'number' && Number.isFinite(anchorRaw.y) ? anchorRaw.y : 0.5;\n\n  return {\n    scale: {\n      x: clampNumber(scaleX, 0.001, 1000),\n      y: clampNumber(scaleY, 0.001, 1000),\n      linked,\n    },\n    position: {\n      x: clampNumber(posX, -1_000_000, 1_000_000),\n      y: clampNumber(posY, -1_000_000, 1_000_000),\n    },\n    rotationDeg: clampNumber(rotationDeg, -36000, 36000),\n    anchor:\n      preset === 'custom'\n        ? { preset, x: clampNumber(anchorX, 0, 1), y: clampNumber(anchorY, 0, 1) }\n        : { preset },\n  };\n}\n\nfunction updateSelectedClipTransform(patch: Partial<import('~/timeline/types').ClipTransform>) {\n  if (!selectedClip.value) return;\n  const clip = selectedClip.value;\n  const current = getSafeTransform(clip);\n  const next: import('~/timeline/types').ClipTransform = {\n    ...current,\n    ...patch,\n    scale: {\n      ...(current.scale ?? { x: 1, y: 1, linked: true }),\n      ...(patch.scale ?? {}),\n    },\n    position: {\n      ...(current.position ?? { x: 0, y: 0 }),\n      ...(patch.position ?? {}),\n    },\n    anchor: {\n      ...(current.anchor ?? { preset: 'center' }),\n      ...(patch.anchor ?? {}),\n    },\n  };\n\n  timelineStore.updateClipProperties(clip.trackId, clip.id, {\n    transform: next,\n  });\n}\n\nconst canEditTransform = computed(() => {\n  const clip = selectedClip.value;\n  if (!clip) return false;\n  return clip.trackId.startsWith('v');\n});\n\nconst anchorPresetOptions = computed(() => [\n  { value: 'center', label: 'Center' },\n  { value: 'topLeft', label: 'Top Left' },\n  { value: 'topRight', label: 'Top Right' },\n  { value: 'bottomLeft', label: 'Bottom Left' },\n  { value: 'bottomRight', label: 'Bottom Right' },\n  { value: 'custom', label: 'Custom' },\n]);\n\nconst transformScaleLinked = computed({\n  get: () => {\n    if (!selectedClip.value) return true;\n    return Boolean(getSafeTransform(selectedClip.value).scale?.linked);\n  },\n  set: (val: boolean) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    const linked = Boolean(val);\n    const x = current.scale?.x ?? 1;\n    const y = current.scale?.y ?? 1;\n    updateSelectedClipTransform({\n      scale: linked ? { x, y: x, linked } : { x, y, linked },\n    });\n  },\n});\n\nconst transformScaleX = computed({\n  get: () => {\n    if (!selectedClip.value) return 1;\n    return getSafeTransform(selectedClip.value).scale?.x ?? 1;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    const linked = Boolean(current.scale?.linked);\n    const x = clampNumber(val, 0.001, 1000);\n    const y = linked ? x : (current.scale?.y ?? 1);\n    updateSelectedClipTransform({ scale: { x, y, linked } });\n  },\n});\n\nconst transformScaleY = computed({\n  get: () => {\n    if (!selectedClip.value) return 1;\n    return getSafeTransform(selectedClip.value).scale?.y ?? 1;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    const linked = Boolean(current.scale?.linked);\n    const y = clampNumber(val, 0.001, 1000);\n    const x = linked ? y : (current.scale?.x ?? 1);\n    updateSelectedClipTransform({ scale: { x, y, linked } });\n  },\n});\n\nconst transformRotationDeg = computed({\n  get: () => {\n    if (!selectedClip.value) return 0;\n    return getSafeTransform(selectedClip.value).rotationDeg ?? 0;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    updateSelectedClipTransform({ rotationDeg: clampNumber(val, -36000, 36000) });\n  },\n});\n\nconst transformPosX = computed({\n  get: () => {\n    if (!selectedClip.value) return 0;\n    return getSafeTransform(selectedClip.value).position?.x ?? 0;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    updateSelectedClipTransform({\n      position: { x: clampNumber(val, -1_000_000, 1_000_000), y: current.position?.y ?? 0 },\n    });\n  },\n});\n\nconst transformPosY = computed({\n  get: () => {\n    if (!selectedClip.value) return 0;\n    return getSafeTransform(selectedClip.value).position?.y ?? 0;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    updateSelectedClipTransform({\n      position: { x: current.position?.x ?? 0, y: clampNumber(val, -1_000_000, 1_000_000) },\n    });\n  },\n});\n\nconst transformAnchorPreset = computed({\n  get: () => {\n    if (!selectedClip.value) return 'center';\n    return getSafeTransform(selectedClip.value).anchor?.preset ?? 'center';\n  },\n  set: (val: string) => {\n    if (!selectedClip.value) return;\n    if (\n      val !== 'center' &&\n      val !== 'topLeft' &&\n      val !== 'topRight' &&\n      val !== 'bottomLeft' &&\n      val !== 'bottomRight' &&\n      val !== 'custom'\n    ) {\n      return;\n    }\n    if (val === 'custom') {\n      updateSelectedClipTransform({ anchor: { preset: 'custom', x: 0.5, y: 0.5 } });\n    } else {\n      updateSelectedClipTransform({ anchor: { preset: val as any } });\n    }\n  },\n});\n\nconst transformAnchorX = computed({\n  get: () => {\n    if (!selectedClip.value) return 0.5;\n    return getSafeTransform(selectedClip.value).anchor?.x ?? 0.5;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    if (current.anchor?.preset !== 'custom') return;\n    updateSelectedClipTransform({\n      anchor: {\n        preset: 'custom',\n        x: clampNumber(val, 0, 1),\n        y: current.anchor?.y ?? 0.5,\n      },\n    });\n  },\n});\n\nconst transformAnchorY = computed({\n  get: () => {\n    if (!selectedClip.value) return 0.5;\n    return getSafeTransform(selectedClip.value).anchor?.y ?? 0.5;\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = getSafeTransform(selectedClip.value);\n    if (current.anchor?.preset !== 'custom') return;\n    updateSelectedClipTransform({\n      anchor: {\n        preset: 'custom',\n        x: current.anchor?.x ?? 0.5,\n        y: clampNumber(val, 0, 1),\n      },\n    });\n  },\n});\n\nconst displayMode = computed<'transition' | 'clip' | 'track' | 'file' | 'empty'>(() => {\n  if (selectedTransitionClip.value && selectedTransitionValue.value) return 'transition';\n  if (selectedClip.value) return 'clip';\n  if (selectedTrack.value) return 'track';\n\n  const entity = selectionStore.selectedEntity;\n  if (entity?.source === 'fileManager' && (entity.kind === 'file' || entity.kind === 'directory'))\n    return 'file';\n\n  return 'empty';\n});\n\nconst selectedFsEntry = computed(() => {\n  const entity = selectionStore.selectedEntity;\n  if (entity?.source === 'fileManager' && (entity.kind === 'file' || entity.kind === 'directory')) {\n    return entity.entry;\n  }\n  return null;\n});\n\nconst timelinesUsingSelectedFile = computed(() => {\n  const entry = selectedFsEntry.value;\n  if (!entry || entry.kind !== 'file' || !entry.path) return [];\n  return timelineMediaUsageStore.mediaPathToTimelines[entry.path] ?? [];\n});\n\nasync function openTimelineFromUsage(path: string) {\n  await projectStore.openTimelineFile(path);\n  await timelineStore.loadTimeline();\n  void timelineStore.loadTimelineMetadata();\n}\n\nconst hasProxy = computed(() => {\n  if (displayMode.value !== 'file' || !selectedFsEntry.value || !selectedFsEntry.value.path)\n    return false;\n  return proxyStore.existingProxies.has(selectedFsEntry.value.path);\n});\n\nconst selectedClipTrack = computed<TimelineTrack | null>(() => {\n  const clip = selectedClip.value;\n  if (!clip) return null;\n  return (\n    (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined)?.find(\n      (t) => t.id === clip.trackId,\n    ) ?? null\n  );\n});\n\nconst canEditAudioFades = computed(() => {\n  const clip = selectedClip.value;\n  if (!clip) return false;\n  if (clip.clipType !== 'media' && clip.clipType !== 'timeline') return false;\n  return true;\n});\n\nconst canEditAudioGain = computed(() => {\n  const clip = selectedClip.value;\n  if (!clip) return false;\n  if (clip.clipType !== 'media' && clip.clipType !== 'timeline') return false;\n  const track = timelineStore.timelineDoc?.tracks.find((t) => t.id === clip.trackId);\n  if (track?.kind === 'video' && (clip as any).audioFromVideoDisabled) return false;\n\n  if (clip.source?.path) {\n    const meta = mediaStore.mediaMetadata[clip.source.path];\n    if (!meta?.audio) return false;\n  }\n\n  return true;\n});\n\nconst canEditAudioBalance = computed(() => {\n  return canEditAudioGain.value;\n});\n\nconst audioGain = computed({\n  get: () => {\n    const clip = selectedClip.value as any;\n    const v =\n      typeof clip?.audioGain === 'number' && Number.isFinite(clip.audioGain) ? clip.audioGain : 1;\n    return Math.max(0, Math.min(2, v));\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = selectedClip.value as any;\n    const v = Math.max(0, Math.min(2, Number(val)));\n    timelineStore.updateClipProperties(current.trackId, current.id, { audioGain: v });\n  },\n});\n\nconst audioBalance = computed({\n  get: () => {\n    const clip = selectedClip.value as any;\n    const v =\n      typeof clip?.audioBalance === 'number' && Number.isFinite(clip.audioBalance)\n        ? clip.audioBalance\n        : 0;\n    return Math.max(-1, Math.min(1, v));\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = selectedClip.value as any;\n    const v = Math.max(-1, Math.min(1, Number(val)));\n    timelineStore.updateClipProperties(current.trackId, current.id, { audioBalance: v });\n  },\n});\n\nconst clipDurationSec = computed(() => {\n  const clip = selectedClip.value;\n  if (!clip) return 0;\n  return Math.max(0, Number(clip.timelineRange?.durationUs ?? 0) / 1_000_000);\n});\n\nconst audioFadeInSec = computed({\n  get: () => {\n    const clip = selectedClip.value as any;\n    const v =\n      typeof clip?.audioFadeInUs === 'number' && Number.isFinite(clip.audioFadeInUs)\n        ? clip.audioFadeInUs\n        : 0;\n    return Math.max(0, v / 1_000_000);\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = selectedClip.value as any;\n    const v = Math.max(0, Math.min(val, clipDurationSec.value)) * 1_000_000;\n    timelineStore.updateClipProperties(current.trackId, current.id, { audioFadeInUs: v });\n  },\n});\n\nconst audioFadeOutSec = computed({\n  get: () => {\n    const clip = selectedClip.value as any;\n    const v =\n      typeof clip?.audioFadeOutUs === 'number' && Number.isFinite(clip.audioFadeOutUs)\n        ? clip.audioFadeOutUs\n        : 0;\n    return Math.max(0, v / 1_000_000);\n  },\n  set: (val: number) => {\n    if (!selectedClip.value) return;\n    const current = selectedClip.value as any;\n    const v = Math.max(0, Math.min(val, clipDurationSec.value)) * 1_000_000;\n    timelineStore.updateClipProperties(current.trackId, current.id, { audioFadeOutUs: v });\n  },\n});\n\nconst audioFadeInMaxSec = computed(() => {\n  const clip = selectedClip.value as any;\n  if (!clip) return 0;\n  const opp =\n    typeof clip.audioFadeOutUs === 'number' && Number.isFinite(clip.audioFadeOutUs)\n      ? clip.audioFadeOutUs\n      : 0;\n  return Math.max(0, (Number(clip.timelineRange?.durationUs ?? 0) - opp) / 1_000_000);\n});\n\nconst audioFadeOutMaxSec = computed(() => {\n  const clip = selectedClip.value as any;\n  if (!clip) return 0;\n  const opp =\n    typeof clip.audioFadeInUs === 'number' && Number.isFinite(clip.audioFadeInUs)\n      ? clip.audioFadeInUs\n      : 0;\n  return Math.max(0, (Number(clip.timelineRange?.durationUs ?? 0) - opp) / 1_000_000);\n});\n\nwatch(hasProxy, (val) => {\n  if (!val && previewMode.value === 'proxy') {\n    previewMode.value = 'original';\n  }\n});\n\nasync function loadPreviewMedia() {\n  if (currentUrl.value) {\n    URL.revokeObjectURL(currentUrl.value);\n    currentUrl.value = null;\n  }\n\n  const entry = selectedFsEntry.value;\n  if (!entry || entry.kind !== 'file') return;\n\n  try {\n    let fileToPlay: File;\n\n    if (previewMode.value === 'proxy' && hasProxy.value && entry.path) {\n      const proxyFile = await proxyStore.getProxyFile(entry.path);\n      if (proxyFile) {\n        fileToPlay = proxyFile;\n      } else {\n        fileToPlay = await (entry.handle as FileSystemFileHandle).getFile();\n      }\n    } else {\n      fileToPlay = await (entry.handle as FileSystemFileHandle).getFile();\n    }\n\n    if (mediaType.value === 'image' || mediaType.value === 'video' || mediaType.value === 'audio') {\n      currentUrl.value = URL.createObjectURL(fileToPlay);\n    }\n  } catch (e) {\n    console.error('Failed to load preview media:', e);\n  }\n}\n\nwatch(previewMode, () => {\n  void loadPreviewMedia();\n});\n\nwatch(\n  () => selectedFsEntry.value,\n  async (entry) => {\n    // Revoke old URL\n    if (currentUrl.value) {\n      URL.revokeObjectURL(currentUrl.value);\n      currentUrl.value = null;\n    }\n    mediaType.value = null;\n    textContent.value = '';\n    fileInfo.value = null;\n    previewMode.value = 'original';\n\n    if (!entry) return;\n\n    if (entry.kind === 'directory') {\n      fileInfo.value = {\n        name: entry.name,\n        kind: 'directory',\n        size: await computeDirectorySize(entry.handle as FileSystemDirectoryHandle),\n      };\n      return;\n    }\n\n    try {\n      const file = await (entry.handle as FileSystemFileHandle).getFile();\n\n      const ext = entry.name.split('.').pop()?.toLowerCase();\n      const textExtensions = ['txt', 'md', 'json', 'yaml', 'yml'];\n\n      if (file.type.startsWith('image/')) {\n        mediaType.value = 'image';\n      } else if (file.type.startsWith('video/')) {\n        mediaType.value = 'video';\n      } else if (file.type.startsWith('audio/')) {\n        mediaType.value = 'audio';\n      } else if (textExtensions.includes(ext || '') || file.type.startsWith('text/')) {\n        mediaType.value = 'text';\n        // limit text read to first 1MB\n        const textSlice = file.slice(0, 1024 * 1024);\n        textContent.value = await textSlice.text();\n        if (file.size > 1024 * 1024) {\n          textContent.value += '\\n... (truncated)';\n        }\n      } else {\n        mediaType.value = 'unknown';\n      }\n\n      fileInfo.value = {\n        name: file.name,\n        kind: 'file',\n        size: file.size,\n        lastModified: file.lastModified,\n        metadata:\n          entry.path && (mediaType.value === 'video' || mediaType.value === 'audio')\n            ? await mediaStore.getOrFetchMetadata(\n                entry.handle as FileSystemFileHandle,\n                entry.path,\n                {\n                  forceRefresh: true,\n                },\n              )\n            : undefined,\n      };\n\n      if (\n        mediaType.value === 'image' ||\n        mediaType.value === 'video' ||\n        mediaType.value === 'audio'\n      ) {\n        await loadPreviewMedia();\n      }\n    } catch (e) {\n      console.error('Failed to preview file:', e);\n    }\n  },\n);\n\nonUnmounted(() => {\n  if (currentUrl.value) {\n    URL.revokeObjectURL(currentUrl.value);\n  }\n});\n\nfunction formatMegabytes(bytes: number, decimals = 2): string {\n  if (!Number.isFinite(bytes) || bytes <= 0) return '0 MB';\n  const mb = bytes / (1024 * 1024);\n  return `${mb.toFixed(decimals)} MB`;\n}\n\nfunction formatTime(us: number): string {\n  if (!us) return '0.00s';\n  return (us / 1_000_000).toFixed(2) + 's';\n}\n\nconst metadataYaml = computed(() => {\n  if (!fileInfo.value?.metadata) return null;\n  try {\n    return yaml.dump(fileInfo.value.metadata, { indent: 2 });\n  } catch {\n    return String(fileInfo.value.metadata);\n  }\n});\n\nfunction handleDeleteClip() {\n  if (selectedClip.value) {\n    timelineStore.deleteSelectedItems(selectedClip.value.trackId);\n  }\n}\n\nfunction handleRenameClip(newName: string) {\n  if (selectedClip.value && newName.trim()) {\n    timelineStore.renameItem(selectedClip.value.trackId, selectedClip.value.id, newName.trim());\n  }\n}\n\nconst isUnknown = computed(() => mediaType.value === 'unknown');\n\nfunction handleTransitionUpdate(payload: {\n  trackId: string;\n  itemId: string;\n  edge: 'in' | 'out';\n  transition: import('~/timeline/types').ClipTransition | null;\n}) {\n  if (payload.edge === 'in') {\n    timelineStore.updateClipTransition(payload.trackId, payload.itemId, {\n      transitionIn: payload.transition,\n    });\n  } else {\n    timelineStore.updateClipTransition(payload.trackId, payload.itemId, {\n      transitionOut: payload.transition,\n    });\n  }\n}\n\nfunction toggleTransition(edge: 'in' | 'out') {\n  if (!selectedClip.value) return;\n  const clip = selectedClip.value;\n  const current = edge === 'in' ? (clip as any).transitionIn : (clip as any).transitionOut;\n\n  if (current) {\n    handleTransitionUpdate({ trackId: clip.trackId, itemId: clip.id, edge, transition: null });\n  } else {\n    // Basic defaults\n    const transition = {\n      type: 'dissolve',\n      durationUs: 1_000_000,\n      mode: 'blend' as const,\n      curve: 'linear' as const,\n    };\n    handleTransitionUpdate({ trackId: clip.trackId, itemId: clip.id, edge, transition });\n    // Optionally select it right away\n    timelineStore.selectTransition({ trackId: clip.trackId, itemId: clip.id, edge });\n  }\n}\n\nfunction updateTransitionDuration(edge: 'in' | 'out', durationSec: number) {\n  if (!selectedClip.value) return;\n  const clip = selectedClip.value;\n  const current = (\n    edge === 'in' ? (clip as any).transitionIn : (clip as any).transitionOut\n  ) as import('~/timeline/types').ClipTransition;\n  if (!current) return;\n\n  handleTransitionUpdate({\n    trackId: clip.trackId,\n    itemId: clip.id,\n    edge,\n    transition: {\n      ...current,\n      durationUs: Math.round(durationSec * 1_000_000),\n    },\n  });\n}\n\nfunction onPanelFocusIn(e: FocusEvent) {\n  if (!isEditableTarget(e.target)) return;\n  focusStore.setTempFocus('right');\n}\n\nfunction onPanelFocusOut() {\n  // We no longer automatically clear temp focus on blur\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col h-full bg-ui-bg-elevated border-r border-ui-border min-w-0 relative\"\n    :class=\"{\n      'outline-2 outline-primary-500/60 -outline-offset-2 z-10': focusStore.isPanelFocused('right'),\n    }\"\n    @pointerdown.capture=\"focusStore.setTempFocus('right')\"\n    @focusin.capture=\"onPanelFocusIn\"\n    @focusout.capture=\"onPanelFocusOut\"\n  >\n    <!-- Header -->\n    <div\n      v-if=\"displayMode !== 'empty'\"\n      class=\"flex items-center justify-between px-2 py-1.5 border-b border-ui-border shrink-0\"\n    >\n      <div class=\"flex items-center overflow-hidden min-w-0\">\n        <span\n          v-if=\"displayMode === 'clip'\"\n          class=\"ml-2 text-xs text-ui-text-muted font-mono truncate\"\n        >\n          {{ selectedClip?.name }}\n        </span>\n        <span\n          v-else-if=\"displayMode === 'transition'\"\n          class=\"ml-2 text-xs text-ui-text-muted font-mono truncate\"\n        >\n          {{ selectedTransitionClip?.name }}\n        </span>\n        <span\n          v-else-if=\"displayMode === 'file' && selectedFsEntry\"\n          class=\"ml-2 text-xs text-ui-text-muted font-mono truncate\"\n        >\n          {{ selectedFsEntry.name }}\n        </span>\n        <span\n          v-else-if=\"displayMode === 'track' && selectedTrack\"\n          class=\"ml-2 text-xs text-ui-text-muted font-mono truncate\"\n        >\n          {{ selectedTrack.name }}\n        </span>\n      </div>\n      <div class=\"flex gap-1 shrink-0 ml-2\">\n        <UButton\n          size=\"xs\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-x-mark\"\n          @click=\"clearAllSelection\"\n        />\n        <div v-if=\"displayMode === 'clip'\" class=\"flex gap-1\">\n          <UButton\n            size=\"xs\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-pencil\"\n            @click=\"isRenameModalOpen = true\"\n          />\n          <UButton\n            size=\"xs\"\n            variant=\"ghost\"\n            color=\"red\"\n            icon=\"i-heroicons-trash\"\n            @click=\"handleDeleteClip\"\n          />\n        </div>\n        <div v-else-if=\"displayMode === 'file' && hasProxy\" class=\"flex gap-1\">\n          <UFieldGroup size=\"xs\">\n            <UButton\n              :color=\"previewMode === 'original' ? 'primary' : 'neutral'\"\n              :variant=\"previewMode === 'original' ? 'soft' : 'ghost'\"\n              :label=\"t('videoEditor.fileManager.preview.original', 'Original')\"\n              @click=\"previewMode = 'original'\"\n            />\n            <UButton\n              :color=\"previewMode === 'proxy' ? 'primary' : 'neutral'\"\n              :variant=\"previewMode === 'proxy' ? 'soft' : 'ghost'\"\n              :label=\"t('videoEditor.fileManager.preview.proxy', 'Proxy')\"\n              @click=\"previewMode = 'proxy'\"\n            />\n          </UFieldGroup>\n        </div>\n      </div>\n    </div>\n\n    <!-- Content Area -->\n    <div class=\"flex-1 min-h-0 bg-ui-bg relative\">\n      <div class=\"absolute inset-0 overflow-auto\">\n        <div class=\"flex flex-col p-2 items-start w-full\">\n          <div\n            v-if=\"displayMode === 'empty'\"\n            key=\"empty\"\n            class=\"w-full flex items-center justify-center text-ui-text-muted min-h-50\"\n          >\n            <p class=\"text-xs\">\n              {{ t('granVideoEditor.preview.noSelection', 'No item selected') }}\n            </p>\n          </div>\n\n          <!-- Transition Properties -->\n          <div\n            v-else-if=\"displayMode === 'transition' && selectedTransition && selectedTransitionClip\"\n            key=\"transition\"\n            class=\"w-full flex flex-col gap-2 text-ui-text\"\n          >\n            <div\n              class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n            >\n              {{ selectedTransition.edge === 'in' ? 'Transition In' : 'Transition Out' }}\n            </div>\n\n            <ClipTransitionPanel\n              :edge=\"selectedTransition.edge\"\n              :track-id=\"selectedTransition.trackId\"\n              :item-id=\"selectedTransition.itemId\"\n              :transition=\"selectedTransitionValue\"\n              @update=\"handleTransitionUpdate\"\n            />\n          </div>\n\n          <!-- Clip Properties -->\n          <div\n            v-else-if=\"displayMode === 'clip' && selectedClip\"\n            key=\"clip\"\n            class=\"w-full flex flex-col gap-2 text-ui-text\"\n          >\n            <div\n              class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n            >\n              {{ selectedClip.name }}\n            </div>\n\n            <div class=\"space-y-2 bg-ui-bg-elevated p-2 rounded border border-ui-border text-xs\">\n              <div\n                v-if=\"selectedClip.clipType === 'media'\"\n                class=\"flex flex-col gap-0.5 border-b border-ui-border pb-1.5\"\n              >\n                <span class=\"text-ui-text-muted text-xs\">{{\n                  t('common.source', 'Source File')\n                }}</span>\n                <span class=\"font-medium break-all text-xs\">{{ selectedClip.source.path }}</span>\n              </div>\n              <div\n                v-else-if=\"selectedClip.clipType === 'background'\"\n                class=\"flex flex-col gap-0.5 border-b border-ui-border pb-1.5\"\n              >\n                <span class=\"text-ui-text-muted text-xs\">{{ t('common.color', 'Color') }}</span>\n                <div class=\"flex items-center justify-between gap-3\">\n                  <span class=\"font-mono text-xs text-ui-text\">{{\n                    selectedClip.backgroundColor\n                  }}</span>\n                  <UColorPicker\n                    :model-value=\"selectedClip.backgroundColor\"\n                    format=\"hex\"\n                    size=\"sm\"\n                    @update:model-value=\"handleUpdateBackgroundColor\"\n                  />\n                </div>\n              </div>\n              <div\n                v-else-if=\"selectedClip.clipType === 'text'\"\n                class=\"flex flex-col gap-1.5 border-b border-ui-border pb-1.5\"\n              >\n                <span class=\"text-ui-text-muted text-xs\">{{\n                  t('granVideoEditor.textClip.text', 'Text')\n                }}</span>\n                <UTextarea\n                  :model-value=\"(selectedClip as any).text\"\n                  size=\"sm\"\n                  :rows=\"4\"\n                  @update:model-value=\"handleUpdateText\"\n                />\n\n                <div class=\"grid grid-cols-2 gap-2\">\n                  <div class=\"flex flex-col gap-0.5\">\n                    <span class=\"text-xs text-ui-text-muted\">{{\n                      t('granVideoEditor.textClip.fontSize', 'Font size')\n                    }}</span>\n                    <UInput\n                      :model-value=\"Number((selectedClip as any).style?.fontSize ?? 64)\"\n                      size=\"sm\"\n                      type=\"number\"\n                      step=\"1\"\n                      @update:model-value=\"\n                        (v: any) => handleUpdateTextStyle({ fontSize: Number(v) })\n                      \"\n                    />\n                  </div>\n                  <div class=\"flex flex-col gap-0.5\">\n                    <span class=\"text-xs text-ui-text-muted\">{{ t('common.color', 'Color') }}</span>\n                    <UColorPicker\n                      :model-value=\"String((selectedClip as any).style?.color ?? '#ffffff')\"\n                      format=\"hex\"\n                      size=\"sm\"\n                      @update:model-value=\"(v: any) => handleUpdateTextStyle({ color: String(v) })\"\n                    />\n                  </div>\n                </div>\n\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.textClip.align', 'Align')\n                  }}</span>\n                  <USelect\n                    :model-value=\"String((selectedClip as any).style?.align ?? 'center')\"\n                    :options=\"[\n                      { value: 'left', label: 'Left' },\n                      { value: 'center', label: 'Center' },\n                      { value: 'right', label: 'Right' },\n                    ]\"\n                    size=\"sm\"\n                    @update:model-value=\"(v: any) => handleUpdateTextStyle({ align: v })\"\n                  />\n                </div>\n\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.textClip.verticalAlign', 'Vertical align')\n                  }}</span>\n                  <USelect\n                    :model-value=\"String((selectedClip as any).style?.verticalAlign ?? 'middle')\"\n                    :options=\"[\n                      { value: 'top', label: 'Top' },\n                      { value: 'middle', label: 'Middle' },\n                      { value: 'bottom', label: 'Bottom' },\n                    ]\"\n                    size=\"sm\"\n                    @update:model-value=\"(v: any) => handleUpdateTextStyle({ verticalAlign: v })\"\n                  />\n                </div>\n\n                <div class=\"grid grid-cols-2 gap-2\">\n                  <div class=\"flex flex-col gap-0.5\">\n                    <span class=\"text-xs text-ui-text-muted\">{{\n                      t('granVideoEditor.textClip.lineHeight', 'Line height')\n                    }}</span>\n                    <UInput\n                      :model-value=\"Number((selectedClip as any).style?.lineHeight ?? 1.2)\"\n                      size=\"sm\"\n                      type=\"number\"\n                      step=\"0.1\"\n                      @update:model-value=\"\n                        (v: any) => handleUpdateTextStyle({ lineHeight: Number(v) })\n                      \"\n                    />\n                  </div>\n                  <div class=\"flex flex-col gap-0.5\">\n                    <span class=\"text-xs text-ui-text-muted\">{{\n                      t('granVideoEditor.textClip.letterSpacing', 'Letter spacing')\n                    }}</span>\n                    <UInput\n                      :model-value=\"Number((selectedClip as any).style?.letterSpacing ?? 0)\"\n                      size=\"sm\"\n                      type=\"number\"\n                      step=\"1\"\n                      @update:model-value=\"\n                        (v: any) => handleUpdateTextStyle({ letterSpacing: Number(v) })\n                      \"\n                    />\n                  </div>\n                </div>\n\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.textClip.backgroundColor', 'Background')\n                  }}</span>\n                  <UColorPicker\n                    :model-value=\"String((selectedClip as any).style?.backgroundColor ?? '')\"\n                    format=\"hex\"\n                    size=\"sm\"\n                    @update:model-value=\"\n                      (v: any) => handleUpdateTextStyle({ backgroundColor: String(v) })\n                    \"\n                  />\n                </div>\n\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.textClip.padding', 'Padding')\n                  }}</span>\n                  <UInput\n                    :model-value=\"Number((selectedClip as any).style?.padding ?? 60)\"\n                    size=\"sm\"\n                    type=\"number\"\n                    step=\"1\"\n                    @update:model-value=\"(v: any) => handleUpdateTextStyle({ padding: Number(v) })\"\n                  />\n                </div>\n              </div>\n              <div class=\"flex flex-col gap-0.5 border-b border-ui-border pb-1.5\">\n                <span class=\"text-xs text-ui-text-muted\">{{\n                  t('common.start', 'Start Time')\n                }}</span>\n                <span class=\"font-mono text-xs\">{{\n                  formatTime(selectedClip.timelineRange.startUs)\n                }}</span>\n              </div>\n              <div class=\"flex flex-col gap-0.5 pb-1.5\">\n                <span class=\"text-xs text-ui-text-muted\">{{\n                  t('common.duration', 'Duration')\n                }}</span>\n                <span class=\"font-mono text-xs\">{{\n                  formatTime(selectedClip.timelineRange.durationUs)\n                }}</span>\n              </div>\n            </div>\n\n            <!-- Quick Transitions -->\n            <div\n              v-if=\"selectedClip.trackId.startsWith('v')\"\n              class=\"space-y-2 bg-ui-bg-elevated p-2 rounded border border-ui-border\"\n            >\n              <div\n                class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n              >\n                {{ t('granVideoEditor.timeline.transitions', 'Transitions') }}\n              </div>\n\n              <!-- In Transition -->\n              <div class=\"flex flex-col gap-1 pb-1.5 border-b border-ui-border/40\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-[11px] font-medium text-ui-text-muted\">Transition IN</span>\n                  <UButton\n                    size=\"xs\"\n                    :color=\"(selectedClip as any).transitionIn ? 'red' : 'primary'\"\n                    variant=\"ghost\"\n                    :icon=\"\n                      (selectedClip as any).transitionIn\n                        ? 'i-heroicons-trash'\n                        : 'i-heroicons-plus-circle'\n                    \"\n                    @click=\"toggleTransition('in')\"\n                  />\n                </div>\n                <div\n                  v-if=\"(selectedClip as any).transitionIn\"\n                  class=\"space-y-1.5 pl-2 border-l-2 border-primary-500/40\"\n                >\n                  <div class=\"flex items-center justify-between\">\n                    <UButton\n                      variant=\"link\"\n                      color=\"primary\"\n                      size=\"xs\"\n                      class=\"p-0 h-auto font-mono text-[10px]\"\n                      @click=\"\n                        timelineStore.selectTransition({\n                          trackId: selectedClip.trackId,\n                          itemId: selectedClip.id,\n                          edge: 'in',\n                        })\n                      \"\n                    >\n                      {{ (selectedClip as any).transitionIn.type }}\n                    </UButton>\n                    <span class=\"text-[10px] font-mono text-ui-text-muted\">\n                      {{ formatTime((selectedClip as any).transitionIn.durationUs) }}\n                    </span>\n                  </div>\n                  <DurationSliderInput\n                    :model-value=\"(selectedClip as any).transitionIn.durationUs / 1_000_000\"\n                    :min=\"0.1\"\n                    :max=\"\n                      Math.max(\n                        0.1,\n                        (selectedClip.timelineRange.durationUs -\n                          ((selectedClip as any).transitionOut?.durationUs ?? 0)) /\n                          1_000_000,\n                      )\n                    \"\n                    :step=\"0.01\"\n                    unit=\"s\"\n                    :decimals=\"2\"\n                    @update:model-value=\"(v: number) => updateTransitionDuration('in', v)\"\n                  />\n                </div>\n              </div>\n\n              <!-- Out Transition -->\n              <div class=\"flex flex-col gap-1\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-[11px] font-medium text-ui-text-muted\">Transition OUT</span>\n                  <UButton\n                    size=\"xs\"\n                    :color=\"(selectedClip as any).transitionOut ? 'red' : 'primary'\"\n                    variant=\"ghost\"\n                    :icon=\"\n                      (selectedClip as any).transitionOut\n                        ? 'i-heroicons-trash'\n                        : 'i-heroicons-plus-circle'\n                    \"\n                    @click=\"toggleTransition('out')\"\n                  />\n                </div>\n                <div\n                  v-if=\"(selectedClip as any).transitionOut\"\n                  class=\"space-y-1.5 pl-2 border-l-2 border-primary-500/40\"\n                >\n                  <div class=\"flex items-center justify-between\">\n                    <UButton\n                      variant=\"link\"\n                      color=\"primary\"\n                      size=\"xs\"\n                      class=\"p-0 h-auto font-mono text-[10px]\"\n                      @click=\"\n                        timelineStore.selectTransition({\n                          trackId: selectedClip.trackId,\n                          itemId: selectedClip.id,\n                          edge: 'out',\n                        })\n                      \"\n                    >\n                      {{ (selectedClip as any).transitionOut.type }}\n                    </UButton>\n                    <span class=\"text-[10px] font-mono text-ui-text-muted\">\n                      {{ formatTime((selectedClip as any).transitionOut.durationUs) }}\n                    </span>\n                  </div>\n                  <DurationSliderInput\n                    :model-value=\"(selectedClip as any).transitionOut.durationUs / 1_000_000\"\n                    :min=\"0.1\"\n                    :max=\"\n                      Math.max(\n                        0.1,\n                        (selectedClip.timelineRange.durationUs -\n                          ((selectedClip as any).transitionIn?.durationUs ?? 0)) /\n                          1_000_000,\n                      )\n                    \"\n                    :step=\"0.01\"\n                    unit=\"s\"\n                    :decimals=\"2\"\n                    @update:model-value=\"(v: number) => updateTransitionDuration('out', v)\"\n                  />\n                </div>\n              </div>\n            </div>\n\n            <!-- Transparency (Opacity) -->\n            <div\n              v-if=\"selectedClip.clipType !== 'adjustment'\"\n              class=\"space-y-1.5 bg-ui-bg-elevated p-2 rounded border border-ui-border\"\n            >\n              <div class=\"flex items-center justify-between\">\n                <span class=\"text-xs font-semibold text-ui-text uppercase tracking-wide\"\n                  >ÐÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ</span\n                >\n                <span class=\"text-xs font-mono text-ui-text-muted\"\n                  >{{ Math.round((selectedClip.opacity ?? 1) * 100) }}%</span\n                >\n              </div>\n              <WheelSlider\n                :model-value=\"selectedClip.opacity ?? 1\"\n                :min=\"0\"\n                :max=\"1\"\n                :step=\"0.01\"\n                @update:model-value=\"handleUpdateOpacity\"\n              />\n            </div>\n\n            <EffectsEditor\n              :effects=\"selectedClip.effects\"\n              :title=\"t('granVideoEditor.effects.clipTitle', 'Clip effects')\"\n              :add-label=\"t('granVideoEditor.effects.add', 'Add')\"\n              :empty-label=\"t('granVideoEditor.effects.empty', 'No effects')\"\n              @update:effects=\"handleUpdateClipEffects\"\n            />\n\n            <div\n              v-if=\"\n                canEditAudioFades &&\n                (selectedClipTrack?.kind === 'audio' || selectedClipTrack?.kind === 'video')\n              \"\n              class=\"space-y-2 bg-ui-bg-elevated p-2 rounded border border-ui-border\"\n            >\n              <div\n                class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n              >\n                {{ t('granVideoEditor.clip.audioFade.title', 'Audio fades') }}\n              </div>\n\n              <div class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.clip.audio.volume', 'Volume')\n                  }}</span>\n                  <span class=\"text-xs font-mono text-ui-text-muted\"\n                    >{{ audioGain.toFixed(3) }}x</span\n                  >\n                </div>\n                <WheelSlider\n                  :model-value=\"audioGain\"\n                  :min=\"0\"\n                  :max=\"2\"\n                  :step=\"0.001\"\n                  @update:model-value=\"handleUpdateAudioGain\"\n                />\n              </div>\n\n              <div v-if=\"canEditAudioBalance\" class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.clip.audio.balance', 'Balance')\n                  }}</span>\n                  <span class=\"text-xs font-mono text-ui-text-muted\">{{\n                    audioBalance.toFixed(2)\n                  }}</span>\n                </div>\n                <WheelSlider\n                  :model-value=\"audioBalance\"\n                  :min=\"-1\"\n                  :max=\"1\"\n                  :step=\"0.01\"\n                  @update:model-value=\"handleUpdateAudioBalance\"\n                />\n              </div>\n\n              <div class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.clip.audioFade.fadeIn', 'Fade in')\n                  }}</span>\n                </div>\n                <DurationSliderInput\n                  v-model=\"audioFadeInSec\"\n                  :min=\"0\"\n                  :max=\"audioFadeInMaxSec\"\n                  :step=\"0.01\"\n                  unit=\"s\"\n                  :decimals=\"2\"\n                />\n              </div>\n\n              <div class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.clip.audioFade.fadeOut', 'Fade out')\n                  }}</span>\n                </div>\n                <DurationSliderInput\n                  v-model=\"audioFadeOutSec\"\n                  :min=\"0\"\n                  :max=\"audioFadeOutMaxSec\"\n                  :step=\"0.01\"\n                  unit=\"s\"\n                  :decimals=\"2\"\n                />\n              </div>\n            </div>\n\n            <div\n              v-if=\"canEditTransform\"\n              class=\"space-y-2 bg-ui-bg-elevated p-2 rounded border border-ui-border\"\n            >\n              <div\n                class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n              >\n                Transform\n              </div>\n\n              <div class=\"grid grid-cols-2 gap-2\">\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Scale X</span>\n                  <UInput v-model.number=\"transformScaleX\" size=\"sm\" type=\"number\" step=\"0.01\" />\n                </div>\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Scale Y</span>\n                  <UInput v-model.number=\"transformScaleY\" size=\"sm\" type=\"number\" step=\"0.01\" />\n                </div>\n              </div>\n\n              <div class=\"flex items-center justify-between\">\n                <span class=\"text-sm text-ui-text\">Linked scale</span>\n                <UCheckbox v-model=\"transformScaleLinked\" />\n              </div>\n\n              <div class=\"flex flex-col gap-0.5\">\n                <span class=\"text-xs text-ui-text-muted\">Rotation (deg)</span>\n                <UInput v-model.number=\"transformRotationDeg\" size=\"sm\" type=\"number\" step=\"0.1\" />\n              </div>\n\n              <div class=\"grid grid-cols-2 gap-2\">\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Position X</span>\n                  <UInput v-model.number=\"transformPosX\" size=\"sm\" type=\"number\" step=\"1\" />\n                </div>\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Position Y</span>\n                  <UInput v-model.number=\"transformPosY\" size=\"sm\" type=\"number\" step=\"1\" />\n                </div>\n              </div>\n\n              <div class=\"flex flex-col gap-0.5\">\n                <span class=\"text-xs text-ui-text-muted\">Anchor</span>\n                <USelect v-model=\"transformAnchorPreset\" :options=\"anchorPresetOptions\" size=\"sm\" />\n              </div>\n\n              <div v-if=\"transformAnchorPreset === 'custom'\" class=\"grid grid-cols-2 gap-2\">\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Anchor X (0..1)</span>\n                  <UInput v-model.number=\"transformAnchorX\" size=\"sm\" type=\"number\" step=\"0.01\" />\n                </div>\n                <div class=\"flex flex-col gap-0.5\">\n                  <span class=\"text-xs text-ui-text-muted\">Anchor Y (0..1)</span>\n                  <UInput v-model.number=\"transformAnchorY\" size=\"sm\" type=\"number\" step=\"0.01\" />\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div\n            v-else-if=\"displayMode === 'track' && selectedTrack\"\n            key=\"track\"\n            class=\"w-full flex flex-col gap-2\"\n          >\n            <div\n              class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n            >\n              {{ selectedTrack.name }}\n            </div>\n\n            <div\n              v-if=\"selectedTrack.kind === 'audio' || selectedTrack.kind === 'video'\"\n              class=\"space-y-2 bg-ui-bg-elevated p-2 rounded border border-ui-border\"\n            >\n              <div\n                class=\"text-xs font-semibold text-ui-text uppercase tracking-wide border-b border-ui-border pb-1\"\n              >\n                {{ t('granVideoEditor.track.audio.title', 'Track audio') }}\n              </div>\n\n              <div class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.track.audio.volume', 'Volume')\n                  }}</span>\n                  <span class=\"text-xs font-mono text-ui-text-muted\"\n                    >{{ trackAudioGain.toFixed(3) }}x</span\n                  >\n                </div>\n                <WheelSlider\n                  :model-value=\"trackAudioGain\"\n                  :min=\"0\"\n                  :max=\"2\"\n                  :step=\"0.001\"\n                  @update:model-value=\"(v: any) => (trackAudioGain = Number(v))\"\n                />\n              </div>\n\n              <div class=\"space-y-1.5\">\n                <div class=\"flex items-center justify-between\">\n                  <span class=\"text-xs text-ui-text-muted\">{{\n                    t('granVideoEditor.track.audio.balance', 'Balance')\n                  }}</span>\n                  <span class=\"text-xs font-mono text-ui-text-muted\">{{\n                    trackAudioBalance.toFixed(2)\n                  }}</span>\n                </div>\n                <WheelSlider\n                  :model-value=\"trackAudioBalance\"\n                  :min=\"-1\"\n                  :max=\"1\"\n                  :step=\"0.01\"\n                  @update:model-value=\"(v: any) => (trackAudioBalance = Number(v))\"\n                />\n              </div>\n            </div>\n\n            <EffectsEditor\n              :effects=\"selectedTrack.effects\"\n              :title=\"t('granVideoEditor.effects.trackTitle', 'Track effects')\"\n              :add-label=\"t('granVideoEditor.effects.add', 'Add')\"\n              :empty-label=\"t('granVideoEditor.effects.empty', 'No effects')\"\n              @update:effects=\"handleUpdateTrackEffects\"\n            />\n          </div>\n\n          <!-- File Preview & Properties -->\n          <div v-else-if=\"displayMode === 'file'\" key=\"file\" class=\"w-full flex flex-col gap-4\">\n            <input\n              ref=\"uploadInputRef\"\n              type=\"file\"\n              multiple\n              class=\"hidden\"\n              @change=\"onDirectoryFileSelect\"\n            />\n\n            <!-- Preview Box (only for files) -->\n            <div\n              v-if=\"selectedFsEntry?.kind === 'file'\"\n              class=\"w-full bg-ui-bg rounded border border-ui-border flex flex-col items-center justify-center min-h-50 overflow-hidden shrink-0\"\n            >\n              <div\n                v-if=\"isUnknown\"\n                class=\"flex flex-col items-center gap-3 text-ui-text-muted p-8 w-full h-full justify-center\"\n              >\n                <UIcon name=\"i-heroicons-document\" class=\"w-16 h-16\" />\n                <p class=\"text-sm text-center\">\n                  {{\n                    t(\n                      'granVideoEditor.preview.unsupported',\n                      'Unsupported file format for visual preview',\n                    )\n                  }}\n                </p>\n              </div>\n\n              <div v-else-if=\"currentUrl\" class=\"w-full h-full flex flex-col\">\n                <img\n                  v-if=\"mediaType === 'image'\"\n                  :src=\"currentUrl\"\n                  class=\"max-w-full max-h-64 object-contain mx-auto my-auto\"\n                />\n                <MediaPlayer\n                  v-else-if=\"mediaType === 'video' || mediaType === 'audio'\"\n                  :src=\"currentUrl\"\n                  :type=\"mediaType\"\n                  class=\"w-full h-64\"\n                />\n              </div>\n\n              <pre\n                v-else-if=\"mediaType === 'text'\"\n                class=\"w-full max-h-64 overflow-auto p-4 text-xs font-mono text-ui-text whitespace-pre-wrap\"\n                >{{ textContent }}</pre\n              >\n            </div>\n\n            <!-- File Info -->\n            <div\n              v-if=\"fileInfo\"\n              class=\"space-y-1.5 bg-ui-bg-elevated p-2 rounded border border-ui-border text-xs w-full\"\n            >\n              <div class=\"flex flex-col gap-0.5 border-b border-ui-border pb-1.5\">\n                <span class=\"text-xs text-ui-text-muted\">{{ t('common.name', 'Name') }}</span>\n                <span class=\"font-medium text-ui-text break-all\">{{ fileInfo.name }}</span>\n              </div>\n\n              <div v-if=\"selectedFsEntry?.kind === 'directory'\" class=\"flex\">\n                <UButton\n                  size=\"xs\"\n                  color=\"neutral\"\n                  variant=\"soft\"\n                  icon=\"i-heroicons-arrow-up-tray\"\n                  class=\"w-full\"\n                  @click=\"triggerDirectoryUpload\"\n                >\n                  {{ t('videoEditor.fileManager.actions.uploadFiles', 'Upload files') }}\n                </UButton>\n              </div>\n              <div\n                v-if=\"fileInfo.size !== undefined\"\n                class=\"flex flex-col gap-0.5 border-b border-ui-border pb-1.5\"\n              >\n                <span class=\"text-xs text-ui-text-muted\">{{ t('common.size', 'Size') }}</span>\n                <span class=\"font-medium text-ui-text\">{{ formatMegabytes(fileInfo.size) }}</span>\n              </div>\n              <div\n                v-if=\"fileInfo.lastModified !== undefined\"\n                class=\"flex flex-col gap-0.5 pb-1.5\"\n                :class=\"{ 'border-b border-ui-border': metadataYaml }\"\n              >\n                <span class=\"text-xs text-ui-text-muted\">{{\n                  t('common.modified', 'Modified')\n                }}</span>\n                <span class=\"font-medium text-ui-text\">{{\n                  new Date(fileInfo.lastModified).toLocaleString()\n                }}</span>\n              </div>\n              <div v-if=\"metadataYaml\" class=\"flex flex-col gap-0.5 pt-1.5\">\n                <span class=\"text-xs text-ui-text-muted\">{{\n                  t('videoEditor.fileManager.info.metadata', 'Metadata')\n                }}</span>\n                <pre\n                  class=\"bg-ui-bg p-2 rounded text-[10px] font-mono overflow-auto max-h-40 whitespace-pre text-ui-text-muted\"\n                  >{{ metadataYaml }}</pre\n                >\n              </div>\n            </div>\n\n            <div\n              v-if=\"selectedFsEntry?.kind === 'file' && timelinesUsingSelectedFile.length > 0\"\n              class=\"space-y-1.5 bg-ui-bg-elevated p-2 rounded border border-ui-border text-xs w-full\"\n            >\n              <div class=\"flex flex-col gap-0.5\">\n                <span class=\"text-xs text-ui-text-muted\">{{ t('common.usedIn', 'Used in') }}</span>\n              </div>\n\n              <div class=\"flex flex-col gap-1\">\n                <button\n                  v-for=\"tl in timelinesUsingSelectedFile\"\n                  :key=\"tl.timelinePath\"\n                  type=\"button\"\n                  class=\"text-left px-2 py-1 rounded hover:bg-ui-bg-hover transition-colors\"\n                  @click=\"openTimelineFromUsage(tl.timelinePath)\"\n                >\n                  <div class=\"text-xs font-medium text-ui-text break-all\">\n                    {{ tl.timelineName }}\n                  </div>\n                  <div class=\"text-[10px] text-ui-text-muted break-all\">\n                    {{ tl.timelinePath }}\n                  </div>\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <RenameModal\n      v-model:open=\"isRenameModalOpen\"\n      :initial-name=\"selectedClip?.name\"\n      @rename=\"handleRenameClip\"\n    />\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ProjectSettingsModal.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timelineStore' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":7,"messageId":"unusedVar","endLine":29,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport AppModal from '~/components/ui/AppModal.vue';\nimport UiConfirmModal from '~/components/ui/UiConfirmModal.vue';\nimport { ref, computed } from 'vue';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport MediaEncodingSettings, {\n  type FormatOption,\n} from '~/components/media/MediaEncodingSettings.vue';\nimport MediaResolutionSettings from '~/components/media/MediaResolutionSettings.vue';\nimport {\n  BASE_VIDEO_CODEC_OPTIONS,\n  checkVideoCodecSupport,\n  resolveVideoCodecOptions,\n} from '~/utils/webcodecs';\n\nconst props = defineProps<{\n  open: boolean;\n}>();\n\nconst emit = defineEmits<{\n  'update:open': [value: boolean];\n}>();\n\nconst { t } = useI18n();\nconst projectStore = useProjectStore();\nconst workspaceStore = useWorkspaceStore();\nconst timelineStore = useTimelineStore();\n\nconst isOpen = computed({\n  get: () => props.open,\n  set: (value) => emit('update:open', value),\n});\n\nconst isClearProjectVardataConfirmOpen = ref(false);\nconst isDeleteProjectConfirmOpen = ref(false);\n\nasync function confirmClearProjectVardata() {\n  isClearProjectVardataConfirmOpen.value = false;\n  if (!projectStore.currentProjectId) return;\n  await workspaceStore.clearProjectVardata(projectStore.currentProjectId);\n}\n\nasync function confirmDeleteProject() {\n  isDeleteProjectConfirmOpen.value = false;\n  await projectStore.deleteCurrentProject();\n  // Closing the current project will automatically return the user to the projects list\n  // because projectStore.currentProjectName becomes null and the view switches in index.vue\n}\n\nconst formatOptions: readonly FormatOption[] = [\n  { value: 'mp4', label: 'MP4' },\n  { value: 'webm', label: 'WebM (VP9/OPUS)' },\n  { value: 'mkv', label: 'MKV (AV1|OPUS)' },\n];\n\nconst videoCodecSupport = ref<Record<string, boolean>>({});\nconst isLoadingCodecSupport = ref(false);\n\nconst videoCodecOptions = computed(() =>\n  resolveVideoCodecOptions(BASE_VIDEO_CODEC_OPTIONS, videoCodecSupport.value),\n);\n\nasync function loadCodecSupport() {\n  if (isLoadingCodecSupport.value) return;\n  isLoadingCodecSupport.value = true;\n  try {\n    videoCodecSupport.value = await checkVideoCodecSupport(BASE_VIDEO_CODEC_OPTIONS);\n  } finally {\n    isLoadingCodecSupport.value = false;\n  }\n}\n\n// Load on mount\nloadCodecSupport();\n\n// Project settings form data\nasync function applySettings() {\n  // Settings are already bound via v-model and saved automatically in projectStore\n\n  // Close modal\n  isOpen.value = false;\n\n  await projectStore.saveProjectSettings();\n\n  // Show success message\n  const toast = useToast();\n  toast.add({\n    title: t('videoEditor.projectSettings.applied', 'Project settings applied'),\n    color: 'success',\n  });\n}\n\nasync function resetToDefaults() {\n  if (!projectStore.projectSettings) return;\n\n  // Reset project resolution and FPS to workspace defaults\n  const pDefaults = workspaceStore.userSettings.projectDefaults;\n  projectStore.projectSettings.project.width = pDefaults.width;\n  projectStore.projectSettings.project.height = pDefaults.height;\n  projectStore.projectSettings.project.fps = pDefaults.fps;\n  projectStore.projectSettings.project.resolutionFormat = pDefaults.resolutionFormat;\n  projectStore.projectSettings.project.orientation = pDefaults.orientation;\n  projectStore.projectSettings.project.aspectRatio = pDefaults.aspectRatio;\n  projectStore.projectSettings.project.isCustomResolution = pDefaults.isCustomResolution;\n\n  // Reset export encoding settings to workspace defaults\n  const eDefaults = workspaceStore.userSettings.exportDefaults.encoding;\n  projectStore.projectSettings.exportDefaults.encoding = {\n    ...eDefaults,\n    metadata: { title: '', author: '', tags: '' },\n  };\n\n  await projectStore.saveProjectSettings();\n}\n</script>\n\n<template>\n  <AppModal\n    v-model:open=\"isOpen\"\n    :title=\"\n      t('videoEditor.projectSettings.title', 'Project Settings') +\n      (projectStore.currentProjectName ? ': ' + projectStore.currentProjectName : '')\n    \"\n    :ui=\"{ content: 'sm:max-w-lg max-h-[90vh]', body: 'overflow-y-auto' }\"\n  >\n    <UiConfirmModal\n      v-model:open=\"isClearProjectVardataConfirmOpen\"\n      :title=\"t('videoEditor.projectSettings.clearTempTitle', 'Clear temporary files')\"\n      :description=\"\n        t(\n          'videoEditor.projectSettings.clearTempDescription',\n          'This will delete generated proxies, thumbnails and cached data for this project.',\n        )\n      \"\n      :confirm-text=\"t('videoEditor.projectSettings.clearTempConfirm', 'Clear')\"\n      :cancel-text=\"t('common.cancel', 'Cancel')\"\n      color=\"warning\"\n      icon=\"i-heroicons-trash\"\n      @confirm=\"confirmClearProjectVardata\"\n    />\n\n    <UiConfirmModal\n      v-model:open=\"isDeleteProjectConfirmOpen\"\n      :title=\"t('videoEditor.projectSettings.deleteProjectConfirmTitle', 'Delete Project?')\"\n      :description=\"\n        t(\n          'videoEditor.projectSettings.deleteProjectConfirmDescription',\n          'This will permanently delete the project folder and all its contents. This action cannot be undone.',\n        )\n      \"\n      :confirm-text=\"t('videoEditor.projectSettings.deleteProjectAction', 'Delete')\"\n      :cancel-text=\"t('common.cancel', 'Cancel')\"\n      color=\"error\"\n      icon=\"i-heroicons-trash\"\n      @confirm=\"confirmDeleteProject\"\n    />\n\n    <div class=\"space-y-6\">\n      <div class=\"text-xs text-ui-text-muted\">\n        {{\n          t('videoEditor.projectSettings.note', 'Settings are saved to .gran/project.settings.json')\n        }}\n      </div>\n\n      <!-- Resolution & FPS Settings -->\n      <div class=\"space-y-4\">\n        <h3 class=\"text-lg font-semibold text-ui-text\">\n          {{ t('videoEditor.projectSettings.resolutionAndFps', 'Resolution & FPS') }}\n        </h3>\n\n        <MediaResolutionSettings\n          v-model:width=\"projectStore.projectSettings.project.width\"\n          v-model:height=\"projectStore.projectSettings.project.height\"\n          v-model:fps=\"projectStore.projectSettings.project.fps\"\n          v-model:resolution-format=\"projectStore.projectSettings.project.resolutionFormat\"\n          v-model:orientation=\"projectStore.projectSettings.project.orientation\"\n          v-model:aspect-ratio=\"projectStore.projectSettings.project.aspectRatio\"\n          v-model:is-custom-resolution=\"projectStore.projectSettings.project.isCustomResolution\"\n          v-model:audio-channels=\"projectStore.projectSettings.project.audioChannels\"\n          v-model:sample-rate=\"projectStore.projectSettings.project.sampleRate\"\n        />\n      </div>\n\n      <div class=\"h-px bg-ui-border\"></div>\n\n      <!-- Export Settings -->\n      <div class=\"space-y-4\">\n        <h3 class=\"text-lg font-semibold text-ui-text\">\n          {{ t('videoEditor.projectSettings.export', 'Export Defaults') }}\n        </h3>\n\n        <MediaEncodingSettings\n          v-model:output-format=\"projectStore.projectSettings.exportDefaults.encoding.format\"\n          v-model:video-codec=\"projectStore.projectSettings.exportDefaults.encoding.videoCodec\"\n          v-model:bitrate-mbps=\"projectStore.projectSettings.exportDefaults.encoding.bitrateMbps\"\n          v-model:exclude-audio=\"projectStore.projectSettings.exportDefaults.encoding.excludeAudio\"\n          v-model:audio-codec=\"projectStore.projectSettings.exportDefaults.encoding.audioCodec\"\n          v-model:audio-bitrate-kbps=\"\n            projectStore.projectSettings.exportDefaults.encoding.audioBitrateKbps\n          \"\n          v-model:bitrate-mode=\"projectStore.projectSettings.exportDefaults.encoding.bitrateMode\"\n          v-model:keyframe-interval-sec=\"\n            projectStore.projectSettings.exportDefaults.encoding.keyframeIntervalSec\n          \"\n          v-model:export-alpha=\"projectStore.projectSettings.exportDefaults.encoding.exportAlpha\"\n          v-model:metadata-title=\"\n            projectStore.projectSettings.exportDefaults.encoding.metadata.title\n          \"\n          v-model:metadata-author=\"\n            projectStore.projectSettings.exportDefaults.encoding.metadata.author\n          \"\n          v-model:metadata-tags=\"projectStore.projectSettings.exportDefaults.encoding.metadata.tags\"\n          :show-metadata=\"true\"\n          :disabled=\"false\"\n          :has-audio=\"true\"\n          :is-loading-codec-support=\"isLoadingCodecSupport\"\n          :format-options=\"formatOptions\"\n          :video-codec-options=\"videoCodecOptions\"\n        />\n      </div>\n\n      <div class=\"h-px bg-ui-border\"></div>\n\n      <!-- Storage Settings -->\n      <div class=\"space-y-4\">\n        <h3 class=\"text-lg font-semibold text-ui-text\">\n          {{ t('videoEditor.projectSettings.storage', 'Storage') }}\n        </h3>\n\n        <div class=\"space-y-3\">\n          <!-- Clear Vardata -->\n          <div class=\"flex items-center justify-between gap-3 p-3 rounded border border-ui-border\">\n            <div class=\"flex flex-col gap-1 min-w-0\">\n              <div class=\"text-sm font-medium text-ui-text\">\n                {{ t('videoEditor.projectSettings.clearTemp', 'Clear temporary files') }}\n              </div>\n              <div class=\"text-xs text-ui-text-muted\">\n                {{\n                  t(\n                    'videoEditor.projectSettings.clearTempHint',\n                    'Removes all files from vardata for this project',\n                  )\n                }}\n              </div>\n            </div>\n\n            <UButton\n              color=\"warning\"\n              variant=\"soft\"\n              icon=\"i-heroicons-trash\"\n              :disabled=\"!projectStore.currentProjectId\"\n              :label=\"t('videoEditor.projectSettings.clearTempAction', 'Clear')\"\n              @click=\"isClearProjectVardataConfirmOpen = true\"\n            />\n          </div>\n\n          <!-- Delete Project -->\n          <div\n            class=\"flex items-center justify-between gap-3 p-3 rounded border border-error-500/20 bg-error-500/5\"\n          >\n            <div class=\"flex flex-col gap-1 min-w-0\">\n              <div class=\"text-sm font-medium text-error-400\">\n                {{ t('videoEditor.projectSettings.deleteProject', 'Delete Project') }}\n              </div>\n              <div class=\"text-xs text-error-400/70\">\n                {{\n                  t(\n                    'videoEditor.projectSettings.deleteProjectConfirmDescription',\n                    'Permanently delete project folder and all its content',\n                  )\n                }}\n              </div>\n            </div>\n\n            <UButton\n              color=\"error\"\n              variant=\"solid\"\n              icon=\"i-heroicons-trash\"\n              :label=\"t('videoEditor.projectSettings.deleteProjectAction', 'Delete')\"\n              @click=\"isDeleteProjectConfirmOpen = true\"\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <template #footer>\n      <div class=\"flex items-center justify-between w-full\">\n        <UButton\n          variant=\"ghost\"\n          color=\"neutral\"\n          :label=\"t('videoEditor.projectSettings.reset', 'Reset to Defaults')\"\n          @click=\"resetToDefaults\"\n        />\n        <div class=\"flex items-center gap-2\">\n          <UButton\n            variant=\"ghost\"\n            color=\"neutral\"\n            :label=\"t('common.cancel', 'Cancel')\"\n            @click=\"(isOpen = false) && projectStore.saveProjectSettings()\"\n          />\n          <UButton\n            variant=\"solid\"\n            color=\"primary\"\n            :label=\"t('videoEditor.projectSettings.apply', 'Apply Settings')\"\n            @click=\"applySettings\"\n          />\n        </div>\n      </div>\n    </template>\n  </AppModal>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/Timeline.vue","messages":[{"ruleId":"vue/multi-word-component-names","severity":1,"message":"Component name \"Timeline\" should always be multi-word.","line":1,"column":1,"messageId":"unexpected"},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":404,"column":17,"messageId":"unexpectedAny","endLine":404,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11971,11974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11971,11974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":418,"column":15,"messageId":"unexpectedAny","endLine":418,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12303,12306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12303,12306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":491,"column":17,"messageId":"unexpectedAny","endLine":491,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14190,14193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14190,14193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, ref, watch } from 'vue';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useTimelineMediaUsageStore } from '~/stores/timeline-media-usage.store';\nimport type { TimelineTrack } from '~/timeline/types';\nimport {\n  useTimelineInteraction,\n  computeAnchoredScrollLeft,\n  timeUsToPx,\n  pxToTimeUs,\n} from '~/composables/timeline/useTimelineInteraction';\nimport { useDraggedFile } from '~/composables/useDraggedFile';\nimport { Splitpanes, Pane } from 'splitpanes';\nimport 'splitpanes/dist/splitpanes.css';\nimport { useLocalStorage } from '@vueuse/core';\nimport TimelineToolbar from '~/components/timeline/TimelineToolbar.vue';\nimport TimelineTrackLabels from '~/components/timeline/TimelineTrackLabels.vue';\nimport TimelineTracks from '~/components/timeline/TimelineTracks.vue';\nimport TimelineRuler from '~/components/timeline/TimelineRuler.vue';\n\nconst { t } = useI18n();\nconst toast = useToast();\nconst timelineStore = useTimelineStore();\nconst mediaStore = useMediaStore();\nconst focusStore = useFocusStore();\nconst timelineMediaUsageStore = useTimelineMediaUsageStore();\nconst { draggedFile, clearDraggedFile } = useDraggedFile();\n\nconst timelineSplitSizes = useLocalStorage<number[]>('gran-editor-timeline-split-v4', [10, 90]);\n\nfunction onTimelineSplitResize(event: { panes: { size: number }[] }) {\n  if (Array.isArray(event?.panes)) {\n    timelineSplitSizes.value = event.panes.map((p) => p.size);\n  }\n}\n\nconst trackHeights = useLocalStorage<Record<string, number>>('gran-editor-track-heights-v1', {});\n\nfunction updateTrackHeight(trackId: string, height: number) {\n  trackHeights.value[trackId] = height;\n}\n\nconst tracks = computed(\n  () => (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [],\n);\n\nconst scrollEl = ref<HTMLElement | null>(null);\n\nconst pendingZoomAnchor = ref<\n  import('~/composables/timeline/useTimelineInteraction').TimelineZoomAnchor | null\n>(null);\n\nconst dragPreview = ref<{\n  trackId: string;\n  startUs: number;\n  label: string;\n  durationUs: number;\n  kind: 'timeline-clip' | 'file';\n} | null>(null);\n\nconst {\n  draggingMode,\n  draggingItemId,\n  movePreview,\n  onTimeRulerMouseDown,\n  startPlayheadDrag,\n  selectItem,\n  startMoveItem,\n  startTrimItem,\n} = useTimelineInteraction(scrollEl, tracks);\n\nfunction getViewportWidth(): number {\n  return scrollEl.value?.clientWidth ?? 0;\n}\n\nfunction makePlayheadAnchor(params: {\n  zoom: number;\n}): import('~/composables/timeline/useTimelineInteraction').TimelineZoomAnchor {\n  const viewportWidth = getViewportWidth();\n  const prevScrollLeft = scrollEl.value?.scrollLeft ?? 0;\n  const playheadPx = timeUsToPx(timelineStore.currentTime, params.zoom);\n  const isVisible = playheadPx >= prevScrollLeft && playheadPx <= prevScrollLeft + viewportWidth;\n  return {\n    anchorTimeUs: timelineStore.currentTime,\n    anchorViewportX: isVisible ? playheadPx - prevScrollLeft : viewportWidth / 2,\n  };\n}\n\nfunction applyZoomWithAnchor(params: {\n  nextZoom: number;\n  anchor: import('~/composables/timeline/useTimelineInteraction').TimelineZoomAnchor;\n}) {\n  const el = scrollEl.value;\n  if (!el) {\n    timelineStore.setTimelineZoom(params.nextZoom);\n    return;\n  }\n\n  const prevZoom = timelineStore.timelineZoom;\n  const nextZoom = params.nextZoom;\n  if (nextZoom === prevZoom) return;\n\n  const prevScrollLeft = el.scrollLeft;\n  const viewportWidth = el.clientWidth;\n\n  pendingZoomAnchor.value = params.anchor;\n  timelineStore.setTimelineZoom(nextZoom);\n\n  requestAnimationFrame(() => {\n    const anchor = pendingZoomAnchor.value;\n    if (!anchor) return;\n    pendingZoomAnchor.value = null;\n\n    const nextScrollLeft = computeAnchoredScrollLeft({\n      prevZoom,\n      nextZoom,\n      prevScrollLeft,\n      viewportWidth,\n      anchor,\n    });\n    el.scrollLeft = nextScrollLeft;\n  });\n}\n\nconst isPanning = ref(false);\nconst panStartX = ref(0);\nconst panStartScrollLeft = ref(0);\n\nconst clickStartX = ref(0);\nconst clickStartY = ref(0);\n\nfunction onTimelinePointerDownCapture(e: PointerEvent) {\n  if (e.button === 0) {\n    clickStartX.value = e.clientX;\n    clickStartY.value = e.clientY;\n  }\n}\n\nfunction onTimelineClick(e: MouseEvent) {\n  if (e.button !== 0) return;\n  const dx = Math.abs(e.clientX - clickStartX.value);\n  const dy = Math.abs(e.clientY - clickStartY.value);\n  if (dx > 3 || dy > 3) return; // Ignore drag\n\n  const target = e.target as HTMLElement | null;\n  if (target?.closest('button')) return;\n  if (target?.closest('.cursor-ew-resize')) return;\n  if (target?.closest('.cursor-ns-resize')) return;\n\n  const el = scrollEl.value;\n  if (!el) return;\n  const scrollerRect = el.getBoundingClientRect();\n  const scrollX = el.scrollLeft;\n  const x = e.clientX - scrollerRect.left + scrollX;\n\n  timelineStore.currentTime = pxToTimeUs(x, timelineStore.timelineZoom);\n}\n\nfunction onTimelinePointerDown(e: PointerEvent) {\n  if (e.button === 1) {\n    // Middle click\n    const workspaceStore = useWorkspaceStore();\n    const settings = workspaceStore.userSettings?.mouse?.timeline;\n\n    if (settings?.middleClick === 'pan') {\n      const el = scrollEl.value;\n      if (!el) return;\n\n      isPanning.value = true;\n      panStartX.value = e.clientX;\n      panStartScrollLeft.value = el.scrollLeft;\n\n      (e.currentTarget as HTMLElement | null)?.setPointerCapture(e.pointerId);\n      e.preventDefault();\n    }\n  }\n}\n\nfunction onTimelinePointerMove(e: PointerEvent) {\n  if (!isPanning.value) return;\n  const el = scrollEl.value;\n  if (!el) return;\n\n  const dx = e.clientX - panStartX.value;\n  // Move opposite to mouse direction for natural panning\n  el.scrollLeft = Math.max(0, panStartScrollLeft.value - dx);\n}\n\nfunction onTimelinePointerUp(e: PointerEvent) {\n  if (!isPanning.value) return;\n  isPanning.value = false;\n  try {\n    (e.currentTarget as HTMLElement | null)?.releasePointerCapture(e.pointerId);\n  } catch {\n    // ignore\n  }\n}\n\nfunction onTimelineWheel(e: WheelEvent) {\n  const el = scrollEl.value;\n  if (!el) return;\n\n  const isShift = e.shiftKey;\n  const isSecondary =\n    (e.deltaX !== 0 && Math.abs(e.deltaX) > Math.abs(e.deltaY)) || (!e.deltaY && e.deltaX !== 0);\n\n  const workspaceStore = useWorkspaceStore();\n  const settings = workspaceStore.userSettings?.mouse?.timeline ?? {\n    wheel: 'scroll_vertical',\n    wheelShift: 'scroll_horizontal',\n    wheelSecondary: 'scroll_horizontal',\n    wheelSecondaryShift: 'zoom_vertical',\n    middleClick: 'pan',\n  };\n\n  let action = settings.wheel;\n  if (isSecondary && isShift) action = settings.wheelSecondaryShift;\n  else if (isSecondary) action = settings.wheelSecondary;\n  else if (isShift) action = settings.wheelShift;\n\n  if (action === 'none') {\n    e.preventDefault();\n    return;\n  }\n\n  // Calculate delta amount based on event\n  const delta = isSecondary ? e.deltaX : e.deltaY;\n  if (!Number.isFinite(delta) || delta === 0) return;\n\n  if (action === 'scroll_vertical') {\n    // Let browser handle vertical scrolling natively if it's the primary action without modifiers\n    // This allows smooth scrolling and proper trackpad support\n    if (!isShift && !isSecondary) return;\n\n    e.preventDefault();\n    // Use the Splitpanes content element for vertical scrolling\n    const splitpanesEl = document.querySelector('.editor-splitpanes') as HTMLElement;\n    if (splitpanesEl) {\n      splitpanesEl.scrollTop += delta;\n    }\n    return;\n  }\n\n  if (action === 'scroll_horizontal') {\n    // If browser is already scrolling horizontally (like trackpad swipe), let it handle it\n    if (isSecondary && !isShift) return;\n\n    e.preventDefault();\n    el.scrollLeft += delta;\n    return;\n  }\n\n  if (action === 'zoom_horizontal') {\n    e.preventDefault();\n\n    const prevZoom = timelineStore.timelineZoom;\n    const dir = delta < 0 ? 1 : -1;\n    const step = 3;\n    const nextZoom = Math.min(100, Math.max(0, Math.round(prevZoom + dir * step)));\n\n    const rect = el.getBoundingClientRect();\n    const viewportX = e.clientX - rect.left;\n    const prevScrollLeft = el.scrollLeft;\n    const anchorPx = prevScrollLeft + viewportX;\n    const anchorTimeUs = pxToTimeUs(anchorPx, prevZoom);\n\n    applyZoomWithAnchor({\n      nextZoom,\n      anchor: {\n        anchorTimeUs,\n        anchorViewportX: viewportX,\n      },\n    });\n    return;\n  }\n\n  if (action === 'zoom_vertical') {\n    e.preventDefault();\n\n    const dir = delta < 0 ? 1 : -1;\n    const step = 10;\n\n    const docTracks = timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined;\n    if (!docTracks) return;\n\n    for (const track of docTracks) {\n      const currentHeight = trackHeights.value[track.id] ?? 40; // DEFAULT_TRACK_HEIGHT\n      const nextHeight = Math.max(32, Math.min(300, currentHeight + dir * step)); // MIN/MAX from labels\n      updateTrackHeight(track.id, nextHeight);\n    }\n    return;\n  }\n}\n\nwatch(\n  () => timelineStore.timelineZoom,\n  (nextZoom, prevZoom) => {\n    const el = scrollEl.value;\n    if (!el) return;\n    if (!Number.isFinite(prevZoom)) return;\n    if (nextZoom === prevZoom) return;\n\n    const prevScrollLeft = el.scrollLeft;\n    const viewportWidth = el.clientWidth;\n    const anchor = pendingZoomAnchor.value ?? makePlayheadAnchor({ zoom: prevZoom });\n    pendingZoomAnchor.value = null;\n\n    requestAnimationFrame(() => {\n      const nextScrollLeft = computeAnchoredScrollLeft({\n        prevZoom,\n        nextZoom,\n        prevScrollLeft,\n        viewportWidth,\n        anchor,\n      });\n      el.scrollLeft = nextScrollLeft;\n    });\n  },\n);\n\nfunction clearDragPreview() {\n  dragPreview.value = null;\n}\n\nfunction getDropStartUs(e: DragEvent): number | null {\n  const scrollerRect = scrollEl.value?.getBoundingClientRect();\n  const scrollX = scrollEl.value?.scrollLeft ?? 0;\n  if (!scrollerRect) return null;\n  const x = e.clientX - scrollerRect.left + scrollX;\n  return pxToTimeUs(x, timelineStore.timelineZoom);\n}\n\nfunction onTrackDragOver(e: DragEvent, trackId: string) {\n  const startUs = getDropStartUs(e);\n  if (startUs === null) return;\n\n  const file = draggedFile.value;\n  if (!file) {\n    clearDragPreview();\n    return;\n  }\n\n  let durationUs = 2_000_000;\n  if (file.kind === 'adjustment' || file.kind === 'background' || file.kind === 'text') {\n    durationUs = 5_000_000;\n  } else if (file.kind !== 'timeline') {\n    const metadata = mediaStore.mediaMetadata[file.path];\n    if (metadata) {\n      const hasVideo = Boolean(metadata.video);\n      const hasAudio = Boolean(metadata.audio);\n      const isImageLike = !hasVideo && !hasAudio;\n      if (isImageLike) {\n        durationUs = 5_000_000;\n      } else {\n        const durationS = Number(metadata.duration);\n        if (Number.isFinite(durationS) && durationS > 0) {\n          durationUs = Math.floor(durationS * 1_000_000);\n        }\n      }\n    }\n  }\n\n  dragPreview.value = {\n    trackId,\n    startUs,\n    label: file.name,\n    durationUs,\n    kind: file.kind === 'file' ? 'file' : 'timeline-clip',\n  };\n}\n\nfunction onTrackDragLeave() {\n  clearDragPreview();\n}\n\nasync function onClipAction(payload: {\n  action: 'extractAudio' | 'returnAudio' | 'freezeFrame' | 'resetFreezeFrame';\n  trackId: string;\n  itemId: string;\n  videoItemId?: string;\n}) {\n  try {\n    if (payload.action === 'extractAudio') {\n      await timelineStore.extractAudioToTrack({\n        videoTrackId: payload.trackId,\n        videoItemId: payload.itemId,\n      });\n    } else if (payload.action === 'freezeFrame') {\n      timelineStore.setClipFreezeFrameFromPlayhead({\n        trackId: payload.trackId,\n        itemId: payload.itemId,\n      });\n    } else if (payload.action === 'resetFreezeFrame') {\n      timelineStore.resetClipFreezeFrame({\n        trackId: payload.trackId,\n        itemId: payload.itemId,\n      });\n    } else {\n      timelineStore.returnAudioToVideo({ videoItemId: payload.videoItemId ?? payload.itemId });\n    }\n    await timelineStore.requestTimelineSave({ immediate: true });\n  } catch (err: any) {\n    toast.add({\n      title: t('common.error', 'Error'),\n      description: String(err?.message ?? err ?? ''),\n      icon: 'i-heroicons-exclamation-triangle',\n      color: 'error',\n    });\n  }\n}\n\nasync function onDrop(e: DragEvent, trackId: string) {\n  clearDragPreview();\n  const startUs = getDropStartUs(e);\n\n  let parsed: any = null;\n  const raw = e.dataTransfer?.getData('application/json');\n  if (raw) {\n    try {\n      parsed = JSON.parse(raw);\n    } catch {\n      parsed = null;\n    }\n  }\n\n  if (!parsed && draggedFile.value) {\n    parsed = {\n      kind: draggedFile.value.kind,\n      name: draggedFile.value.name,\n      path: draggedFile.value.path,\n    };\n  }\n\n  const kind = typeof parsed?.kind === 'string' ? parsed.kind : undefined;\n  if (\n    kind &&\n    kind !== 'file' &&\n    kind !== 'timeline' &&\n    kind !== 'adjustment' &&\n    kind !== 'background' &&\n    kind !== 'text'\n  ) {\n    clearDraggedFile();\n    return;\n  }\n\n  const name = typeof parsed?.name === 'string' ? parsed.name : undefined;\n  const path = typeof parsed?.path === 'string' ? parsed.path : undefined;\n  const isVirtual = kind === 'adjustment' || kind === 'background' || kind === 'text';\n  if (!name || (!isVirtual && !path)) {\n    clearDraggedFile();\n    return;\n  }\n\n  try {\n    if (kind === 'adjustment' || kind === 'background' || kind === 'text') {\n      timelineStore.addVirtualClipToTrack({\n        trackId,\n        startUs: startUs ?? timelineStore.currentTime,\n        clipType: kind,\n        name,\n        text: kind === 'text' ? name : undefined,\n      });\n      await timelineStore.requestTimelineSave({ immediate: true });\n    } else if (kind === 'timeline') {\n      await timelineStore.addTimelineClipToTimelineFromPath({\n        trackId,\n        name,\n        path,\n        startUs: startUs ?? undefined,\n      });\n    } else {\n      await timelineStore.addClipToTimelineFromPath({\n        trackId,\n        name,\n        path,\n        startUs: startUs ?? undefined,\n      });\n    }\n\n    toast.add({\n      title: 'Clip Added',\n      description: `${name} added to track`,\n      icon: 'i-heroicons-check-circle',\n      color: 'success',\n    });\n\n    void timelineMediaUsageStore.refreshUsage();\n  } catch (err: any) {\n    toast.add({\n      title: t('common.error', 'Error'),\n      description: String(err?.message ?? err ?? ''),\n      icon: 'i-heroicons-exclamation-triangle',\n      color: 'error',\n    });\n  } finally {\n    clearDraggedFile();\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col h-full bg-ui-bg border-t border-ui-border\"\n    :class=\"{\n      'outline-2 outline-primary-500/60 -outline-offset-2 z-10':\n        focusStore.isPanelFocused('timeline'),\n    }\"\n    @pointerdown=\"focusStore.setMainFocus('timeline')\"\n  >\n    <!-- Toolbar -->\n    <TimelineToolbar\n      @update:zoom=\"\n        (v) =>\n          applyZoomWithAnchor({\n            nextZoom: v,\n            anchor: makePlayheadAnchor({ zoom: timelineStore.timelineZoom }),\n          })\n      \"\n    />\n\n    <ClientOnly>\n      <Splitpanes\n        class=\"flex flex-1 min-h-0 overflow-hidden editor-splitpanes\"\n        @resized=\"onTimelineSplitResize\"\n      >\n        <Pane :size=\"timelineSplitSizes[0]\" min-size=\"5\" max-size=\"50\">\n          <TimelineTrackLabels\n            :tracks=\"tracks\"\n            :track-heights=\"trackHeights\"\n            class=\"h-full border-r border-ui-border\"\n            @update:track-height=\"updateTrackHeight\"\n          />\n        </Pane>\n        <Pane :size=\"timelineSplitSizes[1]\" min-size=\"50\">\n          <div class=\"flex flex-col h-full w-full relative\">\n            <TimelineRuler\n              class=\"h-7 border-b border-ui-border bg-ui-bg-elevated z-10 cursor-pointer shrink-0\"\n              :scroll-el=\"scrollEl\"\n              @mousedown=\"onTimeRulerMouseDown\"\n            />\n            <div\n              ref=\"scrollEl\"\n              class=\"w-full flex-1 overflow-x-auto overflow-y-hidden relative\"\n              @pointerdown.capture=\"onTimelinePointerDownCapture\"\n              @pointerdown=\"onTimelinePointerDown\"\n              @pointermove=\"onTimelinePointerMove\"\n              @pointerup=\"onTimelinePointerUp\"\n              @pointercancel=\"onTimelinePointerUp\"\n              @click=\"onTimelineClick\"\n              @wheel=\"onTimelineWheel\"\n            >\n              <!-- Tracks -->\n              <TimelineTracks\n                ref=\"timelineTracksRef\"\n                :tracks=\"tracks\"\n                :track-heights=\"trackHeights\"\n                :drag-preview=\"dragPreview\"\n                :move-preview=\"movePreview\"\n                :dragging-mode=\"draggingMode\"\n                :dragging-item-id=\"draggingItemId\"\n                @drop=\"onDrop\"\n                @dragover=\"onTrackDragOver\"\n                @dragleave=\"onTrackDragLeave\"\n                @start-move-item=\"startMoveItem\"\n                @select-item=\"selectItem\"\n                @start-trim-item=\"startTrimItem\"\n                @clip-action=\"onClipAction\"\n              />\n\n              <!-- Playhead -->\n              <div\n                class=\"absolute top-0 bottom-0 w-px bg-primary-500 cursor-ew-resize pointer-events-auto\"\n                :style=\"{\n                  left: `${timeUsToPx(timelineStore.currentTime, timelineStore.timelineZoom)}px`,\n                }\"\n                @mousedown=\"startPlayheadDrag\"\n              ></div>\n            </div>\n          </div>\n        </Pane>\n      </Splitpanes>\n    </ClientOnly>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/TimelineExportModal.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":196,"column":17,"messageId":"unexpectedAny","endLine":196,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5830,5833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5830,5833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":17,"messageId":"unexpectedAny","endLine":205,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6068,6071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6068,6071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":17,"messageId":"unexpectedAny","endLine":291,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9744,9747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9744,9747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, watch, ref } from 'vue';\nimport { useProjectStore } from '~/stores/project.store';\nimport MediaEncodingSettings, {\n  type FormatOption,\n} from '~/components/media/MediaEncodingSettings.vue';\nimport MediaResolutionSettings from '~/components/media/MediaResolutionSettings.vue';\nimport AppModal from '~/components/ui/AppModal.vue';\nimport { BASE_VIDEO_CODEC_OPTIONS, resolveVideoCodecOptions } from '~/utils/webcodecs';\nimport {\n  useTimelineExport,\n  sanitizeBaseName,\n  resolveExportCodecs,\n  getExt,\n} from '~/composables/timeline/useTimelineExport';\n\ninterface Props {\n  open: boolean;\n}\n\nconst props = defineProps<Props>();\n\nconst emit = defineEmits<{\n  'update:open': [value: boolean];\n  exported: [];\n}>();\n\nconst { t } = useI18n();\nconst toast = useToast();\nconst projectStore = useProjectStore();\nconst saveAsDefaults = ref(false);\n\nconst {\n  isExporting,\n  exportProgress,\n  exportError,\n  exportPhase,\n  exportWarnings,\n  outputFilename,\n  filenameError,\n  outputFormat,\n  videoCodec,\n  bitrateMbps,\n  excludeAudio,\n  audioCodec,\n  audioBitrateKbps,\n  exportWidth,\n  exportHeight,\n  exportFps,\n  resolutionFormat,\n  orientation,\n  aspectRatio,\n  isCustomResolution,\n  bitrateMode,\n  keyframeIntervalSec,\n  exportAlpha,\n  metadataTitle,\n  metadataAuthor,\n  metadataTags,\n  videoCodecSupport,\n  isLoadingCodecSupport,\n  bitrateBps,\n  normalizedExportWidth,\n  normalizedExportHeight,\n  normalizedExportFps,\n  ensureExportDir,\n  preloadExportIndex,\n  validateFilename,\n  getNextAvailableFilename,\n  rememberExportedFilename,\n  loadCodecSupport,\n  exportTimelineToFile,\n  cancelExport,\n  cancelRequested,\n} = useTimelineExport();\n\nconst isOpen = computed({\n  get: () => props.open,\n  set: (v) => emit('update:open', v),\n});\n\nfunction getFormatOptions(): readonly FormatOption[] {\n  return [\n    { value: 'mp4', label: 'MP4' },\n    { value: 'webm', label: 'WebM (VP9/OPUS)' },\n    { value: 'mkv', label: 'MKV (AV1|OPUS)' },\n  ];\n}\n\nfunction getVideoCodecOptions() {\n  return resolveVideoCodecOptions(BASE_VIDEO_CODEC_OPTIONS, videoCodecSupport.value);\n}\n\nfunction getPhaseLabel() {\n  if (exportPhase.value === 'encoding') return t('videoEditor.export.phaseEncoding', 'Encoding');\n  if (exportPhase.value === 'saving') return t('videoEditor.export.phaseSaving', 'Saving');\n  return '';\n}\n\nwatch(\n  () => props.open,\n  async (val) => {\n    if (!val) return;\n\n    exportError.value = null;\n    exportWarnings.value = [];\n    filenameError.value = null;\n    exportProgress.value = 0;\n    exportPhase.value = null;\n    isExporting.value = false;\n    saveAsDefaults.value = false;\n\n    await loadCodecSupport();\n\n    outputFormat.value = projectStore.projectSettings.exportDefaults.encoding.format;\n    videoCodec.value = projectStore.projectSettings.exportDefaults.encoding.videoCodec;\n    bitrateMbps.value = projectStore.projectSettings.exportDefaults.encoding.bitrateMbps;\n    excludeAudio.value = projectStore.projectSettings.exportDefaults.encoding.excludeAudio;\n    audioCodec.value = projectStore.projectSettings.exportDefaults.encoding.audioCodec;\n    audioBitrateKbps.value = projectStore.projectSettings.exportDefaults.encoding.audioBitrateKbps;\n    bitrateMode.value = projectStore.projectSettings.exportDefaults.encoding.bitrateMode;\n    keyframeIntervalSec.value =\n      projectStore.projectSettings.exportDefaults.encoding.keyframeIntervalSec;\n    exportAlpha.value = projectStore.projectSettings.exportDefaults.encoding.exportAlpha;\n    metadataTitle.value = projectStore.projectSettings.exportDefaults.encoding.metadata.title;\n    metadataAuthor.value = projectStore.projectSettings.exportDefaults.encoding.metadata.author;\n    metadataTags.value = projectStore.projectSettings.exportDefaults.encoding.metadata.tags;\n    exportWidth.value = projectStore.projectSettings.project.width;\n    exportHeight.value = projectStore.projectSettings.project.height;\n    exportFps.value = projectStore.projectSettings.project.fps;\n    resolutionFormat.value = projectStore.projectSettings.project.resolutionFormat;\n    orientation.value = projectStore.projectSettings.project.orientation;\n    aspectRatio.value = projectStore.projectSettings.project.aspectRatio;\n    isCustomResolution.value = projectStore.projectSettings.project.isCustomResolution;\n\n    await ensureExportDir();\n    await preloadExportIndex();\n    const timelineBase = sanitizeBaseName(\n      projectStore.currentFileName || projectStore.currentProjectName || 'timeline',\n    );\n    outputFilename.value = await getNextAvailableFilename(timelineBase, getExt(outputFormat.value));\n    await validateFilename();\n  },\n);\n\nwatch(outputFormat, async (fmt) => {\n  const codecConfig = resolveExportCodecs(fmt, videoCodec.value, audioCodec.value);\n  videoCodec.value = codecConfig.videoCodec;\n  audioCodec.value = codecConfig.audioCodec;\n\n  if (!props.open) return;\n\n  try {\n    const base = outputFilename.value.replace(/\\.[^.]+$/, '');\n    const nextExt = getExt(fmt);\n\n    if (!base) return;\n\n    if (!/_\\d{3}$/.test(base)) {\n      outputFilename.value = await getNextAvailableFilename(base, nextExt);\n      return;\n    }\n\n    outputFilename.value = `${base}.${nextExt}`;\n    await validateFilename();\n  } catch {\n    // ignore\n  }\n});\n\nwatch(outputFilename, async () => {\n  if (!props.open) return;\n  try {\n    await validateFilename();\n  } catch {\n    // ignore\n  }\n});\n\nasync function handleConfirm() {\n  if (isExporting.value) return;\n\n  isExporting.value = true;\n  exportProgress.value = 0;\n  exportError.value = null;\n  exportWarnings.value = [];\n\n  try {\n    const exportDir = await ensureExportDir();\n    const ok = await validateFilename();\n    if (!ok) return;\n\n    try {\n      await exportDir.getFileHandle(outputFilename.value);\n      throw new Error('A file with this name already exists');\n    } catch (e: any) {\n      if (e?.name !== 'NotFoundError') {\n        throw e;\n      }\n    }\n\n    let fileHandle: FileSystemFileHandle;\n    try {\n      fileHandle = await exportDir.getFileHandle(outputFilename.value, { create: true });\n    } catch (e: any) {\n      if (e?.name === 'NotAllowedError' || e?.name === 'InvalidModificationError') {\n        throw new Error('A file with this name already exists', { cause: e });\n      }\n      throw e;\n    }\n\n    const resolvedCodecs = resolveExportCodecs(\n      outputFormat.value,\n      videoCodec.value,\n      audioCodec.value as 'aac' | 'opus',\n    );\n\n    if (saveAsDefaults.value) {\n      projectStore.projectSettings.project.width = normalizedExportWidth.value;\n      projectStore.projectSettings.project.height = normalizedExportHeight.value;\n      projectStore.projectSettings.project.fps = normalizedExportFps.value;\n      projectStore.projectSettings.project.resolutionFormat = resolutionFormat.value;\n      projectStore.projectSettings.project.orientation = orientation.value;\n      projectStore.projectSettings.project.aspectRatio = aspectRatio.value;\n      projectStore.projectSettings.project.isCustomResolution = isCustomResolution.value;\n      projectStore.projectSettings.exportDefaults.encoding.format = outputFormat.value;\n      projectStore.projectSettings.exportDefaults.encoding.videoCodec = resolvedCodecs.videoCodec;\n      projectStore.projectSettings.exportDefaults.encoding.bitrateMbps = bitrateMbps.value;\n      projectStore.projectSettings.exportDefaults.encoding.excludeAudio = excludeAudio.value;\n      projectStore.projectSettings.exportDefaults.encoding.audioCodec = resolvedCodecs.audioCodec;\n      projectStore.projectSettings.exportDefaults.encoding.audioBitrateKbps =\n        audioBitrateKbps.value;\n      projectStore.projectSettings.exportDefaults.encoding.bitrateMode = bitrateMode.value;\n      projectStore.projectSettings.exportDefaults.encoding.keyframeIntervalSec =\n        keyframeIntervalSec.value;\n      projectStore.projectSettings.exportDefaults.encoding.exportAlpha = exportAlpha.value;\n      projectStore.projectSettings.exportDefaults.encoding.metadata.title = metadataTitle.value;\n      projectStore.projectSettings.exportDefaults.encoding.metadata.author = metadataAuthor.value;\n      projectStore.projectSettings.exportDefaults.encoding.metadata.tags = metadataTags.value;\n      await projectStore.saveProjectSettings();\n    }\n\n    exportPhase.value = 'encoding';\n    await exportTimelineToFile(\n      {\n        format: outputFormat.value,\n        videoCodec: resolvedCodecs.videoCodec,\n        bitrate: bitrateBps.value,\n        audioBitrate: audioBitrateKbps.value * 1000,\n        audio: !excludeAudio.value,\n        audioCodec: resolvedCodecs.audioCodec,\n        width: normalizedExportWidth.value,\n        height: normalizedExportHeight.value,\n        fps: normalizedExportFps.value,\n        bitrateMode: bitrateMode.value,\n        keyframeIntervalSec: keyframeIntervalSec.value,\n        exportAlpha: exportAlpha.value,\n        metadata: {\n          title: metadataTitle.value,\n          author: metadataAuthor.value,\n          tags: metadataTags.value,\n        },\n      },\n      fileHandle,\n      (progress) => {\n        exportProgress.value = progress;\n      },\n    );\n    rememberExportedFilename(outputFilename.value);\n\n    if (exportWarnings.value.length > 0) {\n      toast.add({\n        title: t('videoEditor.export.warningTitle', 'Export warnings'),\n        description: exportWarnings.value[0]!,\n        color: 'warning',\n        icon: 'i-heroicons-exclamation-triangle',\n      });\n    }\n\n    toast.add({\n      title: t('videoEditor.export.successTitle', 'Export successful'),\n      description: t('videoEditor.export.successDesc', {\n        file: outputFilename.value,\n      }),\n      color: 'success',\n      icon: 'i-heroicons-check-circle',\n    });\n\n    emit('exported');\n    isOpen.value = false;\n  } catch (err: any) {\n    console.error('Export failed:', err);\n    if (err?.name === 'AbortError') {\n      exportError.value = t('videoEditor.export.errorCancelled', 'Export was cancelled');\n    } else {\n      exportError.value =\n        err?.message || t('videoEditor.export.errorGeneric', 'An error occurred during export');\n    }\n  } finally {\n    isExporting.value = false;\n    exportPhase.value = null;\n  }\n}\n</script>\n\n<template>\n  <AppModal\n    v-model:open=\"isOpen\"\n    :prevent-close=\"isExporting\"\n    :title=\"t('videoEditor.export.title', 'Export Timeline')\"\n    :ui=\"{ content: 'sm:max-w-lg' }\"\n  >\n    <div class=\"flex flex-col gap-6\">\n      <div class=\"flex flex-col gap-1.5\">\n        <UFormField\n          :label=\"t('videoEditor.export.filename', 'Filename')\"\n          :error=\"filenameError ?? undefined\"\n        >\n          <UInput\n            v-model=\"outputFilename\"\n            class=\"w-full\"\n            :disabled=\"isExporting\"\n            :placeholder=\"t('videoEditor.export.filenamePlaceholder', 'e.g. video.mp4')\"\n          />\n        </UFormField>\n        <div class=\"text-xs text-ui-text-muted flex items-center gap-1.5 mt-1\">\n          <UIcon name=\"i-heroicons-information-circle\" class=\"w-4 h-4 shrink-0\" />\n          <span class=\"leading-relaxed\">\n            {{\n              t(\n                'videoEditor.export.saveLocationNote',\n                'File will be saved to the export/ folder in your project directory',\n              )\n            }}\n          </span>\n        </div>\n      </div>\n\n      <MediaResolutionSettings\n        v-model:width=\"exportWidth\"\n        v-model:height=\"exportHeight\"\n        v-model:fps=\"exportFps\"\n        v-model:resolution-format=\"resolutionFormat\"\n        v-model:orientation=\"orientation\"\n        v-model:aspect-ratio=\"aspectRatio\"\n        v-model:is-custom-resolution=\"isCustomResolution\"\n        :disabled=\"isExporting\"\n      />\n\n      <MediaEncodingSettings\n        v-model:output-format=\"outputFormat\"\n        v-model:video-codec=\"videoCodec\"\n        v-model:bitrate-mbps=\"bitrateMbps\"\n        v-model:exclude-audio=\"excludeAudio\"\n        v-model:audio-codec=\"audioCodec\"\n        v-model:audio-bitrate-kbps=\"audioBitrateKbps\"\n        v-model:bitrate-mode=\"bitrateMode\"\n        v-model:keyframe-interval-sec=\"keyframeIntervalSec\"\n        v-model:export-alpha=\"exportAlpha\"\n        v-model:metadata-title=\"metadataTitle\"\n        v-model:metadata-author=\"metadataAuthor\"\n        v-model:metadata-tags=\"metadataTags\"\n        :show-metadata=\"true\"\n        :disabled=\"isExporting\"\n        :has-audio=\"true\"\n        :is-loading-codec-support=\"isLoadingCodecSupport\"\n        :format-options=\"getFormatOptions()\"\n        :video-codec-options=\"getVideoCodecOptions()\"\n      />\n\n      <label class=\"flex items-center gap-3 cursor-pointer mt-2\">\n        <UCheckbox v-model=\"saveAsDefaults\" :disabled=\"isExporting\" />\n        <span class=\"text-sm text-ui-text\">{{\n          t('videoEditor.export.saveAsDefault', 'Save as project settings')\n        }}</span>\n      </label>\n\n      <div\n        v-if=\"exportError\"\n        class=\"p-3 text-sm text-error-400 bg-error-400/10 rounded-md border border-error-400/20\"\n      >\n        {{ exportError }}\n      </div>\n    </div>\n\n    <template #footer>\n      <div class=\"flex flex-col gap-3 w-full\">\n        <div v-if=\"isExporting\" class=\"flex flex-col gap-2\">\n          <div class=\"flex justify-between text-xs text-ui-text-muted\">\n            <span class=\"font-medium\">{{ getPhaseLabel() }}</span>\n            <span class=\"font-mono\">{{ Math.round(exportProgress * 100) }}%</span>\n          </div>\n          <UProgress :value=\"exportProgress * 100\" />\n          <p class=\"text-xs text-ui-text-muted text-center mt-1\">\n            {{\n              t(\n                'videoEditor.export.doNotClose',\n                'Please do not close this window or navigate away during export.',\n              )\n            }}\n          </p>\n        </div>\n        <div class=\"flex justify-end gap-2\" :class=\"{ 'mt-2': isExporting }\">\n          <UButton\n            color=\"neutral\"\n            variant=\"ghost\"\n            :label=\"t('common.cancel', 'Cancel')\"\n            :loading=\"cancelRequested\"\n            :disabled=\"cancelRequested\"\n            @click=\"isExporting ? cancelExport() : (isOpen = false)\"\n          />\n          <UButton\n            color=\"primary\"\n            variant=\"solid\"\n            :label=\"\n              isExporting\n                ? t('videoEditor.export.exporting', 'Exporting...')\n                : t('videoEditor.export.startExport', 'Export')\n            \"\n            :loading=\"isExporting\"\n            :disabled=\"isExporting || !!filenameError || !outputFilename.trim()\"\n            @click=\"handleConfirm\"\n          />\n        </div>\n      </div>\n    </template>\n  </AppModal>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/common/CreateFolderModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/common/EffectsEditor.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/common/FileInfoModal.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":14,"messageId":"unexpectedAny","endLine":13,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[319,322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[319,322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":26,"column":12,"messageId":"unusedVar","endLine":26,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'formatBytes' is defined but never used. Allowed unused vars must match /^_/u.","line":31,"column":10,"messageId":"unusedVar","endLine":31,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport yaml from 'js-yaml';\nimport AppModal from '~/components/ui/AppModal.vue';\n\nconst isOpen = defineModel<boolean>('open', { required: true });\n\nexport interface FileInfo {\n  name: string;\n  kind: 'file' | 'directory';\n  size?: number;\n  lastModified?: number;\n  path?: string;\n  metadata?: any;\n}\n\nconst props = defineProps<{\n  info: FileInfo | null;\n}>();\n\nconst { t } = useI18n();\n\nconst metadataYaml = computed(() => {\n  if (!props.info?.metadata) return null;\n  try {\n    return yaml.dump(props.info.metadata, { indent: 2 });\n  } catch (e) {\n    return String(props.info.metadata);\n  }\n});\n\nfunction formatBytes(bytes: number, decimals = 2) {\n  if (!+bytes) return '0 Bytes';\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\n\nfunction formatMegabytes(bytes: number, decimals = 2): string {\n  if (!Number.isFinite(bytes) || bytes <= 0) return '0 MB';\n  const mb = bytes / (1024 * 1024);\n  return `${mb.toFixed(decimals)} MB`;\n}\n</script>\n\n<template>\n  <AppModal\n    v-model:open=\"isOpen\"\n    :title=\"t('videoEditor.fileManager.info.title', 'File Information')\"\n    :ui=\"{ content: 'sm:max-w-md' }\"\n  >\n    <div v-if=\"info\" class=\"space-y-4\">\n      <div class=\"flex flex-col gap-2\">\n        <div class=\"flex flex-col gap-1 border-b border-ui-border pb-2\">\n          <span class=\"text-sm text-ui-text-muted\">{{ t('common.name', 'Name') }}</span>\n          <span class=\"font-medium text-ui-text break-all\">{{ info.name }}</span>\n        </div>\n        <div class=\"flex flex-col gap-1 border-b border-ui-border pb-2\">\n          <span class=\"text-sm text-ui-text-muted\">{{ t('common.type', 'Type') }}</span>\n          <span class=\"font-medium text-ui-text\">\n            {{\n              info.kind === 'directory' ? t('common.folder', 'Folder') : t('common.file', 'File')\n            }}\n          </span>\n        </div>\n        <div\n          v-if=\"info.size !== undefined\"\n          class=\"flex flex-col gap-1 border-b border-ui-border pb-2\"\n        >\n          <span class=\"text-sm text-ui-text-muted\">{{ t('common.size', 'Size') }}</span>\n          <span class=\"font-medium text-ui-text\">{{ formatMegabytes(info.size) }}</span>\n        </div>\n        <div v-if=\"info.lastModified\" class=\"flex flex-col gap-1 pb-2\">\n          <span class=\"text-sm text-ui-text-muted\">{{ t('common.modified', 'Modified') }}</span>\n          <span class=\"font-medium text-ui-text\">{{\n            new Date(info.lastModified).toLocaleString()\n          }}</span>\n        </div>\n        <div v-if=\"metadataYaml\" class=\"flex flex-col gap-1 border-t border-ui-border pt-2 pb-2\">\n          <span class=\"text-sm text-ui-text-muted\">{{\n            t('videoEditor.fileManager.info.metadata', 'Metadata')\n          }}</span>\n          <pre\n            class=\"bg-ui-bg p-2 rounded text-[10px] font-mono overflow-auto max-h-64 whitespace-pre text-ui-text-muted\"\n            >{{ metadataYaml }}</pre\n          >\n        </div>\n      </div>\n    </div>\n\n    <template #footer>\n      <UButton color=\"neutral\" variant=\"ghost\" @click=\"isOpen = false\">\n        {{ t('common.close', 'Close') }}\n      </UButton>\n    </template>\n  </AppModal>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/common/RenameModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/common/SelectEffectModal.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/file-manager/FileManagerEffects.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/file-manager/FileManagerFiles.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'watch' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":38,"messageId":"unusedVar","endLine":2,"endColumn":43,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"watch"},"fix":{"range":[60,67],"text":""},"desc":"Remove unused variable \"watch\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":58,"messageId":"unexpectedAny","endLine":42,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1692,1695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1692,1695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":251,"column":15,"messageId":"unexpectedAny","endLine":251,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7268,7271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7268,7271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, computed, onUnmounted, watch } from 'vue';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useUiStore } from '~/stores/ui.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useSelectionStore } from '~/stores/selection.store';\nimport { useProxyStore } from '~/stores/proxy.store';\nimport { useTimelineMediaUsageStore } from '~/stores/timeline-media-usage.store';\nimport FileManagerTree from './FileManagerTree.vue';\nimport type { FsEntry } from '~/types/fs';\nimport { FILE_MANAGER_MOVE_DRAG_TYPE } from '~/composables/useDraggedFile';\n\nconst { t } = useI18n();\nconst projectStore = useProjectStore();\nconst timelineStore = useTimelineStore();\nconst uiStore = useUiStore();\nconst focusStore = useFocusStore();\nconst selectionStore = useSelectionStore();\nconst proxyStore = useProxyStore();\nconst timelineMediaUsageStore = useTimelineMediaUsageStore();\n\nconst scrollEl = ref<HTMLElement | null>(null);\nconst lastDragEvent = ref<DragEvent | null>(null);\nlet autoScrollRaf: number | null = null;\nlet isWheelListenerAttached = false;\n\nfunction isRelevantDrag(e: DragEvent): boolean {\n  const types = e.dataTransfer?.types;\n  if (!types) return false;\n  return types.includes(FILE_MANAGER_MOVE_DRAG_TYPE) || types.includes('Files');\n}\n\nfunction stopAutoScroll() {\n  lastDragEvent.value = null;\n  if (autoScrollRaf !== null && typeof window !== 'undefined') {\n    window.cancelAnimationFrame(autoScrollRaf);\n    autoScrollRaf = null;\n  }\n\n  if (isWheelListenerAttached && typeof window !== 'undefined') {\n    window.removeEventListener('wheel', onWindowWheel as any);\n    isWheelListenerAttached = false;\n  }\n}\n\nonUnmounted(() => {\n  stopAutoScroll();\n});\n\nfunction onWindowWheel(e: WheelEvent) {\n  const el = scrollEl.value;\n  if (!el) return;\n\n  if (!lastDragEvent.value) return;\n  if (!Number.isFinite(e.deltaY) || e.deltaY === 0) return;\n\n  e.preventDefault();\n  el.scrollTop += e.deltaY;\n}\n\nfunction scheduleAutoScroll() {\n  if (autoScrollRaf !== null) return;\n  if (typeof window === 'undefined') return;\n\n  const tick = () => {\n    autoScrollRaf = null;\n    const el = scrollEl.value;\n    const ev = lastDragEvent.value;\n    if (!el || !ev) return;\n\n    const rect = el.getBoundingClientRect();\n    const zone = 48;\n    const maxSpeed = 16;\n\n    const topDist = ev.clientY - rect.top;\n    const bottomDist = rect.bottom - ev.clientY;\n\n    let dy = 0;\n    if (topDist >= 0 && topDist < zone) {\n      dy = -Math.ceil(((zone - topDist) / zone) * maxSpeed);\n    } else if (bottomDist >= 0 && bottomDist < zone) {\n      dy = Math.ceil(((zone - bottomDist) / zone) * maxSpeed);\n    }\n\n    if (dy !== 0) {\n      el.scrollTop += dy;\n      scheduleAutoScroll();\n    }\n  };\n\n  autoScrollRaf = window.requestAnimationFrame(tick);\n}\n\nfunction onContainerDragOver(e: DragEvent) {\n  if (!isRelevantDrag(e)) return;\n  lastDragEvent.value = e;\n  scheduleAutoScroll();\n\n  if (!isWheelListenerAttached && typeof window !== 'undefined') {\n    window.addEventListener('wheel', onWindowWheel, { passive: false });\n    isWheelListenerAttached = true;\n  }\n}\n\nfunction onContainerDrop() {\n  stopAutoScroll();\n}\n\nfunction onContainerDragLeave(e: DragEvent) {\n  const currentTarget = e.currentTarget as HTMLElement | null;\n  const relatedTarget = e.relatedTarget as Node | null;\n  if (!currentTarget?.contains(relatedTarget)) {\n    stopAutoScroll();\n  }\n}\n\nconst props = defineProps<{\n  isDragging: boolean;\n  isLoading: boolean;\n  isApiSupported: boolean;\n  rootEntries: FsEntry[];\n  getFileIcon: (entry: FsEntry) => string;\n  findEntryByPath: (path: string) => FsEntry | null;\n  moveEntry: (params: {\n    source: FsEntry;\n    targetDirHandle: FileSystemDirectoryHandle;\n    targetDirPath: string;\n  }) => Promise<void>;\n  getProjectRootDirHandle: () => Promise<FileSystemDirectoryHandle | null>;\n  handleFiles: (\n    files: FileList | File[],\n    targetDirHandle?: FileSystemDirectoryHandle,\n    targetDirPath?: string,\n  ) => Promise<void>;\n}>();\n\nconst selectedPath = computed(() => uiStore.selectedFsEntry?.path ?? null);\n\nconst mediaUsageMap = computed(() => timelineMediaUsageStore.mediaPathToTimelines);\n\nfunction getEntryMeta(entry: FsEntry): {\n  hasProxy: boolean;\n  generatingProxy: boolean;\n  proxyProgress?: number;\n  isUsedInTimeline?: boolean;\n} {\n  if (entry.kind !== 'file' || !entry.path) {\n    return { hasProxy: false, generatingProxy: false };\n  }\n\n  const hasProxy = proxyStore.existingProxies.has(entry.path);\n  const generatingProxy = proxyStore.generatingProxies.has(entry.path);\n  const proxyProgress = proxyStore.proxyProgress[entry.path];\n  const isUsedInTimeline = Boolean(mediaUsageMap.value[entry.path]?.length);\n  return { hasProxy, generatingProxy, proxyProgress, isUsedInTimeline };\n}\n\nasync function onRequestMove(params: {\n  sourcePath: string;\n  targetDirHandle: FileSystemDirectoryHandle;\n  targetDirPath: string;\n}) {\n  const source = props.findEntryByPath(params.sourcePath);\n  if (!source) return;\n  await props.moveEntry({\n    source,\n    targetDirHandle: params.targetDirHandle,\n    targetDirPath: params.targetDirPath,\n  });\n}\n\nasync function onRequestUpload(params: {\n  files: File[];\n  targetDirHandle: FileSystemDirectoryHandle;\n  targetDirPath: string;\n}) {\n  await props.handleFiles(params.files, params.targetDirHandle, params.targetDirPath);\n}\n\nconst emit = defineEmits<{\n  (e: 'toggle', entry: FsEntry): void;\n  (\n    e: 'action',\n    action:\n      | 'createFolder'\n      | 'rename'\n      | 'info'\n      | 'delete'\n      | 'createProxy'\n      | 'cancelProxy'\n      | 'deleteProxy'\n      | 'upload'\n      | 'createProxyForFolder',\n    entry: FsEntry,\n  ): void;\n  (e: 'createFolder', entry: FsEntry | null): void;\n}>();\n\nconst rootContextMenuItems = computed(() => {\n  if (!projectStore.currentProjectName) return [];\n  return [\n    [\n      {\n        label: t('videoEditor.fileManager.actions.createFolder', 'Create Folder'),\n        icon: 'i-heroicons-folder-plus',\n        onSelect: () => emit('createFolder', null),\n      },\n    ],\n  ];\n});\n\nconst isRootDropOver = ref(false);\n\nfunction onRootDragOver(e: DragEvent) {\n  if (!isRelevantDrag(e)) return;\n\n  e.stopPropagation();\n\n  isRootDropOver.value = true;\n  e.dataTransfer!.dropEffect = e.dataTransfer?.types.includes('Files') ? 'copy' : 'move';\n}\n\nfunction onRootDragLeave(e: DragEvent) {\n  const currentTarget = e.currentTarget as HTMLElement | null;\n  const relatedTarget = e.relatedTarget as Node | null;\n  if (!currentTarget?.contains(relatedTarget)) {\n    isRootDropOver.value = false;\n  }\n}\n\nasync function onRootDrop(e: DragEvent) {\n  e.stopPropagation();\n  isRootDropOver.value = false;\n\n  // Snapshot data synchronously - dataTransfer becomes empty after any await\n  const droppedFiles = e.dataTransfer?.files ? Array.from(e.dataTransfer.files) : [];\n  const hasFiles = e.dataTransfer?.types.includes('Files') ?? false;\n\n  const rootHandle = await props.getProjectRootDirHandle();\n  if (!rootHandle) return;\n\n  if (hasFiles && droppedFiles.length > 0) {\n    await props.handleFiles(droppedFiles, rootHandle, '');\n    return;\n  }\n\n  const moveRaw = e.dataTransfer?.getData(FILE_MANAGER_MOVE_DRAG_TYPE);\n  if (!moveRaw) return;\n\n  let parsed: any;\n  try {\n    parsed = JSON.parse(moveRaw);\n  } catch {\n    return;\n  }\n\n  const sourcePath = typeof parsed?.path === 'string' ? parsed.path : '';\n  if (!sourcePath) return;\n\n  const source = props.findEntryByPath(sourcePath);\n  if (!source) return;\n\n  await props.moveEntry({\n    source,\n    targetDirHandle: rootHandle,\n    targetDirPath: '',\n  });\n}\n\nasync function onEntrySelect(entry: FsEntry) {\n  uiStore.selectedFsEntry = {\n    kind: entry.kind,\n    name: entry.name,\n    path: entry.path,\n    handle: entry.handle,\n  };\n\n  selectionStore.selectFsEntry(entry);\n\n  if (entry.kind === 'file') {\n    focusStore.setTempFocus('left');\n  }\n\n  if (entry.kind !== 'file') return;\n  if (!entry.path?.toLowerCase().endsWith('.otio')) return;\n\n  await projectStore.openTimelineFile(entry.path);\n  await timelineStore.loadTimeline();\n  void timelineStore.loadTimelineMetadata();\n}\n</script>\n\n<template>\n  <div\n    ref=\"scrollEl\"\n    class=\"flex-1 overflow-auto min-h-0 min-w-0 relative\"\n    @dragover=\"onContainerDragOver\"\n    @dragleave=\"onContainerDragLeave\"\n    @drop.capture=\"onContainerDrop\"\n    @drop=\"onContainerDrop\"\n  >\n    <UContextMenu :items=\"rootContextMenuItems\">\n      <div\n        class=\"min-w-full w-max min-h-full flex flex-col\"\n        @pointerdown=\"\n          uiStore.selectedFsEntry = null;\n          selectionStore.clearSelection();\n        \"\n      >\n        <div\n          v-if=\"isLoading && rootEntries.length === 0\"\n          class=\"px-3 py-4 text-sm text-ui-text-muted\"\n        >\n          {{ t('common.loading', 'Loading...') }}\n        </div>\n\n        <!-- Empty state -->\n        <div\n          v-else-if=\"rootEntries.length === 0\"\n          class=\"flex flex-col items-center justify-center flex-1 w-full gap-3 text-ui-text-disabled px-4 text-center min-h-50\"\n        >\n          <UIcon name=\"i-heroicons-folder-open\" class=\"w-10 h-10\" />\n          <p class=\"text-sm\">\n            {{\n              isApiSupported\n                ? t('videoEditor.fileManager.empty', 'No files in this project')\n                : t(\n                    'videoEditor.fileManager.unsupported',\n                    'File System Access API is not supported in this browser',\n                  )\n            }}\n          </p>\n        </div>\n\n        <!-- File tree -->\n        <div v-else class=\"flex flex-col flex-1\">\n          <FileManagerTree\n            :entries=\"rootEntries\"\n            :depth=\"0\"\n            :get-file-icon=\"getFileIcon\"\n            :selected-path=\"selectedPath\"\n            :get-entry-meta=\"getEntryMeta\"\n            @toggle=\"emit('toggle', $event)\"\n            @select=\"onEntrySelect\"\n            @action=\"(action, entry) => emit('action', action, entry)\"\n            @request-move=\"onRequestMove\"\n            @request-upload=\"onRequestUpload\"\n          />\n          <div\n            v-if=\"isLoading\"\n            class=\"absolute inset-0 bg-ui-bg/30 flex items-center justify-center z-50\"\n          >\n            <UIcon name=\"i-heroicons-arrow-path\" class=\"w-6 h-6 animate-spin text-primary-500\" />\n          </div>\n        </div>\n\n        <div\n          class=\"flex-1 w-full min-w-full flex items-center justify-center min-h-12\"\n          :class=\"{\n            'bg-primary-500/10 outline outline-primary-500/40 -outline-offset-1': isRootDropOver,\n          }\"\n          @dragover.prevent=\"onRootDragOver\"\n          @dragleave.prevent=\"onRootDragLeave\"\n          @drop.prevent=\"onRootDrop\"\n        >\n          <p v-if=\"isRootDropOver\" class=\"text-xs font-medium text-primary-400 text-center\">\n            {{\n              t(\n                'videoEditor.fileManager.actions.dropToRootHint',\n                'Release to upload into the project root',\n              )\n            }}\n          </p>\n        </div>\n      </div>\n    </UContextMenu>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/file-manager/FileManagerHistory.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/file-manager/FileManagerTree.vue","messages":[{"ruleId":"@typescript-eslint/unified-signatures","severity":1,"message":"This overload and the one on line 28 can be combined into one signature taking `'toggle' | 'select'`.","line":29,"column":4,"messageId":"singleParameterDifference","endLine":29,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":17,"messageId":"unexpectedAny","endLine":173,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4613,4616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4613,4616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":68,"messageId":"unexpectedAny","endLine":247,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6779,6782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6779,6782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport {\n  useDraggedFile,\n  INTERNAL_DRAG_TYPE,\n  FILE_MANAGER_MOVE_DRAG_TYPE,\n} from '~/composables/useDraggedFile';\nimport type { DraggedFileData } from '~/composables/useDraggedFile';\nimport { VIDEO_DIR_NAME } from '~/utils/constants';\nimport type { FsEntry } from '~/types/fs';\n\ninterface Props {\n  entries: FsEntry[];\n  depth: number;\n  getFileIcon: (entry: FsEntry) => string;\n  selectedPath: string | null;\n  getEntryMeta: (entry: FsEntry) => {\n    hasProxy: boolean;\n    generatingProxy: boolean;\n    proxyProgress?: number;\n    isUsedInTimeline?: boolean;\n  };\n}\n\nconst props = defineProps<Props>();\n\nconst emit = defineEmits<{\n  (e: 'toggle', entry: FsEntry): void;\n  (e: 'select', entry: FsEntry): void;\n  (\n    e: 'action',\n    action:\n      | 'createFolder'\n      | 'rename'\n      | 'info'\n      | 'delete'\n      | 'createProxy'\n      | 'cancelProxy'\n      | 'deleteProxy'\n      | 'upload'\n      | 'createProxyForFolder',\n    entry: FsEntry,\n  ): void;\n  (\n    e: 'requestMove',\n    params: {\n      sourcePath: string;\n      targetDirHandle: FileSystemDirectoryHandle;\n      targetDirPath: string;\n    },\n  ): void;\n  (\n    e: 'requestUpload',\n    params: {\n      files: File[];\n      targetDirHandle: FileSystemDirectoryHandle;\n      targetDirPath: string;\n    },\n  ): void;\n}>();\n\nconst { t } = useI18n();\nconst { setDraggedFile, clearDraggedFile } = useDraggedFile();\n\nconst isDragOver = ref<string | null>(null);\n\nfunction isDotEntry(entry: FsEntry): boolean {\n  return entry.name.startsWith('.');\n}\n\nfunction isSelected(entry: FsEntry): boolean {\n  if (!props.selectedPath) return false;\n  if (!entry.path) return false;\n  return props.selectedPath === entry.path;\n}\n\nfunction getEntryIconClass(entry: FsEntry): string {\n  if (isDotEntry(entry)) return 'opacity-30';\n  if (entry.kind === 'directory') return 'text-ui-text-muted/80';\n\n  const ext = entry.name.split('.').pop()?.toLowerCase() ?? '';\n  if (['mp4', 'mov', 'avi', 'mkv', 'webm'].includes(ext)) return 'text-violet-400/90';\n  if (['mp3', 'wav', 'aac', 'flac', 'ogg'].includes(ext)) return 'text-emerald-400/90';\n  if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'avif'].includes(ext)) return 'text-sky-400/90';\n  if (['otio', 'txt', 'md', 'json', 'yaml', 'yml'].includes(ext)) return 'text-amber-400/90';\n  return 'text-ui-text-muted';\n}\n\nfunction isVideo(entry: FsEntry) {\n  return entry.kind === 'file' && entry.path?.startsWith(`${VIDEO_DIR_NAME}/`);\n}\n\nfunction onEntryClick(entry: FsEntry) {\n  emit('select', entry);\n}\n\nfunction onCaretClick(e: MouseEvent, entry: FsEntry) {\n  e.stopPropagation();\n  if (entry.kind !== 'directory') return;\n  emit('toggle', entry);\n}\n\nfunction onDragStart(e: DragEvent, entry: FsEntry) {\n  if (!entry.path) return;\n\n  const movePayload = {\n    name: entry.name,\n    kind: entry.kind,\n    path: entry.path,\n  };\n  e.dataTransfer?.setData(FILE_MANAGER_MOVE_DRAG_TYPE, JSON.stringify(movePayload));\n\n  // Mark this as an internal drag so the global drop overlay is not shown\n  e.dataTransfer?.setData(INTERNAL_DRAG_TYPE, '1');\n\n  if (entry.kind !== 'file') return;\n\n  const isTimeline = entry.name.toLowerCase().endsWith('.otio');\n  const kind: DraggedFileData['kind'] = isTimeline ? 'timeline' : 'file';\n  const data = {\n    name: entry.name,\n    kind,\n    path: entry.path,\n    handle: entry.handle as FileSystemFileHandle,\n  };\n  setDraggedFile(data);\n  e.dataTransfer?.setData('application/json', JSON.stringify(data));\n}\n\nfunction onDragEnd() {\n  clearDraggedFile();\n}\n\nfunction onDragOverDir(e: DragEvent, entry: FsEntry) {\n  if (entry.kind !== 'directory') return;\n\n  const types = e.dataTransfer?.types;\n  if (!types) return;\n\n  if (types.includes(FILE_MANAGER_MOVE_DRAG_TYPE)) {\n    isDragOver.value = entry.path || null;\n    e.dataTransfer.dropEffect = 'move';\n    return;\n  }\n\n  // External files import\n  if (types.includes('Files')) {\n    isDragOver.value = entry.path || null;\n    e.dataTransfer.dropEffect = 'copy';\n  }\n}\n\nfunction onDragLeaveDir(e: DragEvent, entry: FsEntry) {\n  if (entry.kind !== 'directory') return;\n  if (isDragOver.value !== entry.path) return;\n\n  const currentTarget = e.currentTarget as HTMLElement | null;\n  const relatedTarget = e.relatedTarget as Node | null;\n  if (!currentTarget?.contains(relatedTarget)) {\n    isDragOver.value = null;\n  }\n}\n\nasync function onDropDir(e: DragEvent, entry: FsEntry) {\n  if (entry.kind !== 'directory') return;\n\n  e.stopPropagation();\n\n  isDragOver.value = null;\n\n  const moveRaw = e.dataTransfer?.getData(FILE_MANAGER_MOVE_DRAG_TYPE);\n  if (moveRaw) {\n    let parsed: any;\n    try {\n      parsed = JSON.parse(moveRaw);\n    } catch {\n      return;\n    }\n\n    const sourcePath = typeof parsed?.path === 'string' ? parsed.path : '';\n    if (!sourcePath) return;\n\n    emit('requestMove', {\n      sourcePath,\n      targetDirHandle: entry.handle as FileSystemDirectoryHandle,\n      targetDirPath: entry.path ?? '',\n    });\n    return;\n  }\n\n  const droppedFiles = e.dataTransfer?.files ? Array.from(e.dataTransfer.files) : [];\n  const files =\n    droppedFiles.length > 0\n      ? droppedFiles\n      : Array.from(e.dataTransfer?.items ?? [])\n          .map((item) => item.getAsFile())\n          .filter((file): file is File => file instanceof File);\n\n  if (files.length === 0) return;\n\n  emit('requestUpload', {\n    files,\n    targetDirHandle: entry.handle as FileSystemDirectoryHandle,\n    targetDirPath: entry.path ?? '',\n  });\n}\n\nfunction folderHasVideos(entry: FsEntry): boolean {\n  if (entry.kind !== 'directory') return false;\n  if (!entry.children) return true; // Assume true if not loaded yet, or we can be conservative\n  return entry.children.some((child) => {\n    if (child.kind === 'file') {\n      const ext = child.name.split('.').pop()?.toLowerCase() ?? '';\n      return ['mp4', 'mov', 'avi', 'mkv', 'webm'].includes(ext);\n    }\n    return false;\n  });\n}\n\nfunction getContextMenuItems(entry: FsEntry) {\n  const items = [];\n\n  if (entry.kind === 'directory') {\n    const hasVideos = folderHasVideos(entry);\n\n    items.push([\n      {\n        label: t('videoEditor.fileManager.actions.createFolder', 'Create Folder'),\n        icon: 'i-heroicons-folder-plus',\n        onSelect: () => emit('action', 'createFolder', entry),\n      },\n      {\n        label: t('videoEditor.fileManager.actions.uploadFiles', 'Upload files'),\n        icon: 'i-heroicons-arrow-up-tray',\n        onSelect: () => emit('action', 'upload', entry),\n      },\n    ]);\n\n    if (hasVideos) {\n      items.push([\n        {\n          label: t(\n            'videoEditor.fileManager.actions.createProxyForAll',\n            'Create proxy for all videos',\n          ),\n          icon: 'i-heroicons-film',\n          onSelect: () => emit('action', 'createProxyForFolder' as any, entry),\n        },\n      ]);\n    }\n  }\n\n  items.push([\n    {\n      label: t('common.rename', 'Rename'),\n      icon: 'i-heroicons-pencil',\n      onSelect: () => emit('action', 'rename', entry),\n    },\n    {\n      label: t('videoEditor.fileManager.info.title', 'Information'),\n      icon: 'i-heroicons-information-circle',\n      onSelect: () => emit('action', 'info', entry),\n    },\n  ]);\n\n  if (isVideo(entry)) {\n    const meta = props.getEntryMeta(entry);\n    const hasProxy = meta.hasProxy;\n    const generatingProxy = meta.generatingProxy;\n\n    items.push([\n      {\n        label: generatingProxy\n          ? t('videoEditor.fileManager.actions.generatingProxy', 'Generating Proxy...')\n          : hasProxy\n            ? t('videoEditor.fileManager.actions.regenerateProxy', 'Regenerate Proxy')\n            : t('videoEditor.fileManager.actions.createProxy', 'Create Proxy'),\n        icon: generatingProxy ? 'i-heroicons-arrow-path' : 'i-heroicons-film',\n        disabled: generatingProxy,\n        onSelect: () => emit('action', 'createProxy', entry),\n      },\n    ]);\n\n    if (generatingProxy) {\n      items.push([\n        {\n          label: t(\n            'videoEditor.fileManager.actions.cancelProxyGeneration',\n            'Cancel proxy generation',\n          ),\n          icon: 'i-heroicons-x-circle',\n          color: 'error',\n          onSelect: () => emit('action', 'cancelProxy', entry),\n        },\n      ]);\n    }\n\n    if (hasProxy) {\n      items.push([\n        {\n          label: t('videoEditor.fileManager.actions.deleteProxy', 'Delete Proxy'),\n          icon: 'i-heroicons-trash',\n          color: 'error',\n          onSelect: () => emit('action', 'deleteProxy', entry),\n        },\n      ]);\n    }\n  }\n\n  items.push([\n    {\n      label: t('common.delete', 'Delete'),\n      icon: 'i-heroicons-trash',\n      color: 'error',\n      onSelect: () => emit('action', 'delete', entry),\n    },\n  ]);\n\n  return items;\n}\n</script>\n\n<template>\n  <ul class=\"select-none min-w-full w-max\">\n    <li v-for=\"entry in entries\" :key=\"entry.name\">\n      <!-- Row -->\n      <UContextMenu :items=\"getContextMenuItems(entry)\">\n        <div\n          class=\"flex items-center gap-1.5 py-1 pr-2 rounded cursor-pointer hover:bg-ui-bg-hover transition-colors group min-w-fit\"\n          :style=\"{ paddingLeft: `${8 + depth * 14}px` }\"\n          :class=\"[\n            isDragOver === entry.path\n              ? 'bg-primary-500/20 outline outline-primary-500 -outline-offset-1'\n              : '',\n            isSelected(entry)\n              ? 'bg-ui-bg-elevated outline-1 outline-(--selection-ring) -outline-offset-1'\n              : '',\n          ]\"\n          :draggable=\"true\"\n          :aria-selected=\"isSelected(entry)\"\n          :aria-expanded=\"entry.kind === 'directory' ? entry.expanded : undefined\"\n          :aria-level=\"depth + 1\"\n          role=\"treeitem\"\n          tabindex=\"0\"\n          @keydown.enter=\"onEntryClick(entry)\"\n          @keydown.space.prevent=\"onEntryClick(entry)\"\n          @dragstart=\"onDragStart($event, entry)\"\n          @dragend=\"onDragEnd()\"\n          @dragover.prevent=\"onDragOverDir($event, entry)\"\n          @dragleave.prevent=\"onDragLeaveDir($event, entry)\"\n          @drop.prevent=\"onDropDir($event, entry)\"\n          @click=\"onEntryClick(entry)\"\n        >\n          <!-- Chevron for directories -->\n          <UIcon\n            v-if=\"entry.kind === 'directory'\"\n            name=\"i-heroicons-chevron-right\"\n            class=\"w-3.5 h-3.5 text-ui-text-muted shrink-0 transition-transform duration-150\"\n            :class=\"{ 'rotate-90': entry.expanded }\"\n            :aria-hidden=\"true\"\n            @click=\"onCaretClick($event, entry)\"\n          />\n          <span v-else class=\"w-3.5 shrink-0\" />\n\n          <!-- File / folder icon -->\n          <div class=\"w-4 shrink-0 flex items-center justify-center\">\n            <div\n              class=\"h-4 flex items-center justify-center\"\n              :class=\"[\n                props.getEntryMeta(entry).isUsedInTimeline ? 'border-b-2 border-red-500' : '',\n              ]\"\n            >\n              <UIcon\n                :name=\"getFileIcon(entry)\"\n                class=\"w-4 h-4 shrink-0 transition-colors\"\n                :class=\"[\n                  getEntryIconClass(entry),\n                  props.getEntryMeta(entry).hasProxy ? 'text-(--color-success)!' : '',\n                ]\"\n              />\n            </div>\n          </div>\n\n          <!-- Name -->\n          <span\n            class=\"text-sm truncate transition-colors\"\n            :class=\"[\n              isSelected(entry)\n                ? 'font-medium text-ui-text group-hover:text-ui-text'\n                : 'text-ui-text group-hover:text-ui-text',\n              isDotEntry(entry) ? 'opacity-30' : '',\n              props.getEntryMeta(entry).hasProxy ? 'text-(--color-success)!' : '',\n            ]\"\n          >\n            {{ entry.name }}\n          </span>\n\n          <!-- Proxy indicators -->\n          <template v-if=\"isVideo(entry)\">\n            <div\n              v-if=\"props.getEntryMeta(entry).generatingProxy\"\n              class=\"flex items-center gap-1 ml-2\"\n            >\n              <UIcon\n                name=\"i-heroicons-arrow-path\"\n                class=\"w-3.5 h-3.5 text-primary-400 animate-spin\"\n              />\n              <span\n                v-if=\"props.getEntryMeta(entry).proxyProgress !== undefined\"\n                class=\"text-xs text-primary-400 font-mono\"\n              >\n                {{ props.getEntryMeta(entry).proxyProgress }}%\n              </span>\n            </div>\n          </template>\n        </div>\n      </UContextMenu>\n\n      <!-- Children -->\n      <div v-if=\"entry.kind === 'directory' && entry.expanded && entry.children\">\n        <FileManagerTree\n          :entries=\"entry.children\"\n          :depth=\"depth + 1\"\n          :get-file-icon=\"getFileIcon\"\n          :selected-path=\"selectedPath\"\n          :get-entry-meta=\"getEntryMeta\"\n          @toggle=\"emit('toggle', $event)\"\n          @select=\"emit('select', $event)\"\n          @action=\"(action, childEntry) => emit('action', action, childEntry)\"\n          @request-move=\"emit('requestMove', $event)\"\n          @request-upload=\"emit('requestUpload', $event)\"\n        />\n      </div>\n    </li>\n  </ul>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/media/MediaEncodingSettings.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/media/MediaResolutionSettings.vue","messages":[{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'audioChannels' requires default value to be set.","line":13,"column":5,"messageId":"missingDefault","endLine":13,"endColumn":39},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'sampleRate' requires default value to be set.","line":14,"column":5,"messageId":"missingDefault","endLine":14,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, watch } from 'vue';\n\nconst props = withDefaults(\n  defineProps<{\n    width: number;\n    height: number;\n    fps: number;\n    resolutionFormat: string;\n    orientation: 'landscape' | 'portrait';\n    aspectRatio: string;\n    isCustomResolution: boolean;\n    audioChannels?: 'stereo' | 'mono';\n    sampleRate?: number;\n    disabled?: boolean;\n  }>(),\n  {\n    disabled: false,\n  },\n);\n\nconst emit = defineEmits<{\n  'update:width': [value: number];\n  'update:height': [value: number];\n  'update:fps': [value: number];\n  'update:resolutionFormat': [value: string];\n  'update:orientation': [value: 'landscape' | 'portrait'];\n  'update:aspectRatio': [value: string];\n  'update:isCustomResolution': [value: boolean];\n  'update:audioChannels': [value: 'stereo' | 'mono'];\n  'update:sampleRate': [value: number];\n}>();\n\nconst { t } = useI18n();\n\nconst formatOptions = [\n  { value: '720p', label: t('videoEditor.resolution.preset.720p', '720p (HD)') },\n  { value: '1080p', label: t('videoEditor.resolution.preset.1080p', '1080p (FHD)') },\n  { value: '2.7k', label: t('videoEditor.resolution.preset.2.7k', '2.7K (QHD)') },\n  { value: '4k', label: t('videoEditor.resolution.preset.4k', '4K (UHD)') },\n];\n\nconst audioChannelsOptions = [\n  { value: 'stereo', label: t('videoEditor.audio.stereo', 'stereo') },\n  { value: 'mono', label: t('videoEditor.audio.mono', 'mono') },\n];\n\nconst sampleRateOptions = [\n  { value: 44100, label: '44.1 kHz' },\n  { value: 48000, label: '48 kHz' },\n];\n\nconst orientationOptions = [\n  {\n    value: 'landscape',\n    icon: 'i-heroicons-computer-desktop',\n    title: t('videoEditor.resolution.landscape', 'Landscape'),\n  },\n  {\n    value: 'portrait',\n    icon: 'i-heroicons-device-phone-mobile',\n    title: t('videoEditor.resolution.portrait', 'Portrait'),\n  },\n];\n\nconst aspectRatioOptions = [\n  { value: '16:9', label: t('videoEditor.resolution.aspect.16_9', '16:9') },\n  { value: '4:3', label: t('videoEditor.resolution.aspect.4_3', '4:3') },\n  { value: '1:1', label: t('videoEditor.resolution.aspect.1_1', '1:1') },\n  { value: '21:9', label: t('videoEditor.resolution.aspect.21_9', '21:9') },\n];\n\nconst bases: Record<string, number> = {\n  '720p': 720,\n  '1080p': 1080,\n  '2.7k': 1440,\n  '4k': 2160,\n};\n\nconst ratios: Record<string, number> = {\n  '16:9': 16 / 9,\n  '4:3': 4 / 3,\n  '1:1': 1,\n  '21:9': 21 / 9,\n};\n\nconst localFormat = computed({\n  get: () => props.resolutionFormat,\n  set: (val) => emit('update:resolutionFormat', val),\n});\n\nconst localOrientation = computed({\n  get: () => props.orientation,\n  set: (val) => emit('update:orientation', val),\n});\n\nconst localAspectRatio = computed({\n  get: () => props.aspectRatio,\n  set: (val) => emit('update:aspectRatio', val),\n});\n\nconst localIsCustom = computed({\n  get: () => props.isCustomResolution,\n  set: (val) => emit('update:isCustomResolution', val),\n});\n\nconst localWidth = computed({\n  get: () => props.width,\n  set: (val) => emit('update:width', val),\n});\n\nconst localHeight = computed({\n  get: () => props.height,\n  set: (val) => emit('update:height', val),\n});\n\nconst localFps = computed({\n  get: () => props.fps,\n  set: (val) => emit('update:fps', val),\n});\n\nconst localAudioChannels = computed({\n  get: () => props.audioChannels ?? 'stereo',\n  set: (val) => emit('update:audioChannels', val),\n});\n\nconst localSampleRate = computed({\n  get: () => props.sampleRate ?? 48000,\n  set: (val) => emit('update:sampleRate', val),\n});\n\nfunction calculateDimensions(format: string, orientation: string, ratioStr: string) {\n  const base = bases[format] || 1080;\n  const ratio = ratios[ratioStr] || 16 / 9;\n\n  let w = 0;\n  let h = 0;\n\n  if (orientation === 'landscape') {\n    h = base;\n    w = Math.round(base * ratio);\n  } else {\n    w = base;\n    h = Math.round(base * ratio);\n  }\n\n  // Ensure even dimensions\n  w = Math.round(w / 2) * 2;\n  h = Math.round(h / 2) * 2;\n\n  return { w, h };\n}\n\n// Auto-calculate width/height when using preset formats\nwatch(\n  [localFormat, localOrientation, localAspectRatio, localIsCustom],\n  ([format, orientation, ratioStr, isCustom]) => {\n    if (!isCustom) {\n      const { w, h } = calculateDimensions(format, orientation, ratioStr);\n      if (props.width !== w) emit('update:width', w);\n      if (props.height !== h) emit('update:height', h);\n    }\n  },\n  { immediate: true },\n);\n\n// Auto-detect orientation and ratio when custom resolution is modified\nwatch([localWidth, localHeight, localIsCustom], ([w, h, isCustom]) => {\n  if (isCustom) {\n    const isPortrait = h > w;\n    const newOrientation = isPortrait ? 'portrait' : 'landscape';\n    if (props.orientation !== newOrientation) {\n      emit('update:orientation', newOrientation);\n    }\n\n    // We could try to guess aspect ratio, but it's not strictly necessary for custom mode\n    // Just keep the current values, as they are ignored in calculation when isCustom = true\n  }\n});\n</script>\n\n<template>\n  <div class=\"flex flex-col gap-4\">\n    <div class=\"flex items-center justify-between\">\n      <label class=\"text-xs text-ui-text-muted font-medium\">\n        {{ t('videoEditor.resolution.customResolution', 'Custom Resolution') }}\n      </label>\n      <USwitch v-model=\"localIsCustom\" :disabled=\"disabled\" />\n    </div>\n\n    <!-- Preset Mode -->\n    <template v-if=\"!localIsCustom\">\n      <div class=\"grid grid-cols-3 gap-4\">\n        <div class=\"flex flex-col gap-2\">\n          <label class=\"text-xs text-ui-text-muted font-medium\">\n            {{ t('videoEditor.resolution.orientation', 'Orientation') }}\n          </label>\n          <UiAppButtonGroup\n            v-model=\"localOrientation\"\n            :options=\"orientationOptions as any\"\n            :disabled=\"disabled\"\n            :ui=\"{ base: 'px-2' }\"\n            class=\"w-full\"\n          />\n        </div>\n\n        <div class=\"flex flex-col gap-2\">\n          <label class=\"text-xs text-ui-text-muted font-medium\">\n            {{ t('videoEditor.resolution.aspectRatio', 'Aspect Ratio') }}\n          </label>\n          <USelect\n            v-model=\"localAspectRatio\"\n            :items=\"aspectRatioOptions\"\n            :disabled=\"disabled\"\n            size=\"sm\"\n            class=\"w-full\"\n            value-key=\"value\"\n            label-key=\"label\"\n          />\n        </div>\n\n        <div class=\"flex flex-col gap-2\">\n          <label class=\"text-xs text-ui-text-muted font-medium\">\n            {{ t('videoEditor.resolution.format', 'Format') }}\n          </label>\n          <USelect\n            v-model=\"localFormat\"\n            :items=\"formatOptions\"\n            :disabled=\"disabled\"\n            size=\"sm\"\n            class=\"w-full\"\n            value-key=\"value\"\n            label-key=\"label\"\n          />\n        </div>\n      </div>\n\n      <div\n        class=\"text-sm text-ui-text-muted font-medium bg-ui-bg-accent p-3 rounded flex justify-between items-center\"\n      >\n        <span>{{ t('videoEditor.resolution.finalResolution', 'Final Resolution:') }}</span>\n        <span class=\"font-mono text-ui-text\">{{ localWidth }} &times; {{ localHeight }}</span>\n      </div>\n    </template>\n\n    <!-- Custom Mode -->\n    <template v-else>\n      <div class=\"grid grid-cols-2 gap-4\">\n        <div class=\"flex flex-col gap-2\">\n          <label class=\"text-xs text-ui-text-muted font-medium\">\n            {{ t('videoEditor.export.width', 'Width') }}\n          </label>\n          <UInput\n            v-model.number=\"localWidth\"\n            type=\"number\"\n            inputmode=\"numeric\"\n            min=\"2\"\n            step=\"2\"\n            size=\"sm\"\n            class=\"w-full\"\n            :disabled=\"disabled\"\n          />\n        </div>\n        <div class=\"flex flex-col gap-2\">\n          <label class=\"text-xs text-ui-text-muted font-medium\">\n            {{ t('videoEditor.export.height', 'Height') }}\n          </label>\n          <UInput\n            v-model.number=\"localHeight\"\n            type=\"number\"\n            inputmode=\"numeric\"\n            min=\"2\"\n            step=\"2\"\n            size=\"sm\"\n            class=\"w-full\"\n            :disabled=\"disabled\"\n          />\n        </div>\n      </div>\n      <div class=\"text-xs text-ui-text-muted flex justify-end\">\n        {{\n          localOrientation === 'portrait'\n            ? t('videoEditor.resolution.portrait', 'Portrait')\n            : t('videoEditor.resolution.landscape', 'Landscape')\n        }}\n      </div>\n    </template>\n\n    <!-- FPS -->\n    <div class=\"flex flex-col gap-2\">\n      <label class=\"text-xs text-ui-text-muted font-medium\">\n        {{ t('videoEditor.export.fps', 'FPS') }}\n      </label>\n      <UInput\n        v-model.number=\"localFps\"\n        type=\"number\"\n        inputmode=\"numeric\"\n        min=\"1\"\n        max=\"240\"\n        step=\"1\"\n        size=\"sm\"\n        class=\"w-full\"\n        :disabled=\"disabled\"\n      />\n    </div>\n\n    <div class=\"h-px bg-ui-border my-2\"></div>\n\n    <div class=\"text-sm font-semibold text-ui-text uppercase tracking-wider\">\n      {{ t('videoEditor.audio.audioSettings', 'Audio settings') }}\n    </div>\n\n    <div class=\"grid grid-cols-2 gap-4\">\n      <div class=\"flex flex-col gap-2\">\n        <label class=\"text-xs text-ui-text-muted font-medium\">\n          {{ t('videoEditor.audio.channels', 'Channels') }}\n        </label>\n        <UiAppButtonGroup\n          v-model=\"localAudioChannels\"\n          :options=\"audioChannelsOptions as any\"\n          :disabled=\"disabled\"\n          class=\"w-full\"\n        />\n      </div>\n\n      <div class=\"flex flex-col gap-2\">\n        <label class=\"text-xs text-ui-text-muted font-medium\">\n          {{ t('videoEditor.audio.sampleRate', 'Sample Rate') }}\n        </label>\n        <USelect\n          v-model.number=\"localSampleRate\"\n          :items=\"sampleRateOptions\"\n          :disabled=\"disabled\"\n          size=\"sm\"\n          class=\"w-full\"\n          value-key=\"value\"\n          label-key=\"label\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsExportDefaults.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsGeneral.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsHotkeys.vue","messages":[{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":90,"column":37,"messageId":"dynamicDelete","endLine":90,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, onBeforeUnmount, ref } from 'vue';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport UiConfirmModal from '~/components/ui/UiConfirmModal.vue';\nimport { DEFAULT_HOTKEYS, type HotkeyCommandId } from '~/utils/hotkeys/defaultHotkeys';\nimport {\n  hotkeyFromKeyboardEvent,\n  isEditableTarget,\n  normalizeHotkeyCombo,\n} from '~/utils/hotkeys/hotkeyUtils';\nimport { getEffectiveHotkeyBindings } from '~/utils/hotkeys/effectiveHotkeys';\n\nconst { t } = useI18n();\nconst workspaceStore = useWorkspaceStore();\n\nconst isCapturingHotkey = ref(false);\nconst captureTargetCommandId = ref<HotkeyCommandId | null>(null);\nconst capturedCombo = ref<string | null>(null);\nconst isDuplicateConfirmOpen = ref(false);\nconst duplicateWarningText = ref('');\nconst duplicateOwnerCommandId = ref<HotkeyCommandId | null>(null);\n\nlet captureKeydownHandler: ((e: KeyboardEvent) => void) | null = null;\n\nconst isResetAllHotkeysConfirmOpen = ref(false);\nconst resetCommandConfirmTarget = ref<HotkeyCommandId | null>(null);\nconst isResetCommandConfirmOpen = ref(false);\n\nfunction getCommandTitle(cmdId: HotkeyCommandId): string {\n  return DEFAULT_HOTKEYS.commands.find((c) => c.id === cmdId)?.title ?? cmdId;\n}\n\nfunction getCommandGroupTitle(groupId: string): string {\n  if (groupId === 'general') return t('videoEditor.settings.hotkeysGroupGeneral', 'General');\n  if (groupId === 'playback') return t('videoEditor.settings.hotkeysGroupPlayback', 'Playback');\n  if (groupId === 'timeline') return t('videoEditor.settings.hotkeysGroupTimeline', 'Timeline');\n  return groupId;\n}\n\nfunction getCurrentBindings(cmdId: HotkeyCommandId): string[] {\n  const overrides = workspaceStore.userSettings.hotkeys.bindings[cmdId];\n  if (Array.isArray(overrides)) return overrides;\n  return DEFAULT_HOTKEYS.bindings[cmdId] ?? [];\n}\n\nfunction isCommandCustom(cmdId: HotkeyCommandId): boolean {\n  return Array.isArray(workspaceStore.userSettings.hotkeys.bindings[cmdId]);\n}\n\nfunction setBindings(cmdId: HotkeyCommandId, next: string[]) {\n  void workspaceStore.batchUpdateUserSettings(\n    (draft) => {\n      draft.hotkeys.bindings[cmdId] = [...next];\n    },\n    { immediate: true },\n  );\n}\n\nfunction removeBinding(cmdId: HotkeyCommandId, combo: string) {\n  const next = getCurrentBindings(cmdId).filter((c) => c !== combo);\n  setBindings(cmdId, next);\n}\n\nfunction resetCommandBindings(cmdId: HotkeyCommandId) {\n  resetCommandConfirmTarget.value = cmdId;\n  isResetCommandConfirmOpen.value = true;\n}\n\nfunction resetAllHotkeys() {\n  isResetAllHotkeysConfirmOpen.value = true;\n}\n\nfunction confirmResetAllHotkeys() {\n  isResetAllHotkeysConfirmOpen.value = false;\n  void workspaceStore.batchUpdateUserSettings(\n    (draft) => {\n      draft.hotkeys.bindings = {};\n    },\n    { immediate: true },\n  );\n}\n\nfunction confirmResetCommandHotkeys() {\n  const cmdId = resetCommandConfirmTarget.value;\n  isResetCommandConfirmOpen.value = false;\n  resetCommandConfirmTarget.value = null;\n  if (!cmdId) return;\n  void workspaceStore.batchUpdateUserSettings(\n    (draft) => {\n      delete draft.hotkeys.bindings[cmdId];\n    },\n    { immediate: true },\n  );\n}\n\nfunction findDuplicateOwner(combo: string, targetCmdId: HotkeyCommandId): HotkeyCommandId | null {\n  const effective = getEffectiveHotkeyBindings(workspaceStore.userSettings.hotkeys);\n  for (const cmd of DEFAULT_HOTKEYS.commands) {\n    if (cmd.id === targetCmdId) continue;\n    const bindings = effective[cmd.id];\n    if (bindings.includes(combo)) return cmd.id;\n  }\n  return null;\n}\n\nfunction finishCapture() {\n  if (captureKeydownHandler) {\n    window.removeEventListener('keydown', captureKeydownHandler, true);\n    captureKeydownHandler = null;\n  }\n  isCapturingHotkey.value = false;\n  captureTargetCommandId.value = null;\n  capturedCombo.value = null;\n  duplicateOwnerCommandId.value = null;\n}\n\nfunction startCapture(cmdId: HotkeyCommandId) {\n  if (isCapturingHotkey.value) return;\n  isCapturingHotkey.value = true;\n  captureTargetCommandId.value = cmdId;\n  capturedCombo.value = null;\n\n  const handler = (e: KeyboardEvent) => {\n    if (!isCapturingHotkey.value) {\n      window.removeEventListener('keydown', handler, true);\n      if (captureKeydownHandler === handler) captureKeydownHandler = null;\n      return;\n    }\n\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      window.removeEventListener('keydown', handler, true);\n      if (captureKeydownHandler === handler) captureKeydownHandler = null;\n      finishCapture();\n      return;\n    }\n\n    if (isEditableTarget(e.target)) {\n      return;\n    }\n\n    const comboRaw = hotkeyFromKeyboardEvent(e);\n    const combo = comboRaw ? normalizeHotkeyCombo(comboRaw) : null;\n    if (!combo) return;\n\n    e.preventDefault();\n    window.removeEventListener('keydown', handler, true);\n    if (captureKeydownHandler === handler) captureKeydownHandler = null;\n    capturedCombo.value = combo;\n\n    const target = captureTargetCommandId.value;\n    if (!target) {\n      finishCapture();\n      return;\n    }\n\n    const owner = findDuplicateOwner(combo, target);\n    if (owner) {\n      duplicateWarningText.value = `${combo} is already assigned to ${getCommandTitle(owner)}.`;\n      duplicateOwnerCommandId.value = owner;\n      isDuplicateConfirmOpen.value = true;\n      return;\n    }\n\n    const next = [...getCurrentBindings(target), combo];\n    setBindings(target, Array.from(new Set(next)));\n    finishCapture();\n  };\n\n  captureKeydownHandler = handler;\n  window.addEventListener('keydown', handler, true);\n}\n\nfunction confirmAddDuplicate() {\n  const target = captureTargetCommandId.value;\n  const combo = capturedCombo.value;\n  if (!target || !combo) {\n    isDuplicateConfirmOpen.value = false;\n    finishCapture();\n    return;\n  }\n\n  const next = [...getCurrentBindings(target), combo];\n  setBindings(target, Array.from(new Set(next)));\n  isDuplicateConfirmOpen.value = false;\n  finishCapture();\n}\n\nfunction confirmReplaceDuplicate() {\n  const target = captureTargetCommandId.value;\n  const combo = capturedCombo.value;\n  const owner = duplicateOwnerCommandId.value;\n  if (!target || !combo || !owner) {\n    isDuplicateConfirmOpen.value = false;\n    finishCapture();\n    return;\n  }\n\n  const ownerNext = getCurrentBindings(owner).filter((c) => c !== combo);\n  const targetNext = Array.from(new Set([...getCurrentBindings(target), combo]));\n\n  void workspaceStore.batchUpdateUserSettings(\n    (draft) => {\n      draft.hotkeys.bindings[owner] = ownerNext;\n      draft.hotkeys.bindings[target] = targetNext;\n    },\n    { immediate: true },\n  );\n\n  isDuplicateConfirmOpen.value = false;\n  finishCapture();\n}\n\nconst hotkeyGroups = computed(() => {\n  const groupIds = Array.from(new Set(DEFAULT_HOTKEYS.commands.map((c) => c.groupId)));\n  return groupIds.map((groupId) => ({\n    id: groupId,\n    title: getCommandGroupTitle(groupId),\n    commands: DEFAULT_HOTKEYS.commands.filter((c) => c.groupId === groupId),\n  }));\n});\n\nconst hotkeyConflicts = computed(() => {\n  const effective = getEffectiveHotkeyBindings(workspaceStore.userSettings.hotkeys);\n  const counts = new Map<string, number>();\n\n  for (const cmd of DEFAULT_HOTKEYS.commands) {\n    const list = effective[cmd.id] ?? [];\n    for (const combo of list) {\n      counts.set(combo, (counts.get(combo) ?? 0) + 1);\n    }\n  }\n\n  return counts;\n});\n\nfunction isConflicting(combo: string): boolean {\n  return (hotkeyConflicts.value.get(combo) ?? 0) > 1;\n}\n\nonBeforeUnmount(() => {\n  finishCapture();\n});\n\ndefineExpose({\n  finishCapture,\n  isDuplicateConfirmOpen,\n});\n</script>\n\n<template>\n  <div class=\"flex flex-col gap-6\">\n    <UiConfirmModal\n      v-model:open=\"isDuplicateConfirmOpen\"\n      :title=\"t('videoEditor.settings.hotkeysDuplicateTitle', 'Duplicate hotkey')\"\n      :description=\"duplicateWarningText\"\n      :confirm-text=\"t('videoEditor.settings.hotkeysDuplicateConfirm', 'Add anyway')\"\n      :secondary-text=\"t('videoEditor.settings.hotkeysDuplicateReplace', 'Replace')\"\n      secondary-color=\"warning\"\n      :cancel-text=\"t('common.cancel', 'Cancel')\"\n      color=\"warning\"\n      icon=\"i-heroicons-exclamation-triangle\"\n      @confirm=\"confirmAddDuplicate\"\n      @secondary=\"confirmReplaceDuplicate\"\n    />\n\n    <UiConfirmModal\n      v-model:open=\"isResetAllHotkeysConfirmOpen\"\n      :title=\"t('videoEditor.settings.hotkeysResetAllConfirmTitle', 'Reset all hotkeys?')\"\n      :description=\"\n        t(\n          'videoEditor.settings.hotkeysResetAllConfirmDesc',\n          'This will remove all custom hotkeys and restore defaults. This action cannot be undone.',\n        )\n      \"\n      :confirm-text=\"t('videoEditor.settings.hotkeysResetAllConfirmAction', 'Reset')\"\n      :cancel-text=\"t('common.cancel', 'Cancel')\"\n      color=\"warning\"\n      icon=\"i-heroicons-exclamation-triangle\"\n      @confirm=\"confirmResetAllHotkeys\"\n    />\n\n    <UiConfirmModal\n      v-model:open=\"isResetCommandConfirmOpen\"\n      :title=\"t('videoEditor.settings.hotkeysResetCommandConfirmTitle', 'Reset hotkey?')\"\n      :description=\"\n        resetCommandConfirmTarget\n          ? t('videoEditor.settings.hotkeysResetCommandConfirmDesc', {\n              cmd: getCommandTitle(resetCommandConfirmTarget as HotkeyCommandId),\n            })\n          : ''\n      \"\n      :confirm-text=\"t('videoEditor.settings.hotkeysResetCommandConfirmAction', 'Reset')\"\n      :cancel-text=\"t('common.cancel', 'Cancel')\"\n      color=\"warning\"\n      icon=\"i-heroicons-exclamation-triangle\"\n      @confirm=\"confirmResetCommandHotkeys\"\n      @update:open=\"\n        (v: boolean) => {\n          if (!v) resetCommandConfirmTarget = null;\n        }\n      \"\n    />\n\n    <div class=\"flex items-center justify-between gap-3 px-1\">\n      <div class=\"text-sm font-semibold text-ui-text\">\n        {{ t('videoEditor.settings.userHotkeys', 'Hotkeys') }}\n      </div>\n      <UButton\n        size=\"xs\"\n        color=\"neutral\"\n        variant=\"ghost\"\n        :disabled=\"isCapturingHotkey\"\n        @click=\"resetAllHotkeys\"\n      >\n        {{ t('videoEditor.settings.hotkeysResetAll', 'Reset all') }}\n      </UButton>\n      <div v-if=\"isCapturingHotkey\" class=\"text-xs text-primary-500 font-medium animate-pulse\">\n        {{\n          t(\n            'videoEditor.settings.hotkeysCaptureHint',\n            'Listening for key combination (Esc to cancel)',\n          )\n        }}\n      </div>\n    </div>\n\n    <div class=\"flex flex-col gap-8\">\n      <div v-for=\"group in hotkeyGroups\" :key=\"group.id\" class=\"flex flex-col gap-3\">\n        <div class=\"text-[10px] font-bold text-ui-text-muted uppercase tracking-widest px-1\">\n          {{ group.title }}\n        </div>\n\n        <div class=\"overflow-hidden rounded-lg border border-ui-border bg-ui-bg\">\n          <table class=\"w-full border-collapse\">\n            <tbody class=\"divide-y divide-ui-border\">\n              <tr\n                v-for=\"cmd in group.commands\"\n                :key=\"cmd.id\"\n                class=\"group hover:bg-ui-bg-accent/10 transition-colors\"\n              >\n                <td class=\"w-[25%] p-2 py-2.5 align-top border-r border-ui-border/50\">\n                  <div class=\"flex flex-wrap gap-1.5 items-center\">\n                    <div\n                      v-for=\"combo in getCurrentBindings(cmd.id)\"\n                      :key=\"combo\"\n                      class=\"inline-flex items-center gap-1.5 pl-2 pr-1 py-0.5 rounded border border-ui-border bg-ui-bg-accent/50 group-hover:bg-ui-bg-accent/80 transition-colors\"\n                      :class=\"{\n                        'border-warning-400 text-warning-700 bg-warning-50/80':\n                          isConflicting(combo),\n                      }\"\n                      :title=\"\n                        isConflicting(combo)\n                          ? t(\n                              'videoEditor.settings.hotkeysConflict',\n                              'Conflict: used by another command',\n                            )\n                          : undefined\n                      \"\n                    >\n                      <span\n                        class=\"text-[10px] font-mono font-medium text-ui-text-muted select-none\"\n                      >\n                        {{ combo }}\n                      </span>\n                      <UButton\n                        size=\"2xs\"\n                        color=\"neutral\"\n                        variant=\"link\"\n                        icon=\"i-heroicons-x-mark\"\n                        class=\"p-0! h-4 w-4 opacity-40 hover:opacity-100 transition-opacity\"\n                        :aria-label=\"t('common.remove', 'Remove')\"\n                        @click=\"removeBinding(cmd.id, combo)\"\n                      />\n                    </div>\n\n                    <UButton\n                      size=\"xs\"\n                      color=\"neutral\"\n                      variant=\"subtle\"\n                      icon=\"i-heroicons-plus\"\n                      class=\"h-6 w-6 rounded-full shrink-0 justify-center\"\n                      :disabled=\"isCapturingHotkey\"\n                      :loading=\"isCapturingHotkey && captureTargetCommandId === cmd.id\"\n                      @click=\"startCapture(cmd.id)\"\n                    />\n\n                    <UButton\n                      size=\"xs\"\n                      color=\"neutral\"\n                      variant=\"ghost\"\n                      icon=\"i-heroicons-arrow-path\"\n                      class=\"h-6 w-6 rounded-full shrink-0 justify-center\"\n                      :disabled=\"isCapturingHotkey\"\n                      :aria-label=\"t('videoEditor.settings.hotkeysResetCommand', 'Reset')\"\n                      @click=\"resetCommandBindings(cmd.id)\"\n                    />\n                  </div>\n                  <div\n                    v-if=\"isCapturingHotkey && captureTargetCommandId === cmd.id\"\n                    class=\"mt-1 text-[9px] text-primary-500 font-bold uppercase tracking-wider animate-pulse\"\n                  >\n                    {{ t('videoEditor.settings.hotkeysCapturing', 'Listening') }}\n                  </div>\n                </td>\n                <td class=\"p-3 py-2.5 align-middle\">\n                  <span class=\"text-sm text-ui-text font-medium leading-tight\">\n                    {{ cmd.title }}\n                  </span>\n                  <span\n                    class=\"ml-2 inline-flex items-center gap-1 text-[10px] px-2 py-0.5 rounded-full border\"\n                    :class=\"\n                      isCommandCustom(cmd.id)\n                        ? 'border-primary-300 text-primary-700 bg-primary-50'\n                        : 'border-ui-border text-ui-text-muted bg-ui-bg'\n                    \"\n                  >\n                    {{\n                      isCommandCustom(cmd.id)\n                        ? t('common.custom', 'Custom')\n                        : t('common.default', 'Default')\n                    }}\n                  </span>\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"text-[10px] text-ui-text-muted italic px-1\">\n      {{ t('videoEditor.settings.userSavedNote', 'Saved to .gran/user.settings.json') }}\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsMouse.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsOptimization.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsProjectDefaults.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/settings/SettingsStorage.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/ClipTransitionPanel.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineClipThumbnails.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineRuler.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'emit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":19,"column":7,"messageId":"unusedVar","endLine":19,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, onMounted, onUnmounted, watch, computed } from 'vue';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport {\n  pxToTimeUs,\n  timeUsToPx,\n  zoomToPxPerSecond,\n} from '~/composables/timeline/useTimelineInteraction';\nimport { useResizeObserver } from '@vueuse/core';\nimport AppModal from '~/components/ui/AppModal.vue';\n\nconst { t } = useI18n();\n\nconst props = defineProps<{\n  scrollEl: HTMLElement | null;\n}>();\n\nconst emit = defineEmits<{\n  (e: 'mousedown', event: MouseEvent): void;\n}>();\n\nconst canvasRef = ref<HTMLCanvasElement | null>(null);\nconst containerRef = ref<HTMLElement | null>(null);\n\nconst timelineStore = useTimelineStore();\nconst projectStore = useProjectStore();\n\nconst width = ref(0);\nconst height = ref(0);\nconst scrollLeft = ref(0);\n\nconst markers = computed(() => timelineStore.getMarkers());\n\nlet textColor = '#8a8a8a';\nlet tickColor = '#4a4a4a';\n\nonMounted(() => {\n  const styles = window.getComputedStyle(document.documentElement);\n  const tc = styles.getPropertyValue('--ui-text-muted').trim();\n  const bc = styles.getPropertyValue('--ui-border').trim();\n  if (tc) textColor = tc;\n  if (bc) tickColor = bc;\n});\n\nuseResizeObserver(containerRef, (entries) => {\n  const entry = entries[0];\n  if (entry) {\n    height.value = entry.contentRect.height;\n    if (!props.scrollEl) {\n      width.value = entry.contentRect.width;\n      draw();\n    }\n  }\n});\n\nfunction onScroll() {\n  if (props.scrollEl) {\n    scrollLeft.value = props.scrollEl.scrollLeft;\n    draw();\n  }\n}\n\nwatch(\n  () => props.scrollEl,\n  (el, oldEl) => {\n    if (oldEl) {\n      oldEl.removeEventListener('scroll', onScroll);\n    }\n    if (el) {\n      el.addEventListener('scroll', onScroll, { passive: true });\n      onScroll();\n    }\n  },\n  { immediate: true },\n);\n\nuseResizeObserver(\n  () => props.scrollEl,\n  (entries) => {\n    const entry = entries[0];\n    if (entry) {\n      width.value = entry.contentRect.width;\n      draw();\n    }\n  },\n);\n\nonUnmounted(() => {\n  if (props.scrollEl) {\n    props.scrollEl.removeEventListener('scroll', onScroll);\n  }\n});\n\nconst fps = computed(() => projectStore.projectSettings.project.fps || 30);\nconst zoom = computed(() => timelineStore.timelineZoom);\nconst currentTime = computed(() => timelineStore.currentTime);\n\nwatch([fps, zoom, width, height, scrollLeft, currentTime], () => {\n  requestAnimationFrame(draw);\n});\n\nwatch(markers, () => {\n  requestAnimationFrame(draw);\n});\n\nconst isMarkerEditOpen = ref(false);\nconst editingMarkerId = ref<string | null>(null);\nconst markerTextDraft = ref('');\n\nconst editingMarker = computed(() => {\n  const id = editingMarkerId.value;\n  if (!id) return null;\n  return markers.value.find((m) => m.id === id) ?? null;\n});\n\nfunction openEditMarker(markerId: string) {\n  const m = markers.value.find((x) => x.id === markerId) ?? null;\n  if (!m) return;\n  editingMarkerId.value = markerId;\n  markerTextDraft.value = m.text ?? '';\n  isMarkerEditOpen.value = true;\n}\n\nfunction saveMarkerText() {\n  const m = editingMarker.value;\n  if (!m) return;\n  timelineStore.updateMarker(m.id, { text: markerTextDraft.value });\n  isMarkerEditOpen.value = false;\n}\n\nfunction truncateForTooltip(text: string): string {\n  const t = String(text ?? '');\n  const singleLine = t.replace(/\\s+/g, ' ').trim();\n  if (!singleLine) return '';\n  const max = 160;\n  return singleLine.length > max ? `${singleLine.slice(0, max)}â¦` : singleLine;\n}\n\nconst markerPoints = computed(() => {\n  const currentZoom = zoom.value;\n  const startPx = scrollLeft.value;\n  const w = width.value;\n\n  return markers.value\n    .map((m) => {\n      const x = timeUsToPx(m.timeUs, currentZoom) - startPx;\n      return {\n        id: m.id,\n        x,\n        text: m.text ?? '',\n      };\n    })\n    .filter((p) => p.x >= -20 && p.x <= w + 20);\n});\n\nfunction formatTime(us: number, fpsValue: number): string {\n  const totalFrames = Math.round((us / 1_000_000) * fpsValue);\n  const ff = totalFrames % fpsValue;\n  const totalSeconds = Math.floor(us / 1_000_000);\n  const ss = totalSeconds % 60;\n  const mm = Math.floor(totalSeconds / 60) % 60;\n  const hh = Math.floor(totalSeconds / 3600);\n\n  const pad = (n: number) => String(n).padStart(2, '0');\n  return `${pad(hh)}:${pad(mm)}:${pad(ss)}:${pad(ff)}`;\n}\n\nfunction draw() {\n  const canvas = canvasRef.value;\n  if (!canvas) return;\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return;\n\n  const dpr = window.devicePixelRatio || 1;\n  const w = width.value;\n  const h = height.value;\n\n  if (w === 0 || h === 0) return;\n\n  canvas.width = w * dpr;\n  canvas.height = h * dpr;\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.scale(dpr, dpr);\n\n  ctx.clearRect(0, 0, w, h);\n\n  const currentZoom = zoom.value;\n  const currentFps = fps.value;\n  const pxPerSec = zoomToPxPerSecond(currentZoom);\n\n  // When zooming, we want the timeline ticks to stay anchored appropriately\n  // and maintain their spacing relative to the tracks\n  const startPx = scrollLeft.value;\n  const endPx = startPx + w;\n  const startUs = pxToTimeUs(startPx, currentZoom);\n  const endUs = pxToTimeUs(endPx, currentZoom);\n\n  // Determine intervals\n  const MIN_DIST_PX = 90;\n  const timeStepsS = [1, 2, 5, 10, 15, 30, 60, 120, 300, 600, 1800, 3600];\n  let mainStepS = timeStepsS[timeStepsS.length - 1]!;\n  for (const step of timeStepsS) {\n    if (step * pxPerSec >= MIN_DIST_PX) {\n      mainStepS = step;\n      break;\n    }\n  }\n\n  // Increase line visibility by adjusting stroke style\n  ctx.fillStyle = textColor;\n  ctx.strokeStyle = tickColor;\n  ctx.lineWidth = 1.5; // Thicker lines for visibility\n  ctx.font = '10px monospace';\n  ctx.textAlign = 'center';\n  ctx.textBaseline = 'top';\n\n  const startS = Math.floor(startUs / 1_000_000 / mainStepS) * mainStepS;\n  const endS = Math.ceil(endUs / 1_000_000);\n\n  ctx.beginPath();\n  for (let s = startS; s <= endS; s += mainStepS) {\n    // Exact position in pixels from timeline start, minus scroll offset\n    // This perfectly matches timeUsToPx which the tracks use\n    const x = Math.round(timeUsToPx(s * 1_000_000, currentZoom) - startPx) + 0.5;\n\n    if (x >= -50 && x <= w + 50) {\n      ctx.moveTo(x, h - 12); // Taller main ticks\n      ctx.lineTo(x, h);\n      ctx.fillText(formatTime(s * 1_000_000, currentFps), x, 4);\n    }\n\n    // Draw sub ticks\n    if (mainStepS === 1) {\n      const pxPerFrame = pxPerSec / currentFps;\n      let frameStep = 1;\n      if (pxPerFrame < 5) {\n        frameStep = Math.ceil(5 / pxPerFrame);\n      }\n\n      for (let f = 1; f < currentFps; f += frameStep) {\n        const frameX =\n          Math.round(\n            timeUsToPx(s * 1_000_000 + (f * 1_000_000) / currentFps, currentZoom) - startPx,\n          ) + 0.5;\n        if (frameX >= -50 && frameX <= w + 50) {\n          ctx.moveTo(frameX, h - 5); // Taller sub ticks\n          ctx.lineTo(frameX, h);\n        }\n      }\n    } else {\n      let subStepS = 1;\n      if (mainStepS >= 60) subStepS = 10;\n      else if (mainStepS >= 10) subStepS = 5;\n      else if (mainStepS >= 5) subStepS = 1;\n\n      for (let sub = s + subStepS; sub < s + mainStepS; sub += subStepS) {\n        const subX = Math.round(timeUsToPx(sub * 1_000_000, currentZoom) - startPx) + 0.5;\n        if (subX >= -50 && subX <= w + 50) {\n          ctx.moveTo(subX, h - 5); // Taller sub ticks\n          ctx.lineTo(subX, h);\n        }\n      }\n    }\n  }\n  ctx.stroke();\n\n  // Draw playhead head in the ruler for better visual continuity\n  const playheadPx = Math.round(timeUsToPx(currentTime.value, currentZoom) - startPx) + 0.5;\n  if (playheadPx >= -10 && playheadPx <= w + 10) {\n    // Determine the exact color of primary-500 if possible, or use a fallback\n    const styles = window.getComputedStyle(document.documentElement);\n    const primaryColor = styles.getPropertyValue('--color-primary-500').trim() || '#3b82f6';\n\n    ctx.beginPath();\n    ctx.fillStyle = primaryColor;\n\n    // Draw an inverted triangle for the playhead\n    const pw = 10; // width\n    const ph = 10; // height\n\n    ctx.moveTo(playheadPx - pw / 2, h - ph);\n    ctx.lineTo(playheadPx + pw / 2, h - ph);\n    ctx.lineTo(playheadPx, h);\n    ctx.fill();\n\n    // Playhead line through the remaining bottom part of the ruler\n    ctx.beginPath();\n    ctx.strokeStyle = primaryColor;\n    ctx.lineWidth = 1;\n    ctx.moveTo(playheadPx, h);\n    ctx.lineTo(playheadPx, h);\n    ctx.stroke();\n  }\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n}\n</script>\n\n<template>\n  <div\n    ref=\"containerRef\"\n    class=\"relative w-full overflow-hidden\"\n    @mousedown=\"$emit('mousedown', $event)\"\n  >\n    <canvas ref=\"canvasRef\" class=\"absolute top-0 left-0 w-full h-full pointer-events-none\" />\n\n    <div class=\"absolute inset-0 pointer-events-none\">\n      <div\n        v-for=\"p in markerPoints\"\n        :key=\"p.id\"\n        class=\"absolute bottom-0 pointer-events-auto\"\n        :style=\"{ left: `${Math.round(p.x)}px` }\"\n      >\n        <UTooltip :text=\"truncateForTooltip(p.text)\" :disabled=\"!p.text\">\n          <button\n            type=\"button\"\n            class=\"w-2 h-3 -translate-x-1 bg-primary-500 rounded-sm shadow-sm\"\n            :aria-label=\"'Marker'\"\n            @dblclick.stop.prevent=\"openEditMarker(p.id)\"\n            @mousedown.stop\n          />\n        </UTooltip>\n      </div>\n    </div>\n    <AppModal v-if=\"editingMarker\" v-model:open=\"isMarkerEditOpen\" title=\"Marker\">\n      <div class=\"flex flex-col gap-3\">\n        <UTextarea v-model=\"markerTextDraft\" :rows=\"10\" size=\"sm\" />\n      </div>\n\n      <template #footer>\n        <UButton color=\"neutral\" variant=\"ghost\" @click=\"isMarkerEditOpen = false\">\n          {{ t('common.cancel', 'Cancel') }}\n        </UButton>\n        <UButton color=\"primary\" @click=\"saveMarkerText\">\n          {{ t('common.save', 'Save') }}\n        </UButton>\n      </template>\n    </AppModal>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineTabs.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineToolbar.vue","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'addVideoTrack' is defined but never used. Allowed unused vars must match /^_/u.","line":52,"column":10,"messageId":"unusedVar","endLine":52,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'addAudioTrack' is defined but never used. Allowed unused vars must match /^_/u.","line":57,"column":10,"messageId":"unusedVar","endLine":57,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'formatTime' is defined but never used. Allowed unused vars must match /^_/u.","line":92,"column":10,"messageId":"unusedVar","endLine":92,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'togglePlay' is defined but never used. Allowed unused vars must match /^_/u.","line":98,"column":10,"messageId":"unusedVar","endLine":98,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stop' is defined but never used. Allowed unused vars must match /^_/u.","line":102,"column":10,"messageId":"unusedVar","endLine":102,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onZoomInput' is defined but never used. Allowed unused vars must match /^_/u.","line":106,"column":10,"messageId":"unusedVar","endLine":106,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed } from 'vue';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useTimelineSettingsStore } from '~/stores/timelineSettings.store';\nimport type { TimelineTrack } from '~/timeline/types';\nimport TimelineZoomLogSlider from '~/components/ui/TimelineZoomLogSlider.vue';\nimport { useDraggedFile } from '~/composables/useDraggedFile';\n\nconst { t } = useI18n();\nconst timelineStore = useTimelineStore();\nconst settingsStore = useTimelineSettingsStore();\nconst { setDraggedFile, clearDraggedFile } = useDraggedFile();\n\nfunction onDragStart(e: DragEvent, kind: 'adjustment' | 'background' | 'text') {\n  if (e.dataTransfer) {\n    e.dataTransfer.effectAllowed = 'copy';\n    e.dataTransfer.setData(\n      'application/json',\n      JSON.stringify({\n        kind,\n        name: t(`granVideoEditor.timeline.${kind}ClipDefaultName`, kind),\n        path: '',\n      }),\n    );\n  }\n\n  const labels: Record<string, string> = {\n    adjustment: t('granVideoEditor.timeline.adjustmentClipDefaultName', 'Adjustment'),\n    background: t('granVideoEditor.timeline.backgroundClipDefaultName', 'Background'),\n    text: t('granVideoEditor.timeline.textClipDefaultName', 'Text'),\n  };\n\n  setDraggedFile({\n    kind,\n    name: labels[kind] ?? kind,\n    path: '',\n  });\n}\n\nfunction onDragEnd() {\n  clearDraggedFile();\n}\n\nconst emit = defineEmits<{\n  (e: 'update:zoom', value: number): void;\n}>();\n\nconst tracks = computed(\n  () => (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [],\n);\n\nfunction addVideoTrack() {\n  const idx = tracks.value.filter((tr) => tr.kind === 'video').length + 1;\n  timelineStore.addTrack('video', `Video ${idx}`);\n}\n\nfunction addAudioTrack() {\n  const idx = tracks.value.filter((tr) => tr.kind === 'audio').length + 1;\n  timelineStore.addTrack('audio', `Audio ${idx}`);\n}\n\nfunction addAdjustmentClip() {\n  timelineStore.addAdjustmentClipAtPlayhead();\n}\n\nfunction addBackgroundClip() {\n  timelineStore.addBackgroundClipAtPlayhead();\n}\n\nfunction addTextClip() {\n  const defaultName = t('granVideoEditor.timeline.textClipDefaultName', 'Text');\n  const defaultText = t('granVideoEditor.timeline.textClipDefaultText', 'Text');\n  timelineStore.addTextClipAtPlayhead({ name: defaultName, text: defaultText });\n}\n\nfunction addMarker() {\n  timelineStore.addMarkerAtPlayhead();\n}\n\nasync function splitClips() {\n  await timelineStore.splitClipsAtPlayhead();\n}\n\nasync function rippleTrimLeft() {\n  await timelineStore.rippleTrimLeft();\n}\n\nasync function rippleTrimRight() {\n  await timelineStore.rippleTrimRight();\n}\n\nfunction formatTime(seconds: number): string {\n  const m = Math.floor(seconds / 60);\n  const s = Math.floor(seconds % 60);\n  return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;\n}\n\nfunction togglePlay() {\n  timelineStore.togglePlayback();\n}\n\nfunction stop() {\n  timelineStore.stopPlayback();\n}\n\nfunction onZoomInput(e: Event) {\n  const target = e.target as HTMLInputElement | null;\n  timelineStore.setTimelineZoom(Number(target?.value ?? 50));\n}\n\nfunction toggleOverlapMode() {\n  settingsStore.setOverlapMode(settingsStore.overlapMode === 'none' ? 'pseudo' : 'none');\n}\n\nfunction toggleFrameSnapMode() {\n  settingsStore.setFrameSnapMode(settingsStore.frameSnapMode === 'frames' ? 'free' : 'frames');\n}\n\nfunction toggleClipSnapMode() {\n  settingsStore.setClipSnapMode(settingsStore.clipSnapMode === 'clips' ? 'none' : 'clips');\n}\n</script>\n\n<template>\n  <div\n    class=\"flex items-center gap-2 px-2 py-1.5 border-b border-ui-border shrink-0 bg-ui-bg-elevated h-10\"\n  >\n    <div class=\"ml-2 flex items-center gap-1.5\">\n      <div\n        draggable=\"true\"\n        class=\"cursor-grab active:cursor-grabbing\"\n        @dragstart=\"onDragStart($event, 'adjustment')\"\n        @dragend=\"onDragEnd\"\n      >\n        <UButton\n          size=\"sm\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-adjustments-horizontal\"\n          :aria-label=\"t('granVideoEditor.timeline.addAdjustmentClip', 'Add adjustment clip')\"\n          @click=\"addAdjustmentClip\"\n        />\n      </div>\n      <div\n        draggable=\"true\"\n        class=\"cursor-grab active:cursor-grabbing\"\n        @dragstart=\"onDragStart($event, 'background')\"\n        @dragend=\"onDragEnd\"\n      >\n        <UButton\n          size=\"sm\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-swatch\"\n          :aria-label=\"t('granVideoEditor.timeline.addBackgroundClip', 'Add background clip')\"\n          @click=\"addBackgroundClip\"\n        />\n      </div>\n      <div\n        draggable=\"true\"\n        class=\"cursor-grab active:cursor-grabbing\"\n        @dragstart=\"onDragStart($event, 'text')\"\n        @dragend=\"onDragEnd\"\n      >\n        <UButton\n          size=\"sm\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-chat-bubble-bottom-center-text\"\n          :aria-label=\"t('granVideoEditor.timeline.addTextClip', 'Add text clip')\"\n          @click=\"addTextClip\"\n        />\n      </div>\n\n      <UButton\n        size=\"sm\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-bookmark\"\n        :aria-label=\"t('granVideoEditor.timeline.addMarker', 'Add marker')\"\n        @click=\"addMarker\"\n      />\n\n      <div class=\"w-px h-5 bg-ui-border mx-1.5\" />\n\n      <UButton\n        size=\"sm\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-scissors\"\n        :aria-label=\"t('granVideoEditor.timeline.splitClips', 'Split clips at playhead')\"\n        @click=\"splitClips\"\n      />\n\n      <UButton\n        size=\"sm\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-arrow-left\"\n        :aria-label=\"t('granVideoEditor.timeline.rippleTrimLeft', 'Ripple trim left')\"\n        @click=\"rippleTrimLeft\"\n      />\n      <UButton\n        size=\"sm\"\n        variant=\"ghost\"\n        color=\"neutral\"\n        icon=\"i-heroicons-arrow-right\"\n        :aria-label=\"t('granVideoEditor.timeline.rippleTrimRight', 'Ripple trim right')\"\n        @click=\"rippleTrimRight\"\n      />\n    </div>\n\n    <div class=\"mx-2 flex items-center gap-1.5\">\n      <div class=\"w-px h-5 bg-ui-border\" />\n\n      <!-- Overlap mode toggle -->\n      <UButton\n        size=\"sm\"\n        :variant=\"settingsStore.overlapMode === 'pseudo' ? 'solid' : 'ghost'\"\n        :color=\"settingsStore.overlapMode === 'pseudo' ? 'primary' : 'neutral'\"\n        icon=\"i-heroicons-squares-2x2\"\n        :aria-label=\"\n          settingsStore.overlapMode === 'pseudo'\n            ? t('granVideoEditor.timeline.overlayModePseudo', 'Pseudo-overlay mode (active)')\n            : t('granVideoEditor.timeline.overlayModeNone', 'Normal mode (no overlap)')\n        \"\n        :title=\"\n          settingsStore.overlapMode === 'pseudo'\n            ? t('granVideoEditor.timeline.overlayModePseudo', 'Pseudo-overlay mode')\n            : t('granVideoEditor.timeline.overlayModeNone', 'Normal mode')\n        \"\n        @click=\"toggleOverlapMode\"\n      />\n\n      <div class=\"w-px h-5 bg-ui-border\" />\n\n      <!-- Frame snap toggle -->\n      <UButton\n        size=\"sm\"\n        :variant=\"settingsStore.frameSnapMode === 'frames' ? 'solid' : 'ghost'\"\n        :color=\"settingsStore.frameSnapMode === 'frames' ? 'primary' : 'neutral'\"\n        icon=\"i-heroicons-film\"\n        :aria-label=\"\n          settingsStore.frameSnapMode === 'frames'\n            ? t('granVideoEditor.timeline.frameSnapOn', 'Snap to frames (active)')\n            : t('granVideoEditor.timeline.frameSnapOff', 'Free placement (no frame snap)')\n        \"\n        :title=\"\n          settingsStore.frameSnapMode === 'frames'\n            ? t('granVideoEditor.timeline.frameSnapOn', 'Snap to frames')\n            : t('granVideoEditor.timeline.frameSnapOff', 'Free placement')\n        \"\n        @click=\"toggleFrameSnapMode\"\n      />\n\n      <!-- Clip snap toggle -->\n      <UButton\n        size=\"sm\"\n        :variant=\"settingsStore.clipSnapMode === 'clips' ? 'solid' : 'ghost'\"\n        :color=\"settingsStore.clipSnapMode === 'clips' ? 'primary' : 'neutral'\"\n        icon=\"i-heroicons-link\"\n        :aria-label=\"\n          settingsStore.clipSnapMode === 'clips'\n            ? t('granVideoEditor.timeline.clipSnapOn', 'Snap to clips (active)')\n            : t('granVideoEditor.timeline.clipSnapOff', 'No clip snapping')\n        \"\n        :title=\"\n          settingsStore.clipSnapMode === 'clips'\n            ? t('granVideoEditor.timeline.clipSnapOn', 'Snap to clips')\n            : t('granVideoEditor.timeline.clipSnapOff', 'No clip snapping')\n        \"\n        @click=\"toggleClipSnapMode\"\n      />\n    </div>\n\n    <div class=\"ml-auto flex items-center gap-2 text-sm text-ui-text-muted\">\n      <UIcon name=\"i-heroicons-magnifying-glass-minus\" class=\"w-4 h-4\" />\n      <TimelineZoomLogSlider\n        :model-value=\"timelineStore.timelineZoom\"\n        :min=\"0\"\n        :max=\"100\"\n        :step=\"1\"\n        slider-class=\"w-28\"\n        :aria-label=\"t('granVideoEditor.timeline.zoom', 'Zoom')\"\n        @update:model-value=\"(v) => emit('update:zoom', v ?? 50)\"\n      />\n      <UIcon name=\"i-heroicons-magnifying-glass-plus\" class=\"w-4 h-4\" />\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineTrackLabels.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":15,"messageId":"unexpectedAny","endLine":157,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4694,4697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4694,4697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { computed, ref } from 'vue';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport type { TimelineTrack } from '~/timeline/types';\nimport UiConfirmModal from '~/components/ui/UiConfirmModal.vue';\nimport AppModal from '~/components/ui/AppModal.vue';\nimport { useSelectionStore } from '~/stores/selection.store';\n\ndefineOptions({ inheritAttrs: false });\n\nconst props = defineProps<{\n  tracks: TimelineTrack[];\n  trackHeights: Record<string, number>;\n}>();\n\nconst emit = defineEmits<{\n  (e: 'update:trackHeight', trackId: string, height: number): void;\n}>();\n\nconst timelineStore = useTimelineStore();\nconst selectionStore = useSelectionStore();\nconst { t } = useI18n();\n\nconst DEFAULT_TRACK_HEIGHT = 40;\nconst MIN_TRACK_HEIGHT = 32;\nconst MAX_TRACK_HEIGHT = 300;\n\nconst resizingTrackId = ref<string | null>(null);\nconst startY = ref(0);\nconst startHeight = ref(0);\n\nfunction onResizeStart(trackId: string, e: MouseEvent) {\n  resizingTrackId.value = trackId;\n  startY.value = e.clientY;\n  startHeight.value = props.trackHeights[trackId] ?? DEFAULT_TRACK_HEIGHT;\n\n  window.addEventListener('mousemove', onGlobalMouseMove);\n  window.addEventListener('mouseup', onGlobalMouseUp);\n}\n\nfunction onGlobalMouseMove(e: MouseEvent) {\n  if (!resizingTrackId.value) return;\n  const dy = e.clientY - startY.value;\n  const nextHeight = Math.max(MIN_TRACK_HEIGHT, Math.min(MAX_TRACK_HEIGHT, startHeight.value + dy));\n  emit('update:trackHeight', resizingTrackId.value, nextHeight);\n}\n\nfunction onGlobalMouseUp() {\n  resizingTrackId.value = null;\n  window.removeEventListener('mousemove', onGlobalMouseMove);\n  window.removeEventListener('mouseup', onGlobalMouseUp);\n}\n\nconst isConfirmDeleteOpen = ref(false);\nconst isRenameOpen = ref(false);\nconst renameValue = ref('');\nconst contextTrackId = ref<string | null>(null);\n\nconst selectedTrackId = computed(() => timelineStore.selectedTrackId);\n\nfunction onSelectTrack(trackId: string) {\n  timelineStore.selectTrack(trackId);\n  selectionStore.selectTimelineTrack(trackId);\n}\n\nfunction toggleVideoHidden(track: TimelineTrack, e: MouseEvent) {\n  e.preventDefault();\n  e.stopPropagation();\n  timelineStore.toggleVideoHidden(track.id);\n}\n\nfunction toggleAudioMuted(track: TimelineTrack, e: MouseEvent) {\n  e.preventDefault();\n  e.stopPropagation();\n  timelineStore.toggleTrackAudioMuted(track.id);\n}\n\nfunction toggleAudioSolo(track: TimelineTrack, e: MouseEvent) {\n  e.preventDefault();\n  e.stopPropagation();\n  timelineStore.toggleTrackAudioSolo(track.id);\n}\n\nconst selectedTrack = computed(() => {\n  const docTracks = (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [];\n  const id = contextTrackId.value ?? timelineStore.selectedTrackId;\n  return docTracks.find((tr) => tr.id === id) ?? null;\n});\n\nconst canDeleteSelectedTrackWithoutConfirm = computed(() =>\n  Boolean(selectedTrack.value && selectedTrack.value.items.length === 0),\n);\n\nfunction openRename(track: TimelineTrack) {\n  contextTrackId.value = track.id;\n  onSelectTrack(track.id);\n  renameValue.value = track.name;\n  isRenameOpen.value = true;\n}\n\nfunction confirmRename() {\n  if (!selectedTrack.value) return;\n  const next = renameValue.value.trim();\n  if (!next) return;\n  timelineStore.renameTrack(selectedTrack.value.id, next);\n  isRenameOpen.value = false;\n  contextTrackId.value = null;\n}\n\nfunction requestDelete(track: TimelineTrack) {\n  contextTrackId.value = track.id;\n  onSelectTrack(track.id);\n  if (canDeleteSelectedTrackWithoutConfirm.value) {\n    timelineStore.deleteTrack(track.id);\n    contextTrackId.value = null;\n    return;\n  }\n  isConfirmDeleteOpen.value = true;\n}\n\nfunction confirmDelete() {\n  if (!selectedTrack.value) return;\n  timelineStore.deleteTrack(selectedTrack.value.id, { allowNonEmpty: true });\n  isConfirmDeleteOpen.value = false;\n  contextTrackId.value = null;\n}\n\nfunction getTrackContextMenuItems(track: TimelineTrack) {\n  return [\n    [\n      {\n        label: t('granVideoEditor.timeline.renameTrack', 'Rename track'),\n        icon: 'i-heroicons-pencil',\n        onSelect: () => openRename(track),\n      },\n      {\n        label: t('granVideoEditor.timeline.deleteTrack', 'Delete track'),\n        icon: 'i-heroicons-trash',\n        onSelect: () => requestDelete(track),\n      },\n    ],\n  ];\n}\n\nfunction onDragStart(e: DragEvent, track: TimelineTrack) {\n  if (!e.dataTransfer) return;\n  e.dataTransfer.setData(\n    'application/json',\n    JSON.stringify({ kind: 'timeline-track', trackId: track.id }),\n  );\n  e.dataTransfer.effectAllowed = 'move';\n}\n\nfunction onDrop(e: DragEvent, targetTrack: TimelineTrack) {\n  const raw = e.dataTransfer?.getData('application/json');\n  if (!raw) return;\n  let parsed: any;\n  try {\n    parsed = JSON.parse(raw);\n  } catch {\n    return;\n  }\n\n  if (parsed?.kind !== 'timeline-track') return;\n  const sourceId = String(parsed?.trackId ?? '');\n  if (!sourceId) return;\n  if (sourceId === targetTrack.id) return;\n\n  const sourceTrack = props.tracks.find((t) => t.id === sourceId);\n  if (!sourceTrack) return;\n  if (sourceTrack.kind !== targetTrack.kind) return;\n\n  const sameKindTracks = props.tracks.filter((t) => t.kind === targetTrack.kind);\n  const sourceIdx = sameKindTracks.findIndex((t) => t.id === sourceTrack.id);\n  const targetIdx = sameKindTracks.findIndex((t) => t.id === targetTrack.id);\n  if (sourceIdx === -1 || targetIdx === -1) return;\n\n  const nextSameKind = [...sameKindTracks];\n  nextSameKind.splice(sourceIdx, 1);\n  nextSameKind.splice(targetIdx, 0, sourceTrack);\n\n  const otherKind = props.tracks.filter((t) => t.kind !== targetTrack.kind);\n  const nextTracks =\n    targetTrack.kind === 'video'\n      ? [...nextSameKind, ...otherKind]\n      : [...otherKind, ...nextSameKind];\n\n  timelineStore.reorderTracks(nextTracks.map((t) => t.id));\n}\nfunction addVideoTrack() {\n  const idx = props.tracks.filter((tr) => tr.kind === 'video').length + 1;\n  timelineStore.addTrack('video', `Video ${idx}`);\n}\n\nfunction addAudioTrack() {\n  const idx = props.tracks.filter((tr) => tr.kind === 'audio').length + 1;\n  timelineStore.addTrack('audio', `Audio ${idx}`);\n}\nfunction onTrackWheel(e: WheelEvent, track: TimelineTrack) {\n  const isSecondary =\n    (e.deltaX !== 0 && Math.abs(e.deltaX) > Math.abs(e.deltaY)) || (!e.deltaY && e.deltaX !== 0);\n\n  // Only handle primary vertical scroll without shift\n  if (isSecondary || e.shiftKey) return;\n\n  e.preventDefault();\n  e.stopPropagation();\n\n  const delta = e.deltaY;\n  if (!Number.isFinite(delta) || delta === 0) return;\n\n  const dir = delta < 0 ? 1 : -1;\n  const step = 10; // Use a moderate step for track resizing\n\n  const currentHeight = props.trackHeights[track.id] ?? DEFAULT_TRACK_HEIGHT;\n  const nextHeight = Math.max(\n    MIN_TRACK_HEIGHT,\n    Math.min(MAX_TRACK_HEIGHT, currentHeight + dir * step),\n  );\n\n  emit('update:trackHeight', track.id, nextHeight);\n}\n</script>\n\n<template>\n  <div\n    class=\"h-full w-full shrink-0 border-r border-ui-border flex flex-col bg-ui-bg\"\n    v-bind=\"$attrs\"\n  >\n    <div\n      class=\"h-7 border-b border-ui-border bg-ui-bg-elevated flex items-center px-1 shrink-0 gap-0.5\"\n    >\n      <UTooltip :text=\"t('granVideoEditor.timeline.addVideoTrack', 'Add video track')\">\n        <UButton\n          size=\"xs\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-video-camera\"\n          @click=\"addVideoTrack\"\n        />\n      </UTooltip>\n      <UTooltip :text=\"t('granVideoEditor.timeline.addAudioTrack', 'Add audio track')\">\n        <UButton\n          size=\"xs\"\n          variant=\"ghost\"\n          color=\"neutral\"\n          icon=\"i-heroicons-musical-note\"\n          @click=\"addAudioTrack\"\n        />\n      </UTooltip>\n\n      <div v-if=\"selectedTrack\" class=\"flex items-center gap-0.5 ml-auto\">\n        <UTooltip :text=\"t('granVideoEditor.timeline.renameTrack', 'Rename track')\">\n          <UButton\n            size=\"xs\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-pencil\"\n            @click=\"openRename(selectedTrack)\"\n          />\n        </UTooltip>\n        <UTooltip :text=\"t('granVideoEditor.timeline.deleteTrack', 'Delete track')\">\n          <UButton\n            size=\"xs\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-trash\"\n            @click=\"requestDelete(selectedTrack)\"\n          />\n        </UTooltip>\n      </div>\n    </div>\n    <div class=\"flex flex-col divide-y divide-ui-border flex-1\">\n      <UContextMenu\n        v-for=\"track in tracks\"\n        :key=\"track.id\"\n        :items=\"getTrackContextMenuItems(track)\"\n      >\n        <div\n          class=\"flex items-center px-2 text-xs font-medium cursor-pointer select-none relative group\"\n          :class=\"\n            selectedTrackId === track.id\n              ? 'text-ui-text bg-ui-bg-accent'\n              : timelineStore.hoveredTrackId === track.id\n                ? 'text-ui-text bg-ui-bg-elevated/80'\n                : 'text-ui-text-muted hover:text-ui-text hover:bg-ui-bg-elevated'\n          \"\n          :style=\"{ height: `${trackHeights[track.id] ?? DEFAULT_TRACK_HEIGHT}px` }\"\n          draggable=\"true\"\n          @dragstart=\"onDragStart($event, track)\"\n          @dragover.prevent\n          @drop.prevent=\"onDrop($event, track)\"\n          @click=\"onSelectTrack(track.id)\"\n          @contextmenu=\"onSelectTrack(track.id)\"\n          @wheel=\"onTrackWheel($event, track)\"\n          @mouseenter=\"timelineStore.hoveredTrackId = track.id\"\n          @mouseleave=\"timelineStore.hoveredTrackId = null\"\n        >\n          <span class=\"truncate\" :title=\"track.name\">{{ track.name }}</span>\n\n          <div class=\"ml-auto flex items-center gap-1\">\n            <UButton\n              v-if=\"track.kind === 'video'\"\n              size=\"xs\"\n              variant=\"ghost\"\n              color=\"neutral\"\n              :icon=\"track.videoHidden ? 'i-heroicons-eye-slash' : 'i-heroicons-eye'\"\n              :aria-label=\"\n                t('granVideoEditor.timeline.toggleTrackVisibility', 'Toggle track visibility')\n              \"\n              @pointerdown.prevent.stop\n              @mousedown.prevent.stop\n              @click=\"toggleVideoHidden(track, $event)\"\n            />\n\n            <UButton\n              size=\"xs\"\n              variant=\"ghost\"\n              :color=\"track.audioMuted ? 'error' : 'neutral'\"\n              :icon=\"track.audioMuted ? 'i-heroicons-speaker-x-mark' : 'i-heroicons-speaker-wave'\"\n              :aria-label=\"t('granVideoEditor.timeline.toggleTrackMute', 'Toggle track mute')\"\n              @pointerdown.prevent.stop\n              @mousedown.prevent.stop\n              @click=\"toggleAudioMuted(track, $event)\"\n            />\n\n            <UButton\n              size=\"xs\"\n              variant=\"ghost\"\n              :color=\"track.audioSolo ? 'primary' : 'neutral'\"\n              icon=\"i-heroicons-musical-note\"\n              :aria-label=\"t('granVideoEditor.timeline.toggleTrackSolo', 'Toggle track solo')\"\n              @pointerdown.prevent.stop\n              @mousedown.prevent.stop\n              @click=\"toggleAudioSolo(track, $event)\"\n            />\n          </div>\n\n          <!-- Bottom resize handle -->\n          <div\n            class=\"absolute bottom-0 left-0 right-0 h-1 cursor-ns-resize z-20 hover:bg-primary-500/50 transition-colors\"\n            @mousedown.stop.prevent=\"onResizeStart(track.id, $event)\"\n          />\n        </div>\n      </UContextMenu>\n    </div>\n  </div>\n\n  <UiConfirmModal\n    v-if=\"selectedTrack\"\n    v-model:open=\"isConfirmDeleteOpen\"\n    :title=\"t('granVideoEditor.timeline.deleteTrackTitle', 'Delete track?')\"\n    :description=\"\n      t(\n        'granVideoEditor.timeline.deleteTrackDescription',\n        'Track is not empty. This action cannot be undone.',\n      )\n    \"\n    color=\"error\"\n    icon=\"i-heroicons-exclamation-triangle\"\n    :confirm-text=\"t('common.delete', 'Delete')\"\n    @confirm=\"confirmDelete\"\n  />\n\n  <AppModal\n    v-if=\"selectedTrack\"\n    v-model:open=\"isRenameOpen\"\n    :title=\"t('granVideoEditor.timeline.renameTrackTitle', 'Rename track')\"\n  >\n    <div class=\"flex flex-col gap-3\">\n      <UInput\n        v-model=\"renameValue\"\n        size=\"sm\"\n        :placeholder=\"t('granVideoEditor.timeline.trackName', 'Track name')\"\n        @keydown.enter.prevent=\"confirmRename\"\n      />\n    </div>\n\n    <template #footer>\n      <UButton color=\"neutral\" variant=\"ghost\" @click=\"isRenameOpen = false\">\n        {{ t('common.cancel', 'Cancel') }}\n      </UButton>\n      <UButton color=\"primary\" @click=\"confirmRename\">\n        {{ t('common.save', 'Save') }}\n      </UButton>\n    </template>\n  </AppModal>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/TimelineTracks.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":24,"messageId":"unexpectedAny","endLine":59,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2050,2053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2050,2053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":41,"messageId":"unexpectedAny","endLine":59,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2067,2070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2067,2070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/unified-signatures","severity":1,"message":"This overload and the one on line 64 can be combined into one signature taking `'drop' | 'dragover'`.","line":65,"column":4,"messageId":"singleParameterDifference","endLine":65,"endColumn":17},{"ruleId":"@typescript-eslint/unified-signatures","severity":1,"message":"This overload and the one on line 64 can be combined into one signature taking `'drop' | 'dragleave'`.","line":66,"column":4,"messageId":"singleParameterDifference","endLine":66,"endColumn":18},{"ruleId":"@typescript-eslint/unified-signatures","severity":1,"message":"This overload and the one on line 65 can be combined into one signature taking `'dragover' | 'dragleave'`.","line":66,"column":4,"messageId":"singleParameterDifference","endLine":66,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":35,"messageId":"unexpectedAny","endLine":263,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7993,7996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7993,7996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":73,"messageId":"unexpectedAny","endLine":263,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8031,8034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8031,8034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":299,"column":25,"messageId":"unexpectedAny","endLine":299,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9319,9322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9319,9322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":300,"column":26,"messageId":"unexpectedAny","endLine":300,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9380,9383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9380,9383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":25,"messageId":"unexpectedAny","endLine":336,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10696,10699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10696,10699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":26,"messageId":"unexpectedAny","endLine":337,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10746,10749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10746,10749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":404,"column":19,"messageId":"unexpectedAny","endLine":404,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12825,12828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12825,12828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":405,"column":19,"messageId":"unexpectedAny","endLine":405,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12880,12883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12880,12883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":23,"messageId":"unexpectedAny","endLine":419,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13553,13556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13553,13556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":431,"column":23,"messageId":"unexpectedAny","endLine":431,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14207,14210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14207,14210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":708,"column":62,"messageId":"unexpectedAny","endLine":708,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23345,23348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23345,23348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":729,"column":20,"messageId":"unexpectedAny","endLine":729,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23792,23795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23792,23795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":756,"column":38,"messageId":"unexpectedAny","endLine":756,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24819,24822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24819,24822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":780,"column":58,"messageId":"unexpectedAny","endLine":780,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25784,25787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25784,25787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":784,"column":20,"messageId":"unexpectedAny","endLine":784,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25890,25893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25890,25893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":836,"column":22,"messageId":"unexpectedAny","endLine":836,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27796,27799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27796,27799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":856,"column":28,"messageId":"unexpectedAny","endLine":856,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28353,28356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28353,28356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":857,"column":36,"messageId":"unexpectedAny","endLine":857,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28400,28403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28400,28403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":858,"column":37,"messageId":"unexpectedAny","endLine":858,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28456,28459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28456,28459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref, computed } from 'vue';\nimport { storeToRefs } from 'pinia';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useSelectionStore } from '~/stores/selection.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport type { TimelineClipItem, TimelineTrack, TimelineTrackItem } from '~/timeline/types';\nimport { timeUsToPx, pxToDeltaUs } from '~/composables/timeline/useTimelineInteraction';\nimport AppModal from '~/components/ui/AppModal.vue';\nimport TimelineClipThumbnails from '~/components/timeline/TimelineClipThumbnails.vue';\nimport TimelineAudioWaveform from '~/components/timeline/audio/TimelineAudioWaveform.vue';\n\nconst { t } = useI18n();\nconst timelineStore = useTimelineStore();\nconst selectionStore = useSelectionStore();\nconst projectStore = useProjectStore();\nconst mediaStore = useMediaStore();\nconst { selectedTransition } = storeToRefs(timelineStore);\n\nconst props = defineProps<{\n  tracks: TimelineTrack[];\n  trackHeights: Record<string, number>;\n  dragPreview?: {\n    trackId: string;\n    startUs: number;\n    label: string;\n    durationUs: number;\n    kind: 'timeline-clip' | 'file';\n  } | null;\n  movePreview?: {\n    itemId: string;\n    trackId: string;\n    startUs: number;\n  } | null;\n  draggingMode?: 'move' | 'trim_start' | 'trim_end' | null;\n  draggingItemId?: string | null;\n}>();\n\nconst DEFAULT_TRACK_HEIGHT = 40;\n\nconst movePreviewResolved = computed(() => {\n  const mp = props.movePreview;\n  if (!mp) return null;\n  const targetTrack = props.tracks.find((t) => t.id === mp.trackId);\n  if (!targetTrack) return null;\n\n  const clip = props.tracks\n    .flatMap((t) => t.items)\n    .find((it) => it.id === mp.itemId && it.kind === 'clip');\n  if (!clip || clip.kind !== 'clip') return null;\n  return {\n    trackId: targetTrack.id,\n    itemId: clip.id,\n    startUs: mp.startUs,\n    durationUs: clip.timelineRange.durationUs,\n    label: clip.name,\n    trackKind: targetTrack.kind,\n    clipType: (clip as any).clipType as any,\n  };\n});\n\nconst emit = defineEmits<{\n  (e: 'drop', event: DragEvent, trackId: string): void;\n  (e: 'dragover', event: DragEvent, trackId: string): void;\n  (e: 'dragleave', event: DragEvent, trackId: string): void;\n  (e: 'startMoveItem', event: MouseEvent, trackId: string, itemId: string, startUs: number): void;\n  (e: 'selectItem', event: MouseEvent, itemId: string): void;\n  (\n    e: 'clipAction',\n    payload: {\n      action: 'extractAudio' | 'returnAudio' | 'freezeFrame' | 'resetFreezeFrame';\n      trackId: string;\n      itemId: string;\n      videoItemId?: string;\n    },\n  ): void;\n  (\n    e: 'startTrimItem',\n    event: MouseEvent,\n    payload: { trackId: string; itemId: string; edge: 'start' | 'end'; startUs: number },\n  ): void;\n}>();\n\nconst speedModal = ref<{\n  open: boolean;\n  trackId: string;\n  itemId: string;\n  speed: number;\n} | null>(null);\n\nconst speedModalOpen = computed({\n  get: () => Boolean(speedModal.value?.open),\n  set: (v) => {\n    if (!speedModal.value) return;\n    speedModal.value.open = v;\n  },\n});\n\nconst speedModalSpeed = computed({\n  get: () => speedModal.value?.speed ?? 1,\n  set: (v: number) => {\n    if (!speedModal.value) return;\n    speedModal.value.speed = v;\n  },\n});\n\nfunction openSpeedModal(trackId: string, itemId: string, currentSpeed: unknown) {\n  const base = typeof currentSpeed === 'number' && Number.isFinite(currentSpeed) ? currentSpeed : 1;\n  speedModal.value = {\n    open: true,\n    trackId,\n    itemId,\n    speed: Math.max(0.1, Math.min(10, base)),\n  };\n}\n\nasync function saveSpeedModal() {\n  if (!speedModal.value) return;\n  const speed = Number(speedModal.value.speed);\n  if (!Number.isFinite(speed) || speed <= 0) return;\n  timelineStore.updateClipProperties(speedModal.value.trackId, speedModal.value.itemId, {\n    speed: Math.max(0.1, Math.min(10, speed)),\n  });\n  speedModal.value.open = false;\n  await timelineStore.requestTimelineSave({ immediate: true });\n}\n\nfunction selectTransition(\n  e: MouseEvent,\n  input: { trackId: string; itemId: string; edge: 'in' | 'out' },\n) {\n  e.stopPropagation();\n  timelineStore.selectTransition(input);\n  selectionStore.selectTimelineTransition(input.trackId, input.itemId, input.edge);\n}\n\nfunction transitionUsToPx(durationUs: number | undefined): number {\n  const safeUs = typeof durationUs === 'number' && Number.isFinite(durationUs) ? durationUs : 0;\n  return Math.max(8, timeUsToPx(Math.max(0, safeUs), timelineStore.timelineZoom));\n}\n\n/**\n * Returns true when this clip's transitionIn visually overlaps with the previous\n * clip's transitionOut (blend crossfade overlap). In that case we hide the transitionIn\n * SVG/icon to avoid rendering two overlapping triangles, but keep the button and\n * resize handle functional.\n */\nfunction isCrossfadeTransitionIn(track: TimelineTrack, item: TimelineClipItem): boolean {\n  if (!item.transitionIn) return false;\n  const ordered = getOrderedClipsOnTrack(track);\n  const idx = ordered.findIndex((c) => c.id === item.id);\n  if (idx <= 0) return false;\n  const prev = ordered[idx - 1]!;\n  const overlapUs =\n    prev.timelineRange.startUs + prev.timelineRange.durationUs - item.timelineRange.startUs;\n  return overlapUs > 0 && Boolean(prev.transitionOut);\n}\n\n// --- Resize transition by dragging ---\nconst resizeTransition = ref<{\n  trackId: string;\n  itemId: string;\n  edge: 'in' | 'out';\n  startX: number;\n  startDurationUs: number;\n} | null>(null);\n\n// --- Resize audio fade by dragging ---\nconst resizeFade = ref<{\n  trackId: string;\n  itemId: string;\n  edge: 'in' | 'out';\n  startX: number;\n  startFadeUs: number;\n} | null>(null);\n\n// --- Resize volume by dragging ---\nconst resizeVolume = ref<{\n  trackId: string;\n  itemId: string;\n  startY: number;\n  startVolume: number;\n  height: number;\n} | null>(null);\n\nfunction startResizeVolume(\n  e: MouseEvent,\n  trackId: string,\n  itemId: string,\n  currentVolume: number,\n  clipHeight: number,\n) {\n  e.stopPropagation();\n  e.preventDefault();\n  resizeVolume.value = {\n    trackId,\n    itemId,\n    startY: e.clientY,\n    startVolume: currentVolume,\n    height: clipHeight,\n  };\n\n  function onMouseMove(ev: MouseEvent) {\n    if (!resizeVolume.value) return;\n    const dy = ev.clientY - resizeVolume.value.startY;\n    const deltaVol = -(dy / resizeVolume.value.height) * 2;\n    let newVol = resizeVolume.value.startVolume + deltaVol;\n    newVol = Math.max(0, Math.min(2, newVol));\n\n    timelineStore.updateClipProperties(trackId, itemId, {\n      audioGain: newVol,\n    });\n  }\n\n  function onMouseUp() {\n    if (resizeVolume.value) {\n      timelineStore.requestTimelineSave({ immediate: true });\n    }\n    resizeVolume.value = null;\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  }\n\n  window.addEventListener('mousemove', onMouseMove);\n  window.addEventListener('mouseup', onMouseUp);\n}\n\nfunction startResizeFade(\n  e: MouseEvent,\n  trackId: string,\n  itemId: string,\n  edge: 'in' | 'out',\n  currentFadeUs: number,\n) {\n  e.stopPropagation();\n  e.preventDefault();\n  resizeFade.value = {\n    trackId,\n    itemId,\n    edge,\n    startX: e.clientX,\n    startFadeUs: currentFadeUs,\n  };\n\n  function onMouseMove(ev: MouseEvent) {\n    if (!resizeFade.value) return;\n    const dx = ev.clientX - resizeFade.value.startX;\n    // For 'in' edge: drag right = longer fade, drag left = shorter fade\n    // For 'out' edge: drag left = longer fade (towards start), drag right = shorter fade\n    const sign = edge === 'in' ? 1 : -1;\n    const deltaPx = dx * sign;\n    const deltaUs = pxToDeltaUs(deltaPx, timelineStore.timelineZoom);\n\n    const track = props.tracks.find((t) => t.id === trackId);\n    const item = track?.items.find((i) => i.id === itemId);\n    if (!item || item.kind !== 'clip') return;\n\n    const clipDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n    const oppFadeUs = Math.max(\n      0,\n      Math.round(\n        edge === 'in' ? ((item as any).audioFadeOutUs ?? 0) : ((item as any).audioFadeInUs ?? 0),\n      ),\n    );\n    const maxUs = Math.max(0, clipDurationUs - oppFadeUs);\n    let newFadeUs = resizeFade.value.startFadeUs + deltaUs;\n    newFadeUs = Math.max(0, Math.min(maxUs, newFadeUs));\n\n    const propName = edge === 'in' ? 'audioFadeInUs' : 'audioFadeOutUs';\n    timelineStore.updateClipProperties(trackId, itemId, {\n      [propName]: Math.round(newFadeUs),\n    });\n  }\n\n  function onMouseUp() {\n    if (resizeFade.value) {\n      timelineStore.requestTimelineSave({ immediate: true });\n    }\n    resizeFade.value = null;\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  }\n\n  window.addEventListener('mousemove', onMouseMove);\n  window.addEventListener('mouseup', onMouseUp);\n}\n\n// --- Collapse Logic for Transitions and Fades ---\nfunction clipHasAudio(item: TimelineClipItem, track: TimelineTrack): boolean {\n  if (track.kind === 'video' && item.audioFromVideoDisabled) return false;\n  if (item.clipType !== 'media' && item.clipType !== 'timeline') return false;\n  if (!item.source?.path) return false;\n  const meta = mediaStore.mediaMetadata[item.source.path];\n  return Boolean(meta?.audio);\n}\n\nfunction shouldCollapseTransitions(item: TimelineClipItem): boolean {\n  const inUs = (item as any).transitionIn?.durationUs ?? 0;\n  const outUs = (item as any).transitionOut?.durationUs ?? 0;\n  if (inUs === 0 && outUs === 0) return false;\n\n  const clipDurationUs = item.timelineRange.durationUs;\n  const hitEachOther = inUs + outUs > clipDurationUs + 1000; // 1ms tolerance\n\n  const clipUnstretchedPx = timeUsToPx(clipDurationUs, timelineStore.timelineZoom);\n  const clipWidth = Math.max(2, clipUnstretchedPx);\n\n  // Collapse if they hit each other in time, but the clip is artificially stretched\n  // so they can no longer visually show the correct proportional sizes (a gap would appear).\n  if (hitEachOther && clipWidth > clipUnstretchedPx + 1) {\n    return true;\n  }\n\n  // Also collapse if their minimum pixel size forces them to visually overlap in the clip box\n  const inPx = inUs > 0 ? transitionUsToPx(inUs) : 0;\n  const outPx = outUs > 0 ? transitionUsToPx(outUs) : 0;\n  if (inPx + outPx > clipWidth) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction clampHandlePx(px: number, clipPx: number): number {\n  const safePx = Number.isFinite(px) ? px : 0;\n  const safeClipPx = Number.isFinite(clipPx) ? Math.max(0, clipPx) : 0;\n  const padPx = 3;\n  if (safeClipPx <= padPx * 2) {\n    return safeClipPx / 2;\n  }\n  return Math.max(padPx, Math.min(safeClipPx - padPx, safePx));\n}\n\nfunction shouldCollapseFades(item: TimelineClipItem): boolean {\n  const inUs = (item as any).audioFadeInUs ?? 0;\n  const outUs = (item as any).audioFadeOutUs ?? 0;\n  if (inUs === 0 && outUs === 0) return false;\n\n  const clipDurationUs = item.timelineRange.durationUs;\n  const hitEachOther = inUs > 0 && outUs > 0 && inUs + outUs > clipDurationUs - 1000;\n\n  const clipUnstretchedPx = timeUsToPx(clipDurationUs, timelineStore.timelineZoom);\n  const clipWidth = Math.max(2, clipUnstretchedPx);\n\n  if (hitEachOther && clipWidth > clipUnstretchedPx + 1) {\n    return true;\n  }\n\n  const inPx = timeUsToPx(inUs, timelineStore.timelineZoom);\n  const outPx = timeUsToPx(outUs, timelineStore.timelineZoom);\n  if (inPx + outPx > clipWidth) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOrderedClipsOnTrack(track: TimelineTrack): TimelineClipItem[] {\n  const clips = track.items.filter((it): it is TimelineClipItem => it.kind === 'clip');\n  return [...clips].sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n}\n\nfunction getAdjacentClipForTransitionEdge(input: {\n  trackId: string;\n  itemId: string;\n  edge: 'in' | 'out';\n}): { clip: TimelineClipItem; adjacent: TimelineClipItem | null } | null {\n  const track = props.tracks.find((t) => t.id === input.trackId);\n  if (!track) return null;\n  const ordered = getOrderedClipsOnTrack(track);\n  const idx = ordered.findIndex((c) => c.id === input.itemId);\n  if (idx === -1) return null;\n  const clip = ordered[idx]!;\n  const adjacent =\n    input.edge === 'in'\n      ? idx > 0\n        ? ordered[idx - 1]!\n        : null\n      : idx < ordered.length - 1\n        ? ordered[idx + 1]!\n        : null;\n  return { clip, adjacent };\n}\n\nfunction computeMaxResizableTransitionDurationUs(input: {\n  trackId: string;\n  itemId: string;\n  edge: 'in' | 'out';\n  currentTransition: import('~/timeline/types').ClipTransition;\n}): number {\n  const resolved = getAdjacentClipForTransitionEdge({\n    trackId: input.trackId,\n    itemId: input.itemId,\n    edge: input.edge,\n  });\n  if (!resolved) return 10_000_000;\n\n  const { clip, adjacent } = resolved;\n\n  const clipDuration = clip.timelineRange.durationUs;\n  const oppTransitionUs =\n    input.edge === 'in'\n      ? ((clip as any).transitionOut?.durationUs ?? 0)\n      : ((clip as any).transitionIn?.durationUs ?? 0);\n  const maxWithinClip = Math.max(0, clipDuration - oppTransitionUs);\n\n  let limitByHandle = Number.POSITIVE_INFINITY;\n\n  // Only enforce hard max for blend crossfades (needs overlap material)\n  const mode = input.currentTransition.mode ?? 'blend';\n  if (mode === 'blend' && adjacent) {\n    if (input.edge === 'in') {\n      // We're resizing transitionIn of `clip` => crossfade uses previous clip tail handle.\n      const prev = adjacent;\n      const prevSourceEnd = (prev.sourceRange?.startUs ?? 0) + (prev.sourceRange?.durationUs ?? 0);\n      const prevMaxEnd =\n        prev.clipType === 'media' && !prev.isImage\n          ? ((prev as any).sourceDurationUs ?? prevSourceEnd)\n          : Number.POSITIVE_INFINITY;\n      const prevTailHandleUs = Number.isFinite(prevMaxEnd)\n        ? Math.max(0, Math.round(Number(prevMaxEnd)) - Math.round(prevSourceEnd))\n        : Number.POSITIVE_INFINITY;\n      limitByHandle = Math.max(0, prevTailHandleUs + input.currentTransition.durationUs);\n    } else {\n      // Resizing transitionOut of `clip` => uses this clip tail handle.\n      const curr = clip;\n      const currSourceEnd = (curr.sourceRange?.startUs ?? 0) + (curr.sourceRange?.durationUs ?? 0);\n      const currMaxEnd =\n        curr.clipType === 'media' && !curr.isImage\n          ? ((curr as any).sourceDurationUs ?? currSourceEnd)\n          : Number.POSITIVE_INFINITY;\n      const currTailHandleUs = Number.isFinite(currMaxEnd)\n        ? Math.max(0, Math.round(Number(currMaxEnd)) - Math.round(currSourceEnd))\n        : Number.POSITIVE_INFINITY;\n      limitByHandle = Math.max(0, currTailHandleUs + input.currentTransition.durationUs);\n    }\n  }\n\n  return Math.min(maxWithinClip, limitByHandle);\n}\n\nfunction startResizeTransition(\n  e: MouseEvent,\n  trackId: string,\n  itemId: string,\n  edge: 'in' | 'out',\n  currentDurationUs: number,\n) {\n  e.stopPropagation();\n  e.preventDefault();\n  resizeTransition.value = {\n    trackId,\n    itemId,\n    edge,\n    startX: e.clientX,\n    startDurationUs: currentDurationUs,\n  };\n\n  function onMouseMove(ev: MouseEvent) {\n    if (!resizeTransition.value) return;\n    const dx = ev.clientX - resizeTransition.value.startX;\n    // For 'in' edge: drag right = longer, drag left = shorter\n    // For 'out' edge: drag left = longer (towards start), drag right = shorter\n    const sign = edge === 'in' ? 1 : -1;\n    const deltaPx = dx * sign;\n    const deltaUs = pxToDeltaUs(deltaPx, timelineStore.timelineZoom);\n    const minUs = 100_000; // 0.1s\n\n    const track = props.tracks.find((t) => t.id === trackId);\n    const item = track?.items.find((i) => i.id === itemId);\n    if (!item || item.kind !== 'clip') return;\n\n    const current =\n      edge === 'in'\n        ? (item as TimelineClipItem).transitionIn\n        : (item as TimelineClipItem).transitionOut;\n    if (!current) return;\n\n    const maxUsRaw = computeMaxResizableTransitionDurationUs({\n      trackId,\n      itemId,\n      edge,\n      currentTransition: current,\n    });\n\n    if (maxUsRaw <= 0) return;\n    const maxUs = Math.max(minUs, maxUsRaw);\n\n    const newDurationUs = Math.min(\n      maxUs,\n      Math.max(minUs, resizeTransition.value.startDurationUs + deltaUs),\n    );\n\n    timelineStore.updateClipTransition(trackId, itemId, {\n      [edge === 'in' ? 'transitionIn' : 'transitionOut']: {\n        ...current,\n        durationUs: Math.round(newDurationUs),\n      },\n    });\n  }\n\n  function onMouseUp() {\n    resizeTransition.value = null;\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n  }\n\n  window.addEventListener('mousemove', onMouseMove);\n  window.addEventListener('mouseup', onMouseUp);\n}\n\n// --- Problem detection: previous clip too short for blend transition ---\nfunction getPrevClipForItem(\n  track: TimelineTrack,\n  item: TimelineTrackItem,\n): TimelineClipItem | null {\n  const clips = track.items.filter((it): it is TimelineClipItem => it.kind === 'clip');\n  const idx = clips.findIndex((c) => c.id === item.id);\n  if (idx <= 0) return null;\n  return clips[idx - 1] ?? null;\n}\n\nfunction hasTransitionInProblem(track: TimelineTrack, item: TimelineTrackItem): string | null {\n  if (item.kind !== 'clip') return null;\n  const clip = item as TimelineClipItem;\n  const tr = clip.transitionIn;\n  if (!tr) return null;\n  const mode = tr.mode ?? 'blend';\n\n  if (mode === 'blend') {\n    const prev = getPrevClipForItem(track, item);\n    if (!prev)\n      return t(\n        'granVideoEditor.timeline.transition.errorNoPreviousClip',\n        'No previous clip to blend with',\n      );\n\n    // Gap check: clips must be adjacent (no gap > 0)\n    const prevEndUs = prev.timelineRange.startUs + prev.timelineRange.durationUs;\n    const gapUs = clip.timelineRange.startUs - prevEndUs;\n    if (gapUs > 1_000) {\n      const gapSeconds = (gapUs / 1_000_000).toFixed(2);\n      return t('granVideoEditor.timeline.transition.errorGapBetweenClips', {\n        gapSeconds,\n      });\n    }\n\n    // Duration check: prev clip must be long enough\n    const prevDurS = prev.timelineRange.durationUs / 1_000_000;\n    const needS = tr.durationUs / 1_000_000;\n    if (prevDurS < needS) {\n      return t('granVideoEditor.timeline.transition.errorPrevClipTooShort', {\n        needSeconds: needS.toFixed(2),\n        haveSeconds: prevDurS.toFixed(2),\n      });\n    }\n\n    // Handle material check for media video clips only\n    if (prev.kind === 'clip' && prev.clipType === 'media') {\n      const prevClip = prev as TimelineClipItem;\n      const prevSourceEnd =\n        (prevClip.sourceRange?.startUs ?? 0) + (prevClip.sourceRange?.durationUs ?? 0);\n      const prevTimelineEnd = prevClip.timelineRange.durationUs;\n      const handleUs = prevSourceEnd - prevTimelineEnd;\n      if (handleUs < tr.durationUs - 1_000) {\n        const haveS = Math.max(0, handleUs / 1_000_000);\n        return t('granVideoEditor.timeline.transition.errorPrevHandleTooShort', {\n          needSeconds: needS.toFixed(2),\n          haveSeconds: haveS.toFixed(2),\n        });\n      }\n    }\n\n    return null;\n  }\n\n  if (mode === 'composite') {\n    const transitionStart = clip.timelineRange.startUs;\n    const transitionEnd = transitionStart + tr.durationUs;\n    const myTrackIdx = props.tracks.findIndex((t) => t.id === track.id);\n    for (let i = myTrackIdx + 1; i < props.tracks.length; i++) {\n      const lowerTrack = props.tracks[i]!;\n      for (const it of lowerTrack.items) {\n        if (it.kind !== 'clip') continue;\n        const itStart = it.timelineRange.startUs;\n        const itEnd = itStart + it.timelineRange.durationUs;\n        if (itStart < transitionStart && itEnd > transitionStart && itEnd < transitionEnd) {\n          return t(\n            'granVideoEditor.timeline.transition.errorCompositeLowerEndsMid',\n            'A lower-track clip ends mid-transition (composite blend will be incomplete)',\n          );\n        }\n      }\n    }\n    return null;\n  }\n\n  return null;\n}\n\nfunction hasTransitionOutProblem(track: TimelineTrack, item: TimelineTrackItem): string | null {\n  if (item.kind !== 'clip') return null;\n  const clip = item as TimelineClipItem;\n  const tr = clip.transitionOut;\n  if (!tr) return null;\n  const mode = tr.mode ?? 'blend';\n\n  if (mode === 'composite') {\n    const clipEnd = clip.timelineRange.startUs + clip.timelineRange.durationUs;\n    const outStart = clipEnd - tr.durationUs;\n    const myTrackIdx = props.tracks.findIndex((t) => t.id === track.id);\n    for (let i = myTrackIdx + 1; i < props.tracks.length; i++) {\n      const lowerTrack = props.tracks[i]!;\n      for (const it of lowerTrack.items) {\n        if (it.kind !== 'clip') continue;\n        const itStart = it.timelineRange.startUs;\n        const itEnd = itStart + it.timelineRange.durationUs;\n        // Lower clip starts within the transition-out window and ends after the current clip\n        if (itStart > outStart && itStart < clipEnd && itEnd > clipEnd) {\n          return t(\n            'granVideoEditor.timeline.transition.errorCompositeLowerStartsMid',\n            'A lower-track clip starts mid-transition (composite blend will be incomplete)',\n          );\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// --- Transition visual helpers ---\n\n/** Lower triangle: darker variant */\nfunction getClipLowerTriColor(_item: TimelineTrackItem, _track: TimelineTrack): string {\n  return 'var(--clip-lower-tri)';\n}\n\nfunction getClipWidthPx(item: TimelineTrackItem): number {\n  return Math.max(2, timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom));\n}\n\n/** Get dynamic classes for clip background and border */\nfunction getClipClass(item: TimelineTrackItem, track: TimelineTrack): string[] {\n  if (item.kind === 'gap') {\n    return [\n      'border',\n      'border-dashed',\n      'border-ui-border/50',\n      'bg-ui-bg-elevated/20',\n      'hover:bg-ui-bg-elevated/40',\n      'text-ui-text-muted',\n      'transition-colors',\n    ];\n  }\n\n  const clipItem = item as TimelineClipItem;\n  const baseClasses = ['border', 'transition-colors'];\n\n  if (clipItem.clipType === 'background') {\n    return [\n      ...baseClasses,\n      'bg-[var(--clip-background-bg)]',\n      'border-[var(--clip-background-border)]',\n      'hover:bg-[var(--clip-background-bg-hover)]',\n    ];\n  }\n  if (clipItem.clipType === 'adjustment') {\n    return [\n      ...baseClasses,\n      'bg-[var(--clip-adjustment-bg)]',\n      'border-[var(--clip-adjustment-border)]',\n      'hover:bg-[var(--clip-adjustment-bg-hover)]',\n    ];\n  }\n  if (track.kind === 'audio') {\n    return [\n      ...baseClasses,\n      'bg-[var(--clip-audio-bg)]',\n      'border-[var(--clip-audio-border)]',\n      'hover:bg-[var(--clip-audio-bg-hover)]',\n    ];\n  }\n\n  // Default video clip: indigo/primary\n  return [\n    ...baseClasses,\n    'bg-[var(--clip-video-bg)]',\n    'border-[var(--clip-video-border)]',\n    'hover:bg-[var(--clip-video-bg-hover)]',\n  ];\n}\n\nfunction transitionSvgParts(w: number, h: number, edge: 'in' | 'out'): string {\n  const m = h / 2;\n  if (edge === 'in') {\n    // Current clip absorbs previous (previous recedes right)\n    // Dark triangle base on left, apex right.\n    return `M0,0 L${w},${m} L0,${h} Z`;\n  } else {\n    // Next clip absorbs current. Body of current clip ends in a point.\n    // We draw two dark triangles at the top-right and bottom-right corners.\n    return `M0,0 L${w},0 L${w},${m} Z M0,${h} L${w},${h} L${w},${m} Z`;\n  }\n}\n\n// --- Context menu ---\nfunction getClipContextMenuItems(track: TimelineTrack, item: any) {\n  if (!item) return [];\n\n  if (item.kind === 'gap') {\n    return [\n      [\n        {\n          label: t('granVideoEditor.timeline.delete', 'Delete'),\n          icon: 'i-heroicons-trash',\n          onSelect: () => {\n            timelineStore.applyTimeline({\n              type: 'delete_items',\n              trackId: track.id,\n              itemIds: [item.id],\n            });\n          },\n        },\n      ],\n    ];\n  }\n\n  const mainGroup: any[] = [];\n\n  if (item.kind === 'clip') {\n    mainGroup.push({\n      label: item.disabled\n        ? t('granVideoEditor.timeline.enableClip', 'Enable clip')\n        : t('granVideoEditor.timeline.disableClip', 'Disable clip'),\n      icon: item.disabled ? 'i-heroicons-eye' : 'i-heroicons-eye-slash',\n      onSelect: async () => {\n        timelineStore.updateClipProperties(track.id, item.id, {\n          disabled: !item.disabled,\n        });\n        await timelineStore.requestTimelineSave({ immediate: true });\n      },\n    });\n\n    mainGroup.push({\n      label: item.locked\n        ? t('granVideoEditor.timeline.unlockClip', 'Unlock clip')\n        : t('granVideoEditor.timeline.lockClip', 'Lock clip'),\n      icon: item.locked ? 'i-heroicons-lock-open' : 'i-heroicons-lock-closed',\n      onSelect: async () => {\n        timelineStore.updateClipProperties(track.id, item.id, { locked: !item.locked });\n        await timelineStore.requestTimelineSave({ immediate: true });\n      },\n    });\n\n    const currentSpeedRaw = (item as any).speed;\n    const currentSpeed =\n      typeof currentSpeedRaw === 'number' && Number.isFinite(currentSpeedRaw) ? currentSpeedRaw : 1;\n\n    mainGroup.push({\n      label: `${t('granVideoEditor.timeline.speed', 'Speed')} (${currentSpeed.toFixed(2)})`,\n      icon: 'i-heroicons-forward',\n      onSelect: () => openSpeedModal(track.id, item.id, currentSpeed),\n    });\n\n    const canExtract =\n      track.kind === 'video' && item.clipType === 'media' && !item.audioFromVideoDisabled;\n    if (canExtract) {\n      mainGroup.push({\n        label: t('granVideoEditor.timeline.extractAudio', 'Extract audio to audio track'),\n        icon: 'i-heroicons-musical-note',\n        onSelect: () =>\n          emit('clipAction', { action: 'extractAudio', trackId: track.id, itemId: item.id }),\n      });\n    }\n\n    const hasReturnFromVideoClip =\n      track.kind === 'video' &&\n      Boolean(item.audioFromVideoDisabled) &&\n      (timelineStore.timelineDoc?.tracks ?? []).some((t: any) =>\n        t.kind !== 'audio'\n          ? false\n          : (t.items ?? []).some(\n              (it: any) =>\n                it.kind === 'clip' &&\n                it.linkedVideoClipId === item.id &&\n                Boolean(it.lockToLinkedVideo),\n            ),\n      );\n\n    const hasReturnFromLockedAudioClip =\n      track.kind === 'audio' && Boolean(item.linkedVideoClipId) && Boolean(item.lockToLinkedVideo);\n\n    if (hasReturnFromVideoClip) {\n      mainGroup.push({\n        label: t('granVideoEditor.timeline.returnAudio', 'Return audio to video clip'),\n        icon: 'i-heroicons-arrow-uturn-left',\n        onSelect: () =>\n          emit('clipAction', { action: 'returnAudio', trackId: track.id, itemId: item.id }),\n      });\n    } else if (hasReturnFromLockedAudioClip) {\n      mainGroup.push({\n        label: t('granVideoEditor.timeline.returnAudio', 'Return audio to video clip'),\n        icon: 'i-heroicons-arrow-uturn-left',\n        onSelect: () =>\n          emit('clipAction', {\n            action: 'returnAudio',\n            trackId: track.id,\n            itemId: item.id,\n            videoItemId: String(item.linkedVideoClipId),\n          }),\n      });\n    }\n\n    const isMediaVideoClip = track.kind === 'video' && item.clipType === 'media';\n    const hasFreezeFrame = typeof item.freezeFrameSourceUs === 'number';\n    if (isMediaVideoClip && !hasFreezeFrame) {\n      mainGroup.push({\n        label: t('granVideoEditor.timeline.freezeFrame', 'Freeze frame'),\n        icon: 'i-heroicons-pause-circle',\n        onSelect: () =>\n          emit('clipAction', { action: 'freezeFrame', trackId: track.id, itemId: item.id }),\n      });\n    }\n\n    if (isMediaVideoClip && hasFreezeFrame) {\n      mainGroup.push({\n        label: t('granVideoEditor.timeline.resetFreezeFrame', 'Reset freeze frame'),\n        icon: 'i-heroicons-play-circle',\n        onSelect: () =>\n          emit('clipAction', { action: 'resetFreezeFrame', trackId: track.id, itemId: item.id }),\n      });\n    }\n  }\n\n  const actionGroup: any[] = [\n    {\n      label: t('granVideoEditor.timeline.delete', 'Delete'),\n      icon: 'i-heroicons-trash',\n      disabled: item.kind === 'clip' && Boolean(item.locked),\n      onSelect: () => {\n        selectionStore.clearSelection();\n        timelineStore.applyTimeline({\n          type: 'delete_items',\n          trackId: track.id,\n          itemIds: [item.id],\n        });\n      },\n    },\n  ];\n\n  const result = [];\n  if (mainGroup.length > 0) result.push(mainGroup);\n\n  if (item.kind === 'clip' && track.kind === 'video') {\n    const transitionGroup: any[] = [];\n    const hasIn = Boolean((item as any).transitionIn);\n    const hasOut = Boolean((item as any).transitionOut);\n\n    const defaultTransitionDurationUs = Math.max(\n      0,\n      Math.round(Number(projectStore.projectSettings?.transitions?.defaultDurationUs ?? 2_000_000)),\n    );\n    const clipDurationUs = Math.max(0, Math.round(Number(item.timelineRange?.durationUs ?? 0)));\n    const suggestedDurationUs =\n      clipDurationUs > 0 && clipDurationUs < defaultTransitionDurationUs\n        ? Math.round(clipDurationUs * 0.3)\n        : defaultTransitionDurationUs;\n\n    transitionGroup.push({\n      label: hasIn\n        ? t('granVideoEditor.timeline.removeTransitionIn')\n        : t('granVideoEditor.timeline.addTransitionIn'),\n      icon: hasIn ? 'i-heroicons-x-circle' : 'i-heroicons-arrow-left-end-on-rectangle',\n      onSelect: () => {\n        if (hasIn) {\n          timelineStore.updateClipTransition(track.id, item.id, { transitionIn: null });\n          selectionStore.clearSelection();\n        } else {\n          const transition = {\n            type: 'dissolve',\n            durationUs: suggestedDurationUs,\n            mode: 'blend' as const,\n            curve: 'linear' as const,\n          };\n          timelineStore.updateClipTransition(track.id, item.id, { transitionIn: transition });\n          timelineStore.selectTransition({ trackId: track.id, itemId: item.id, edge: 'in' });\n          selectionStore.selectTimelineTransition(track.id, item.id, 'in');\n        }\n      },\n    });\n\n    transitionGroup.push({\n      label: hasOut\n        ? t('granVideoEditor.timeline.removeTransitionOut')\n        : t('granVideoEditor.timeline.addTransitionOut'),\n      icon: hasOut ? 'i-heroicons-x-circle' : 'i-heroicons-arrow-right-end-on-rectangle',\n      onSelect: () => {\n        if (hasOut) {\n          timelineStore.updateClipTransition(track.id, item.id, { transitionOut: null });\n          selectionStore.clearSelection();\n        } else {\n          const transition = {\n            type: 'dissolve',\n            durationUs: suggestedDurationUs,\n            mode: 'blend' as const,\n            curve: 'linear' as const,\n          };\n          timelineStore.updateClipTransition(track.id, item.id, { transitionOut: transition });\n          timelineStore.selectTransition({ trackId: track.id, itemId: item.id, edge: 'out' });\n          selectionStore.selectTimelineTransition(track.id, item.id, 'out');\n        }\n      },\n    });\n\n    if (transitionGroup.length > 0) result.push(transitionGroup);\n  }\n\n  result.push(actionGroup);\n\n  return result;\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col divide-y divide-ui-border min-h-full\"\n    @mousedown=\"\n      if ($event.button !== 1 && $event.target === $event.currentTarget) {\n        timelineStore.clearSelection();\n        selectionStore.clearSelection();\n        timelineStore.selectTrack(null);\n      }\n    \"\n  >\n    <AppModal\n      v-model:open=\"speedModalOpen\"\n      :title=\"t('granVideoEditor.timeline.speedModalTitle', 'Clip speed')\"\n      :description=\"\n        t('granVideoEditor.timeline.speedModalDescription', 'Changes clip playback speed')\n      \"\n      :ui=\"{ content: 'sm:max-w-md' }\"\n    >\n      <div class=\"flex flex-col gap-3\">\n        <div class=\"flex items-center justify-between gap-3\">\n          <span class=\"text-sm text-ui-text\">\n            {{ t('granVideoEditor.timeline.speedValue', 'Speed') }}\n          </span>\n          <span class=\"text-sm font-mono text-ui-text-muted\">{{\n            Number(speedModalSpeed).toFixed(2)\n          }}</span>\n        </div>\n\n        <UInput v-model.number=\"speedModalSpeed\" type=\"number\" :min=\"0.1\" :max=\"10\" :step=\"0.05\" />\n      </div>\n\n      <template #footer>\n        <div class=\"flex justify-end gap-2 w-full\">\n          <UButton color=\"neutral\" variant=\"ghost\" @click=\"speedModal && (speedModal.open = false)\">\n            {{ t('common.cancel', 'Cancel') }}\n          </UButton>\n          <UButton color=\"primary\" @click=\"saveSpeedModal\">\n            {{ t('common.save', 'Save') }}\n          </UButton>\n        </div>\n      </template>\n    </AppModal>\n\n    <div\n      v-for=\"track in tracks\"\n      :key=\"track.id\"\n      :data-track-id=\"track.id\"\n      class=\"flex items-center px-2 relative transition-colors\"\n      :class=\"[\n        timelineStore.selectedTrackId === track.id ? 'bg-ui-bg-elevated' : '',\n        timelineStore.hoveredTrackId === track.id && timelineStore.selectedTrackId !== track.id\n          ? 'bg-ui-bg-elevated/50'\n          : '',\n      ]\"\n      :style=\"{ height: `${trackHeights[track.id] ?? DEFAULT_TRACK_HEIGHT}px` }\"\n      @dragover.prevent=\"emit('dragover', $event, track.id)\"\n      @dragleave.prevent=\"emit('dragleave', $event, track.id)\"\n      @drop.prevent=\"emit('drop', $event, track.id)\"\n      @mouseenter=\"timelineStore.hoveredTrackId = track.id\"\n      @mouseleave=\"timelineStore.hoveredTrackId = null\"\n      @mousedown=\"\n        if ($event.button !== 1 && $event.target === $event.currentTarget) {\n          timelineStore.clearSelection();\n          selectionStore.clearSelection();\n          timelineStore.selectTrack(null);\n        }\n      \"\n    >\n      <div\n        v-if=\"dragPreview && dragPreview.trackId === track.id\"\n        class=\"absolute inset-y-0 rounded px-2 flex items-center text-xs text-[color:var(--clip-text)] z-30 pointer-events-none opacity-80\"\n        :class=\"\n          dragPreview.kind === 'file'\n            ? 'bg-primary-600 border border-primary-400'\n            : 'bg-ui-bg-accent border border-ui-border'\n        \"\n        :style=\"{\n          left: `${2 + timeUsToPx(dragPreview.startUs, timelineStore.timelineZoom)}px`,\n          width: `${Math.max(2, timeUsToPx(dragPreview.durationUs, timelineStore.timelineZoom))}px`,\n        }\"\n      >\n        <span class=\"truncate\" :title=\"dragPreview.label\">{{ dragPreview.label }}</span>\n      </div>\n\n      <div\n        v-if=\"movePreviewResolved && movePreviewResolved.trackId === track.id\"\n        class=\"absolute inset-y-0 rounded px-2 flex items-center text-xs text-[color:var(--clip-text)] z-40 pointer-events-none opacity-60 bg-ui-bg-accent border border-ui-border\"\n        :style=\"{\n          left: `${2 + timeUsToPx(movePreviewResolved.startUs, timelineStore.timelineZoom)}px`,\n          width: `${Math.max(2, timeUsToPx(movePreviewResolved.durationUs, timelineStore.timelineZoom))}px`,\n        }\"\n      >\n        <span class=\"truncate\" :title=\"movePreviewResolved.label\">{{\n          movePreviewResolved.label\n        }}</span>\n      </div>\n\n      <UContextMenu\n        v-for=\"item in track.items\"\n        :key=\"item.id\"\n        :items=\"getClipContextMenuItems(track, item)\"\n      >\n        <div\n          class=\"absolute inset-y-0 rounded flex flex-col text-xs text-[color:var(--clip-text)] z-10 cursor-pointer select-none transition-shadow group/clip\"\n          :class=\"[\n            timelineStore.selectedItemIds.includes(item.id)\n              ? 'ring-2 ring-(--selection-ring) z-20 shadow-lg'\n              : '',\n            item.kind === 'clip' && typeof (item as any).freezeFrameSourceUs === 'number'\n              ? 'outline outline-2 outline-[color:var(--color-warning)]'\n              : '',\n            item.kind === 'clip' && (Boolean((item as any).disabled) || Boolean(track.videoHidden))\n              ? 'opacity-40'\n              : '',\n            item.kind === 'clip' && Boolean((item as any).locked) ? 'cursor-not-allowed' : '',\n            ...getClipClass(item, track),\n          ]\"\n          :style=\"{\n            left: `${2 + timeUsToPx(item.timelineRange.startUs, timelineStore.timelineZoom)}px`,\n            width: `${getClipWidthPx(item)}px`,\n          }\"\n          @mousedown=\"\n            item.kind === 'clip' &&\n            !Boolean((item as any).locked) &&\n            emit('startMoveItem', $event, item.trackId, item.id, item.timelineRange.startUs)\n          \"\n          @pointerdown=\"\n            if ($event.button !== 1) {\n              $event.stopPropagation();\n              emit('selectItem', $event, item.id);\n              selectionStore.selectTimelineItem(track.id, item.id, item.kind as 'clip' | 'gap');\n            }\n          \"\n        >\n          <!-- Audio Fade Layer (Triangles below transitions/title) -->\n          <div\n            v-if=\"item.kind === 'clip' && clipHasAudio(item, track) && !shouldCollapseFades(item)\"\n            class=\"absolute inset-0 pointer-events-none z-10 overflow-hidden rounded\"\n          >\n            <svg\n              v-if=\"\n                (item as any).audioFadeInUs > 0 &&\n                (item as any).audioFadeInUs <= item.timelineRange.durationUs\n              \"\n              class=\"absolute left-0 top-0 h-full\"\n              preserveAspectRatio=\"none\"\n              viewBox=\"0 0 100 100\"\n              :style=\"{\n                width: `${Math.min(\n                  Math.max(\n                    0,\n                    timeUsToPx(\n                      Math.max(0, Math.round(Number((item as any).audioFadeInUs) || 0)),\n                      timelineStore.timelineZoom,\n                    ),\n                  ),\n                  Math.max(\n                    0,\n                    timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                  ),\n                )}px`,\n              }\"\n            >\n              <polygon points=\"0,0 100,0 0,100\" :fill=\"getClipLowerTriColor(item, track)\" />\n            </svg>\n\n            <svg\n              v-if=\"\n                (item as any).audioFadeOutUs > 0 &&\n                (item as any).audioFadeOutUs <= item.timelineRange.durationUs\n              \"\n              class=\"absolute right-0 top-0 h-full\"\n              preserveAspectRatio=\"none\"\n              viewBox=\"0 0 100 100\"\n              :style=\"{\n                width: `${Math.min(\n                  Math.max(\n                    0,\n                    timeUsToPx(\n                      Math.max(0, Math.round(Number((item as any).audioFadeOutUs) || 0)),\n                      timelineStore.timelineZoom,\n                    ),\n                  ),\n                  Math.max(\n                    0,\n                    timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                  ),\n                )}px`,\n              }\"\n            >\n              <polygon points=\"0,0 100,0 100,100\" :fill=\"getClipLowerTriColor(item, track)\" />\n            </svg>\n          </div>\n\n          <!-- Fade Handles -->\n          <template\n            v-if=\"\n              item.kind === 'clip' &&\n              clipHasAudio(item, track) &&\n              !Boolean((item as any).locked) &&\n              !shouldCollapseFades(item)\n            \"\n          >\n            <!-- Fade In Handle -->\n            <div\n              v-if=\"clipHasAudio(item, track) && !shouldCollapseFades(item)\"\n              class=\"absolute top-0 w-6 h-6 -ml-3 -translate-y-1/2 transition-opacity z-60 flex items-center justify-center\"\n              :class=\"\n                getClipWidthPx(item) >= 30\n                  ? 'cursor-ew-resize opacity-0 group-hover/clip:opacity-100'\n                  : 'hidden pointer-events-none'\n              \"\n              :style=\"{\n                left: `${clampHandlePx(\n                  Math.min(\n                    Math.max(\n                      0,\n                      timeUsToPx((item as any).audioFadeInUs || 0, timelineStore.timelineZoom),\n                    ),\n                    timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                  ),\n                  timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                )}px`,\n              }\"\n              @mousedown.stop=\"\n                startResizeFade($event, track.id, item.id, 'in', (item as any).audioFadeInUs || 0)\n              \"\n            >\n              <div class=\"w-2.5 h-2.5 rounded-full bg-white shadow-sm border border-black/30\"></div>\n            </div>\n\n            <!-- Fade Out Handle -->\n            <div\n              v-if=\"clipHasAudio(item, track) && !shouldCollapseFades(item)\"\n              class=\"absolute top-0 w-6 h-6 -mr-3 -translate-y-1/2 transition-opacity z-60 flex items-center justify-center\"\n              :class=\"\n                getClipWidthPx(item) >= 30\n                  ? 'cursor-ew-resize opacity-0 group-hover/clip:opacity-100'\n                  : 'hidden pointer-events-none'\n              \"\n              :style=\"{\n                right: `${clampHandlePx(\n                  Math.min(\n                    Math.max(\n                      0,\n                      timeUsToPx((item as any).audioFadeOutUs || 0, timelineStore.timelineZoom),\n                    ),\n                    timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                  ),\n                  timeUsToPx(item.timelineRange.durationUs, timelineStore.timelineZoom),\n                )}px`,\n              }\"\n              @mousedown.stop=\"\n                startResizeFade($event, track.id, item.id, 'out', (item as any).audioFadeOutUs || 0)\n              \"\n            >\n              <div class=\"w-2.5 h-2.5 rounded-full bg-white shadow-sm border border-black/30\"></div>\n            </div>\n          </template>\n\n          <!-- Collapsed Indicators for Small Clips -->\n          <div\n            v-if=\"\n              item.kind === 'clip' &&\n              (shouldCollapseTransitions(item) ||\n                (clipHasAudio(item, track) && shouldCollapseFades(item)))\n            \"\n            class=\"absolute top-0.5 left-0.5 flex flex-col gap-0.5 z-40 pointer-events-none\"\n          >\n            <div\n              v-if=\"\n                getClipWidthPx(item) >= 30 &&\n                clipHasAudio(item, track) &&\n                shouldCollapseFades(item) &&\n                (item as any).audioFadeInUs > 0\n              \"\n              class=\"w-3.5 h-3.5 rounded-full bg-white flex items-center justify-center shadow-sm\"\n              title=\"Fade In\"\n            >\n              <UIcon name=\"i-heroicons-arrow-right\" class=\"w-2.5 h-2.5 text-gray-800\" />\n            </div>\n            <div\n              v-if=\"\n                clipHasAudio(item, track) &&\n                shouldCollapseFades(item) &&\n                (item as any).audioFadeOutUs > 0\n              \"\n              class=\"w-3.5 h-3.5 rounded-full bg-white flex items-center justify-center shadow-sm\"\n              title=\"Fade Out\"\n            >\n              <UIcon name=\"i-heroicons-arrow-left\" class=\"w-2.5 h-2.5 text-gray-800\" />\n            </div>\n            <div\n              v-if=\"shouldCollapseTransitions(item) && (item as any).transitionIn\"\n              class=\"w-3.5 h-3.5 rounded-full bg-green-500 flex items-center justify-center shadow-sm\"\n              title=\"Transition In\"\n            >\n              <UIcon name=\"i-heroicons-arrow-right\" class=\"w-2.5 h-2.5 text-white\" />\n            </div>\n            <div\n              v-if=\"shouldCollapseTransitions(item) && (item as any).transitionOut\"\n              class=\"w-3.5 h-3.5 rounded-full bg-green-500 flex items-center justify-center shadow-sm\"\n              title=\"Transition Out\"\n            >\n              <UIcon name=\"i-heroicons-arrow-left\" class=\"w-2.5 h-2.5 text-white\" />\n            </div>\n          </div>\n\n          <!-- Volume Control Line -->\n          <div\n            v-if=\"item.kind === 'clip' && clipHasAudio(item, track)\"\n            class=\"absolute left-0 right-0 z-45 h-3 -mt-1.5 flex flex-col justify-center\"\n            :class=\"[\n              !Boolean((item as any).locked) ? 'cursor-ns-resize' : '',\n              (item as any).audioGain !== undefined && Math.abs((item as any).audioGain - 1) > 0.001\n                ? 'opacity-100'\n                : timelineStore.selectedItemIds.includes(item.id)\n                  ? 'opacity-100'\n                  : 'opacity-0 group-hover/clip:opacity-100',\n              ((props.draggingMode && props.draggingItemId === item.id) ||\n                props.movePreview?.itemId === item.id) &&\n              resizeVolume?.itemId !== item.id\n                ? 'opacity-0! pointer-events-none'\n                : '',\n            ]\"\n            :style=\"{\n              top: `${100 - (((item as any).audioGain ?? 1) / 2) * 100}%`,\n            }\"\n            @mousedown.stop=\"\n              !Boolean((item as any).locked) &&\n              startResizeVolume(\n                $event,\n                track.id,\n                item.id,\n                (item as any).audioGain ?? 1,\n                trackHeights[track.id] ?? DEFAULT_TRACK_HEIGHT,\n              )\n            \"\n          >\n            <div\n              class=\"w-full h-[1.5px] bg-yellow-400 pointer-events-none opacity-80\"\n              :class=\"getClipWidthPx(item) >= 15 ? 'group-hover/clip:opacity-100' : 'hidden'\"\n            ></div>\n\n            <div\n              class=\"absolute left-1/2 -translate-x-1/2 text-[10px] font-mono text-yellow-400 leading-none py-0.5 bg-black/60 px-1 rounded pointer-events-none select-none transition-opacity\"\n              :class=\"[\n                getClipWidthPx(item) < 30\n                  ? 'hidden'\n                  : resizeVolume?.itemId === item.id\n                    ? 'opacity-100 z-50'\n                    : 'opacity-0 group-hover/clip:opacity-100',\n                ((item as any).audioGain ?? 1) > 1 ? 'top-full mt-0.5' : 'bottom-full mb-0.5',\n              ]\"\n            >\n              {{ Math.round(((item as any).audioGain ?? 1) * 100) }}%\n            </div>\n          </div>\n\n          <!-- Speed Indicator -->\n          <div\n            v-if=\"item.kind === 'clip' && Math.abs(((item as any).speed ?? 1) - 1) > 0.0001\"\n            class=\"absolute top-0.5 right-0.5 px-1 py-0.5 rounded bg-(--overlay-bg) text-[10px] leading-none font-mono z-40\"\n          >\n            x{{ Number((item as any).speed ?? 1).toFixed(2) }}\n          </div>\n\n          <!-- Main Content Layer -->\n          <div class=\"flex-1 flex w-full min-h-0 relative z-20\">\n            <TimelineClipThumbnails\n              v-if=\"\n                item.kind === 'clip' && (item as any).clipType === 'media' && track.kind === 'video'\n              \"\n              :item=\"item as any\"\n              :width=\"getClipWidthPx(item)\"\n            />\n\n            <TimelineAudioWaveform\n              v-if=\"\n                item.kind === 'clip' && (item as any).clipType === 'media' && track.kind === 'audio'\n              \"\n              :item=\"item as any\"\n            />\n\n            <!-- Title Block (lowest layer, bottom center) -->\n            <div\n              v-if=\"item.kind === 'clip' && !shouldCollapseTransitions(item)\"\n              class=\"absolute bottom-0 left-0 right-0 flex items-end justify-center px-2 pb-0.5 z-0 pointer-events-none\"\n            >\n              <span class=\"truncate text-[10px] leading-tight opacity-70\" :title=\"item.name\">\n                {{ item.name }}\n              </span>\n            </div>\n\n            <!-- Transition In -->\n            <div\n              v-if=\"\n                item.kind === 'clip' &&\n                (item as any).transitionIn &&\n                !shouldCollapseTransitions(item)\n              \"\n              class=\"absolute left-0 top-0 bottom-0 z-10 transition-colors\"\n              :style=\"{\n                width: `${transitionUsToPx((item as any).transitionIn?.durationUs || 0)}px`,\n              }\"\n            >\n              <button\n                type=\"button\"\n                class=\"w-full h-full overflow-hidden group\"\n                :class=\"[\n                  selectedTransition?.itemId === item.id &&\n                  selectedTransition?.trackId === item.trackId &&\n                  selectedTransition?.edge === 'in'\n                    ? 'ring-2 ring-inset ring-amber-300 z-10'\n                    : hasTransitionInProblem(track, item)\n                      ? 'ring-2 ring-inset ring-orange-500 z-10'\n                      : '',\n                ]\"\n                :title=\"\n                  hasTransitionInProblem(track, item) ??\n                  `Transition In: ${(item as any).transitionIn?.type}`\n                \"\n                @click.stop=\"\n                  selectTransition($event, { trackId: item.trackId, itemId: item.id, edge: 'in' })\n                \"\n              >\n                <template v-if=\"!isCrossfadeTransitionIn(track, item as TimelineClipItem)\">\n                  <svg\n                    v-if=\"((item as any).transitionIn?.mode ?? 'blend') === 'blend'\"\n                    class=\"w-full h-full block\"\n                    preserveAspectRatio=\"none\"\n                    viewBox=\"0 0 100 100\"\n                  >\n                    <path\n                      :d=\"transitionSvgParts(100, 100, 'in')\"\n                      :fill=\"getClipLowerTriColor(item, track)\"\n                    />\n                  </svg>\n                  <template v-else>\n                    <div class=\"absolute inset-0 bg-linear-to-r from-transparent to-white/20\" />\n                    <span\n                      class=\"i-heroicons-squares-plus w-3 h-3 absolute inset-0 m-auto opacity-70\"\n                    />\n                  </template>\n                </template>\n                <!-- Problem indicator -->\n                <div\n                  v-if=\"hasTransitionInProblem(track, item)\"\n                  class=\"absolute top-0.5 right-0.5 w-2 h-2 rounded-full bg-orange-500 pointer-events-none z-20\"\n                />\n                <!-- Resize handle inside transition block -->\n                <div\n                  v-if=\"!Boolean((item as any).locked)\"\n                  class=\"absolute right-0 top-0 bottom-0 w-2 cursor-ew-resize bg-white/0 group-hover:bg-white/20 hover:bg-white/40! transition-colors z-40\"\n                  @mousedown.stop=\"\n                    startResizeTransition(\n                      $event,\n                      item.trackId,\n                      item.id,\n                      'in',\n                      (item as any).transitionIn?.durationUs ?? 500_000,\n                    )\n                  \"\n                />\n              </button>\n            </div>\n\n            <!-- Transition Out -->\n            <div\n              v-if=\"\n                item.kind === 'clip' &&\n                (item as any).transitionOut &&\n                !shouldCollapseTransitions(item)\n              \"\n              class=\"absolute right-0 top-0 bottom-0 z-10 transition-colors\"\n              :style=\"{\n                width: `${transitionUsToPx((item as any).transitionOut?.durationUs || 0)}px`,\n              }\"\n            >\n              <button\n                type=\"button\"\n                class=\"w-full h-full overflow-hidden group\"\n                :class=\"[\n                  selectedTransition?.itemId === item.id &&\n                  selectedTransition?.trackId === item.trackId &&\n                  selectedTransition?.edge === 'out'\n                    ? 'ring-2 ring-inset ring-amber-300 z-10'\n                    : hasTransitionOutProblem(track, item)\n                      ? 'ring-2 ring-inset ring-orange-500 z-10'\n                      : '',\n                ]\"\n                :title=\"\n                  hasTransitionOutProblem(track, item) ??\n                  `Transition Out: ${(item as any).transitionOut?.type}`\n                \"\n                @click.stop=\"\n                  selectTransition($event, { trackId: item.trackId, itemId: item.id, edge: 'out' })\n                \"\n              >\n                <svg\n                  v-if=\"((item as any).transitionOut?.mode ?? 'blend') === 'blend'\"\n                  class=\"w-full h-full block\"\n                  preserveAspectRatio=\"none\"\n                  viewBox=\"0 0 100 100\"\n                >\n                  <path\n                    :d=\"transitionSvgParts(100, 100, 'out')\"\n                    :fill=\"getClipLowerTriColor(item, track)\"\n                  />\n                </svg>\n                <template v-else>\n                  <div class=\"absolute inset-0 bg-linear-to-l from-transparent to-white/20\" />\n                  <span\n                    class=\"i-heroicons-squares-plus w-3 h-3 absolute inset-0 m-auto opacity-70\"\n                  />\n                </template>\n                <!-- Problem indicator -->\n                <div\n                  v-if=\"hasTransitionOutProblem(track, item)\"\n                  class=\"absolute top-0.5 right-0.5 w-2 h-2 rounded-full bg-orange-500 pointer-events-none z-20\"\n                />\n                <!-- Resize handle inside transition block -->\n                <div\n                  v-if=\"!Boolean((item as any).locked)\"\n                  class=\"absolute left-0 top-0 bottom-0 w-2 cursor-ew-resize bg-white/0 group-hover:bg-white/20 hover:bg-white/40! transition-colors z-40\"\n                  @mousedown.stop=\"\n                    startResizeTransition(\n                      $event,\n                      item.trackId,\n                      item.id,\n                      'out',\n                      (item as any).transitionOut?.durationUs ?? 500_000,\n                    )\n                  \"\n                />\n              </button>\n            </div>\n          </div>\n\n          <!-- Trim Handles (On top of everything, transparent by default) -->\n          <div\n            v-if=\"item.kind === 'clip' && !Boolean((item as any).locked)\"\n            class=\"absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-white/0 hover:bg-white/30 transition-colors z-50 group\"\n            @mousedown.stop=\"\n              emit('startTrimItem', $event, {\n                trackId: item.trackId,\n                itemId: item.id,\n                edge: 'start',\n                startUs: item.timelineRange.startUs,\n              })\n            \"\n          />\n          <div\n            v-if=\"item.kind === 'clip' && !Boolean((item as any).locked)\"\n            class=\"absolute right-0 top-0 bottom-0 w-1.5 cursor-ew-resize bg-white/0 hover:bg-white/30 transition-colors z-50 group\"\n            @mousedown.stop=\"\n              emit('startTrimItem', $event, {\n                trackId: item.trackId,\n                itemId: item.id,\n                edge: 'end',\n                startUs: item.timelineRange.startUs,\n              })\n            \"\n          />\n        </div>\n      </UContextMenu>\n    </div>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/timeline/audio/TimelineAudioWaveform.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/AppButtonGroup.vue","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":10,"messageId":"unexpectedAny","endLine":4,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[71,74],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[71,74],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":45,"messageId":"unexpectedAny","endLine":12,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[224,227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[224,227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'ui' requires default value to be set.","line":22,"column":5,"messageId":"missingDefault","endLine":22,"endColumn":14},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":10,"messageId":"unexpectedAny","endLine":22,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[722,725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[722,725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":32,"messageId":"unexpectedAny","endLine":37,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[994,997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[994,997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":19,"messageId":"unexpectedAny","endLine":38,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1018,1021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1018,1021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":28,"messageId":"unexpectedAny","endLine":47,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1219,1222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1219,1222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\ninterface Option {\n  label?: string;\n  value: any;\n  icon?: string;\n  disabled?: boolean;\n  title?: string;\n}\n\nconst props = withDefaults(\n  defineProps<{\n    modelValue: string | number | boolean | any;\n    options: Option[];\n    size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n    color?: 'neutral' | 'primary' | 'secondary' | 'success' | 'warning' | 'error' | 'info';\n    activeColor?: 'neutral' | 'primary' | 'secondary' | 'success' | 'warning' | 'error' | 'info';\n    variant?: 'solid' | 'outline' | 'soft' | 'ghost' | 'subtle';\n    activeVariant?: 'solid' | 'outline' | 'soft' | 'ghost' | 'subtle';\n    disabled?: boolean;\n    orientation?: 'horizontal' | 'vertical';\n    fluid?: boolean;\n    ui?: any;\n  }>(),\n  {\n    size: 'sm',\n    color: 'neutral',\n    activeColor: 'primary',\n    variant: 'outline',\n    activeVariant: 'solid',\n    disabled: false,\n    orientation: 'horizontal',\n    fluid: false,\n  },\n);\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: any];\n  change: [value: any];\n}>();\n\nfunction select(option: Option) {\n  if (props.disabled || option.disabled) return;\n  emit('update:modelValue', option.value);\n  emit('change', option.value);\n}\n\nfunction isSelected(value: any) {\n  return props.modelValue === value;\n}\n</script>\n\n<template>\n  <div\n    class=\"rounded-lg shadow-sm isolate\"\n    :class=\"[\n      orientation === 'horizontal' ? 'flex -space-x-px' : 'flex flex-col -space-y-px',\n      fluid ? 'w-full' : 'inline-flex',\n      disabled ? 'opacity-50 cursor-not-allowed' : '',\n    ]\"\n  >\n    <UButton\n      v-for=\"option in options\"\n      :key=\"String(option.value)\"\n      :label=\"option.label\"\n      :icon=\"option.icon\"\n      :size=\"size\"\n      :color=\"isSelected(option.value) ? activeColor : color\"\n      :variant=\"isSelected(option.value) ? activeVariant : variant\"\n      :disabled=\"disabled || option.disabled\"\n      :title=\"option.title\"\n      class=\"focus:z-10 rounded-none! transition-all duration-200 justify-center whitespace-normal h-auto py-1.5 px-2 text-xs\"\n      :class=\"[\n        !(disabled || option.disabled) ? 'cursor-pointer' : '',\n        orientation === 'horizontal'\n          ? 'first:rounded-s-lg! last:rounded-e-lg!'\n          : 'first:rounded-t-lg! last:rounded-b-lg!',\n        fluid ? 'flex-1 w-full' : '',\n      ]\"\n      @click=\"select(option)\"\n    >\n      <slot name=\"option\" :option=\"option\" :selected=\"isSelected(option.value)\" />\n    </UButton>\n  </div>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/AppModal.vue","messages":[{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'title' requires default value to be set.","line":13,"column":3,"messageId":"missingDefault","endLine":13,"endColumn":18},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'description' requires default value to be set.","line":15,"column":3,"messageId":"missingDefault","endLine":15,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":30,"messageId":"unexpectedAny","endLine":41,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1046,1049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1046,1049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\n/**\n * Unified Modal Component\n *\n * Provides a consistent layout with header, body, and footer across the application.\n * Wraps @nuxt/ui's UModal and provides standard padding and styling.\n */\n\nimport { DialogTitle, DialogDescription } from 'reka-ui';\n\ninterface Props {\n  /** Title of the modal */\n  title?: string;\n  /** Optional description text below the title */\n  description?: string;\n  /** Whether to show the close button in the top right corner */\n  closeButton?: boolean;\n  /** Whether to prevent closing when clicking outside or pressing ESC */\n  preventClose?: boolean;\n  /** Nuxt UI modal configuration */\n  ui?: {\n    content?: string;\n    body?: string;\n    header?: string;\n    footer?: string;\n    [key: string]: unknown;\n  };\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  closeButton: true,\n  preventClose: false,\n  ui: () => ({}),\n});\n\nconst isOpen = defineModel<boolean>('open', { default: false });\n\nconst { t } = useI18n();\n\nconst modalUi = computed(() => {\n  return (props.ui || {}) as any;\n});\n\nconst headerClass = computed(() => {\n  return props.ui?.header;\n});\n\nconst bodyClass = computed(() => {\n  return props.ui?.body;\n});\n\nconst footerClass = computed(() => {\n  return props.ui?.footer;\n});\n\nfunction handleClose(close?: () => void) {\n  if (close) {\n    close();\n    return;\n  }\n  isOpen.value = false;\n}\n</script>\n\n<template>\n  <UModal\n    v-model:open=\"isOpen\"\n    :dismissible=\"!props.preventClose\"\n    :title=\"props.title\"\n    :description=\"props.description\"\n    :ui=\"modalUi\"\n  >\n    <template #content=\"{ close }\">\n      <div\n        class=\"bg-ui-bg-elevated shadow-xl overflow-hidden sm:rounded-2xl border border-ui-border flex flex-col max-h-[90vh] min-h-0 w-full\"\n        :class=\"modalUi.content\"\n      >\n        <!-- Header -->\n        <div\n          v-if=\"props.title || $slots.header || props.closeButton\"\n          class=\"px-6 py-4 border-b border-ui-border flex items-center justify-between shrink-0\"\n          :class=\"headerClass\"\n        >\n          <div class=\"min-w-0 flex-1\">\n            <slot name=\"header\">\n              <DialogTitle v-if=\"props.title\" class=\"text-lg font-semibold text-ui-text truncate\">\n                {{ props.title }}\n              </DialogTitle>\n              <DialogDescription\n                :class=\"[props.description ? 'mt-1 text-sm text-ui-text-muted' : 'sr-only']\"\n              >\n                {{ props.description || props.title || 'Modal' }}\n              </DialogDescription>\n            </slot>\n          </div>\n\n          <UButton\n            v-if=\"props.closeButton\"\n            color=\"neutral\"\n            variant=\"ghost\"\n            icon=\"i-heroicons-x-mark\"\n            class=\"-mr-2 ml-4\"\n            size=\"md\"\n            :aria-label=\"t('common.close')\"\n            @click=\"handleClose(close)\"\n          />\n        </div>\n\n        <!-- Body -->\n        <div class=\"px-6 py-6 w-full overflow-y-auto flex-auto custom-scrollbar\" :class=\"bodyClass\">\n          <slot />\n        </div>\n\n        <!-- Footer -->\n        <div\n          v-if=\"$slots.footer\"\n          class=\"px-6 py-4 bg-ui-bg border-t border-ui-border flex justify-end gap-3 shrink-0\"\n          :class=\"footerClass\"\n        >\n          <slot name=\"footer\" />\n        </div>\n      </div>\n    </template>\n  </UModal>\n</template>\n\n<style scoped>\n@reference \"tailwindcss\";\n\n.custom-scrollbar::-webkit-scrollbar {\n  width: 6px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-track {\n  background: transparent;\n}\n\n.custom-scrollbar::-webkit-scrollbar-thumb {\n  background: var(--scrollbar-thumb);\n  border-radius: 9999px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-thumb:hover {\n  background: var(--scrollbar-thumb-hover);\n}\n</style>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/DurationSliderInput.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/TimelineZoomLogSlider.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/UiConfirmModal.vue","messages":[{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'description' requires default value to be set.","line":19,"column":3,"messageId":"missingDefault","endLine":19,"endColumn":24},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'confirmText' requires default value to be set.","line":20,"column":3,"messageId":"missingDefault","endLine":20,"endColumn":24},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'secondaryText' requires default value to be set.","line":21,"column":3,"messageId":"missingDefault","endLine":21,"endColumn":26},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'cancelText' requires default value to be set.","line":22,"column":3,"messageId":"missingDefault","endLine":22,"endColumn":23},{"ruleId":"vue/require-default-prop","severity":1,"message":"Prop 'icon' requires default value to be set.","line":25,"column":3,"messageId":"missingDefault","endLine":25,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport AppModal from '~/components/ui/AppModal.vue';\n\n// We define the specific colors supported by UButton to ensure type safety\ntype ButtonColor = 'primary' | 'secondary' | 'neutral' | 'error' | 'warning' | 'success' | 'info';\n\nconst {\n  title,\n  description,\n  confirmText,\n  secondaryText,\n  cancelText,\n  color = 'primary',\n  secondaryColor = 'neutral',\n  icon,\n  loading = false,\n} = defineProps<{\n  title: string;\n  description?: string;\n  confirmText?: string;\n  secondaryText?: string;\n  cancelText?: string;\n  color?: ButtonColor;\n  secondaryColor?: ButtonColor;\n  icon?: string;\n  loading?: boolean;\n}>();\n\nconst emit = defineEmits(['confirm', 'secondary']);\n\nconst isOpen = defineModel<boolean>('open', { required: true });\n\nconst { t } = useI18n();\n\nconst handleConfirm = () => {\n  // Use a slight delay to allow the active button click event to run to completion\n  // before the parent component tears down the modal DOM. This prevents \"Cannot read properties of null (reading nextSibling)\"\n  setTimeout(() => {\n    emit('confirm');\n  }, 0);\n};\n\nconst handleSecondary = () => {\n  setTimeout(() => {\n    emit('secondary');\n  }, 0);\n};\n\nconst handleClose = () => {\n  isOpen.value = false;\n};\n</script>\n\n<template>\n  <AppModal v-model:open=\"isOpen\" :title=\"title\" :ui=\"{ content: 'sm:max-w-lg' }\">\n    <div class=\"flex flex-col gap-4\">\n      <div v-if=\"icon || description\" class=\"flex gap-4\">\n        <div v-if=\"icon\" class=\"shrink-0\">\n          <UIcon\n            :name=\"icon\"\n            class=\"w-6 h-6\"\n            :class=\"{\n              'text-primary-500': color === 'primary',\n              'text-error-500': color === 'error',\n              'text-warning-500': color === 'warning',\n              'text-success-500': color === 'success',\n              'text-info-500': color === 'info',\n              'text-ui-text-muted': color === 'neutral' || color === 'secondary',\n            }\"\n          />\n        </div>\n        <div v-if=\"description\" class=\"flex-1\">\n          <p class=\"text-sm text-ui-text-muted\">\n            {{ description }}\n          </p>\n        </div>\n      </div>\n\n      <div v-if=\"$slots.default\" class=\"w-full\">\n        <slot />\n      </div>\n    </div>\n\n    <template #footer>\n      <UButton color=\"neutral\" variant=\"ghost\" @click=\"handleClose\">\n        {{ cancelText || t('common.cancel') }}\n      </UButton>\n      <UButton\n        v-if=\"secondaryText\"\n        :color=\"secondaryColor\"\n        variant=\"ghost\"\n        :disabled=\"loading\"\n        @click=\"handleSecondary\"\n      >\n        {{ secondaryText }}\n      </UButton>\n      <UButton :color=\"color\" :loading=\"loading\" @click=\"handleConfirm\">\n        {{ confirmText || t('common.confirm') }}\n      </UButton>\n    </template>\n  </AppModal>\n</template>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/components/ui/WheelSlider.vue","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/fileManager/useFileManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AUDIO_DIR_NAME' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"messageId":"unusedVar","endLine":13,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AUDIO_DIR_NAME"},"fix":{"range":[616,634],"text":""},"desc":"Remove unused variable \"AUDIO_DIR_NAME\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IMAGES_DIR_NAME' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"messageId":"unusedVar","endLine":14,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"IMAGES_DIR_NAME"},"fix":{"range":[634,653],"text":""},"desc":"Remove unused variable \"IMAGES_DIR_NAME\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FILES_DIR_NAME' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"messageId":"unusedVar","endLine":15,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"FILES_DIR_NAME"},"fix":{"range":[653,671],"text":""},"desc":"Remove unused variable \"FILES_DIR_NAME\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":17,"messageId":"unexpectedAny","endLine":61,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2163,2166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2163,2166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":57,"messageId":"unexpectedAny","endLine":140,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5206,5209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5206,5209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":24,"messageId":"unexpectedAny","endLine":193,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6711,6714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6711,6714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":331,"column":27,"messageId":"unexpectedAny","endLine":331,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11610,11613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11610,11613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":378,"column":54,"messageId":"unexpectedAny","endLine":378,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13042,13045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13042,13045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":569,"column":39,"messageId":"dynamicDelete","endLine":569,"endColumn":46},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":570,"column":39,"messageId":"dynamicDelete","endLine":570,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed, toRaw, markRaw, watch, type Ref } from 'vue';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useUiStore } from '~/stores/ui.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport { useProxyStore } from '~/stores/proxy.store';\nimport { useSelectionStore } from '~/stores/selection.store';\nimport { useFocusStore } from '~/stores/focus.store';\nimport { useTimelineMediaUsageStore } from '~/stores/timeline-media-usage.store';\nimport { convertSvgToPng } from '~/utils/svg';\nimport {\n  VIDEO_DIR_NAME,\n  AUDIO_DIR_NAME,\n  IMAGES_DIR_NAME,\n  FILES_DIR_NAME,\n  TIMELINES_DIR_NAME,\n} from '~/utils/constants';\nimport { getClipThumbnailsHash, thumbnailGenerator } from '~/utils/thumbnail-generator';\nimport type { FsEntry } from '~/types/fs';\nimport { isMoveAllowed as isMoveAllowedCore } from '~/file-manager/core/rules';\nimport { findEntryByPath as findEntryByPathCore } from '~/file-manager/core/tree';\nimport { createFileManagerService } from '~/file-manager/application/fileManagerService';\nimport {\n  createFolderCommand,\n  createTimelineCommand,\n  deleteEntryCommand,\n  handleFilesCommand,\n  moveEntryCommand,\n  renameEntryCommand,\n  resolveDefaultTargetDir,\n} from '~/file-manager/application/fileManagerCommands';\n\ntype FileTreeSortMode = 'name' | 'modified';\n\nexport function isMoveAllowed(params: { sourcePath: string; targetDirPath: string }): boolean {\n  return isMoveAllowedCore(params);\n}\n\ninterface UiActionRunnerState {\n  isLoading: Ref<boolean>;\n  error: Ref<string | null>;\n}\n\ninterface UiActionRunnerDeps {\n  toast: ReturnType<typeof useToast>;\n}\n\nfunction createUiActionRunner(state: UiActionRunnerState, deps: UiActionRunnerDeps) {\n  return async function runWithUiFeedback<T>(params: {\n    action: () => Promise<T>;\n    defaultErrorMessage: string;\n    toastTitle: string;\n    toastDescription?: () => string;\n    ignoreError?: (e: unknown) => boolean;\n    rethrow?: boolean;\n  }): Promise<T | null> {\n    state.error.value = null;\n    state.isLoading.value = true;\n    try {\n      return await params.action();\n    } catch (e: any) {\n      if (params.ignoreError?.(e)) {\n        return null;\n      }\n\n      state.error.value = e?.message ?? params.defaultErrorMessage;\n      deps.toast.add({\n        color: 'red',\n        title: params.toastTitle,\n        description:\n          params.toastDescription?.() ?? (state.error.value || params.defaultErrorMessage),\n      });\n\n      if (params.rethrow) throw e;\n      return null;\n    } finally {\n      state.isLoading.value = false;\n    }\n  };\n}\n\nexport interface FileManagerCreateDeps {\n  t: ReturnType<typeof useI18n>['t'];\n  toast: ReturnType<typeof useToast>;\n  isApiSupported: Ref<boolean>;\n  rootEntries: Ref<FsEntry[]>;\n  sortMode: Ref<FileTreeSortMode>;\n  showHiddenFiles: Ref<boolean>;\n  isFileTreePathExpanded: (path: string) => boolean;\n  setFileTreePathExpanded: (path: string, expanded: boolean) => void;\n  getExpandedPaths: () => string[];\n  getProjectRootDirHandle: () => Promise<FileSystemDirectoryHandle | null>;\n  getProjectDirHandle: () => Promise<FileSystemDirectoryHandle | null>;\n  getProjectName: () => string | null;\n  getProjectId: () => string | null;\n  getProjectSize: () => { width: number; height: number };\n  onMediaImported: (params: {\n    fileHandle: FileSystemFileHandle;\n    projectRelativePath: string;\n  }) => void;\n  proxy: {\n    checkExistingProxies: (paths: string[]) => Promise<void>;\n    deleteProxy: (path: string) => Promise<void>;\n    clearExistingProxies: () => void;\n  };\n  thumbnails: {\n    clearVideoThumbnails: (params: {\n      projectId: string;\n      projectRelativePath: string;\n    }) => Promise<void>;\n  };\n  onEntryPathChanged?: (params: { oldPath: string; newPath: string }) => void | Promise<void>;\n  onDirectoryMoved?: () => void | Promise<void>;\n}\n\nexport function createFileManager(deps: FileManagerCreateDeps) {\n  const isLoading = ref(false);\n  const error = ref<string | null>(null);\n  const runWithUiFeedback = createUiActionRunner({ isLoading, error }, { toast: deps.toast });\n  const timelineMediaUsageStore = useTimelineMediaUsageStore();\n\n  const service = createFileManagerService({\n    rootEntries: deps.rootEntries,\n    sortMode: deps.sortMode,\n    showHiddenFiles: () => deps.showHiddenFiles.value,\n    hasPersistedFileTreeState: () => {\n      const projectName = deps.getProjectName();\n      if (!projectName) return false;\n      const uiStore = useUiStore();\n      return uiStore.hasPersistedFileTreeState(projectName);\n    },\n    isPathExpanded: (path) => deps.isFileTreePathExpanded(path),\n    setPathExpanded: (path, expanded) => deps.setFileTreePathExpanded(path, expanded),\n    getExpandedPaths: () => deps.getExpandedPaths(),\n    sanitizeHandle: <T extends object>(handle: T) => markRaw(toRaw(handle)) as unknown as T,\n    sanitizeParentHandle: (handle) => markRaw(toRaw(handle)),\n    checkExistingProxies: (videoPaths) => deps.proxy.checkExistingProxies(videoPaths),\n    onError: (params: { title?: string; message: string; error?: unknown }) => {\n      const description = params.error\n        ? `${params.message}: ${String((params.error as any)?.message ?? params.error)}`\n        : params.message;\n      deps.toast.add({\n        color: 'red',\n        title: params.title ?? 'File manager error',\n        description,\n      });\n    },\n  });\n\n  watch(\n    () => deps.showHiddenFiles.value,\n    () => {\n      void loadProjectDirectory();\n    },\n  );\n\n  function findEntryByPath(path: string): FsEntry | null {\n    return service.findEntryByPath(path);\n  }\n\n  function mergeEntries(prev: FsEntry[] | undefined, next: FsEntry[]): FsEntry[] {\n    return service.mergeEntries(prev, next);\n  }\n\n  async function toggleDirectory(entry: FsEntry) {\n    if (entry.kind !== 'directory') return;\n    await runWithUiFeedback({\n      action: async () => {\n        await service.toggleDirectory(entry);\n      },\n      defaultErrorMessage: 'Failed to read folder',\n      toastTitle: 'Folder error',\n      toastDescription: () => error.value || 'Failed to read folder',\n      ignoreError: () => false,\n    });\n  }\n\n  async function loadProjectDirectory() {\n    const projectDir = await deps.getProjectDirHandle();\n    if (!projectDir) {\n      deps.rootEntries.value = [];\n      void timelineMediaUsageStore.refreshUsage();\n      return;\n    }\n\n    await runWithUiFeedback({\n      action: async () => {\n        await service.loadProjectDirectory(projectDir);\n      },\n      defaultErrorMessage: 'Failed to open project folder',\n      toastTitle: 'Project error',\n      toastDescription: () => error.value || 'Failed to open project folder',\n      ignoreError: (e: any) => e?.name === 'AbortError',\n    });\n\n    void timelineMediaUsageStore.refreshUsage();\n  }\n\n  async function handleFiles(\n    files: FileList | File[],\n    targetDirHandle?: FileSystemDirectoryHandle,\n    targetDirPath?: string,\n  ) {\n    const projectName = deps.getProjectName();\n    if (!projectName) return;\n    const projectDir = await deps.getProjectDirHandle();\n    if (!projectDir) return;\n\n    await runWithUiFeedback({\n      action: async () => {\n        await handleFilesCommand(\n          files,\n          {\n            targetDirHandle: targetDirHandle ? toRaw(targetDirHandle) : undefined,\n            targetDirPath,\n          },\n          {\n            getProjectDirHandle: async () => projectDir,\n            getTargetDirHandle: async ({ projectDir: pd, file }) =>\n              await resolveDefaultTargetDir({ projectDir: pd, file }),\n            convertSvgToPng: async (file) =>\n              await convertSvgToPng(file, {\n                maxWidth: deps.getProjectSize().width,\n                maxHeight: deps.getProjectSize().height,\n              }),\n            onSvgConvertError: ({ file, error: e }) => {\n              console.warn('Failed to convert SVG to PNG', e);\n              error.value = `Failed to import SVG: ${file.name}`;\n              deps.toast.add({\n                color: 'red',\n                title: 'SVG Import Error',\n                description: error.value,\n              });\n            },\n            onSkipProjectFile: ({ file }) => {\n              deps.toast.add({\n                color: 'neutral',\n                title: deps.t('videoEditor.fileManager.skipOtio.title', 'Project files skipped'),\n                description: deps.t(\n                  'videoEditor.fileManager.skipOtio.description',\n                  `${file.name} is a project file and cannot be imported this way. Use Create Timeline instead.`,\n                ),\n              });\n            },\n            onMediaImported: ({ fileHandle, projectRelativePath }) => {\n              deps.onMediaImported({\n                fileHandle: fileHandle as FileSystemFileHandle,\n                projectRelativePath,\n              });\n            },\n          },\n        );\n\n        await loadProjectDirectory();\n      },\n      defaultErrorMessage: 'Failed to upload files',\n      toastTitle: 'Upload error',\n      toastDescription: () => error.value || 'Failed to upload files',\n    });\n  }\n\n  async function createFolder(name: string, targetEntry: FileSystemDirectoryHandle | null = null) {\n    const projectName = deps.getProjectName();\n    if (!projectName) return;\n\n    await runWithUiFeedback({\n      action: async () => {\n        const baseDir = targetEntry || (await deps.getProjectDirHandle());\n        if (!baseDir) return;\n        await createFolderCommand({ name, baseDir });\n        await loadProjectDirectory();\n      },\n      defaultErrorMessage: 'Failed to create folder',\n      toastTitle: 'Folder error',\n      toastDescription: () => error.value || 'Failed to create folder',\n    });\n  }\n\n  async function deleteEntry(target: FsEntry) {\n    await runWithUiFeedback({\n      action: async () => {\n        await deleteEntryCommand(target, {\n          removeEntry: async ({ parentHandle, name, recursive }) => {\n            const parent = toRaw(parentHandle);\n            await parent.removeEntry(name, { recursive });\n          },\n          onFileDeleted: async ({ path }) => {\n            await deps.proxy.deleteProxy(path);\n\n            if (path.startsWith(`${VIDEO_DIR_NAME}/`)) {\n              const projectId = deps.getProjectId();\n              if (projectId) {\n                await deps.thumbnails.clearVideoThumbnails({\n                  projectId,\n                  projectRelativePath: path,\n                });\n              }\n            }\n          },\n        });\n\n        await loadProjectDirectory();\n      },\n      defaultErrorMessage: 'Failed to delete',\n      toastTitle: 'Delete error',\n      toastDescription: () => error.value || 'Failed to delete',\n    });\n  }\n\n  async function renameEntry(target: FsEntry, newName: string) {\n    if (!target.parentHandle) return;\n\n    const oldPath = target.path;\n    const parentPath = oldPath ? oldPath.split('/').slice(0, -1).join('/') : '';\n    const newPath = oldPath ? (parentPath ? `${parentPath}/${newName}` : newName) : '';\n\n    await runWithUiFeedback({\n      action: async () => {\n        await renameEntryCommand(\n          { target, newName },\n          {\n            ensureTargetNameDoesNotExist: async ({ parentHandle, kind, newName: nn }) => {\n              const parent = toRaw(parentHandle);\n              try {\n                if (kind === 'file') {\n                  await parent.getFileHandle(nn);\n                } else {\n                  await parent.getDirectoryHandle(nn);\n                }\n                throw new Error(`Target name already exists: ${nn}`);\n              } catch (e: any) {\n                if (e?.name !== 'NotFoundError') throw e;\n              }\n            },\n            removeEntry: async ({ parentHandle, name, recursive }) => {\n              const parent = toRaw(parentHandle);\n              await parent.removeEntry(name, { recursive });\n            },\n          },\n        );\n\n        if (oldPath && newPath) {\n          await deps.onEntryPathChanged?.({ oldPath, newPath });\n        }\n\n        await loadProjectDirectory();\n      },\n      defaultErrorMessage: 'Failed to rename',\n      toastTitle: 'Rename error',\n      toastDescription: () => error.value || 'Failed to rename',\n    });\n  }\n\n  async function moveEntry(params: {\n    source: FsEntry;\n    targetDirHandle: FileSystemDirectoryHandle;\n    targetDirPath: string;\n  }) {\n    const projectName = deps.getProjectName();\n    if (!projectName) return;\n    if (!params.source.parentHandle) return;\n\n    const sourcePath = params.source.path ?? '';\n    const targetDirPath = params.targetDirPath ?? '';\n    if (!sourcePath) return;\n\n    const sourceParentPath = sourcePath.split('/').slice(0, -1).join('/');\n    if (sourceParentPath === targetDirPath) return;\n\n    if (!isMoveAllowed({ sourcePath, targetDirPath })) return;\n\n    await runWithUiFeedback({\n      action: async () => {\n        await moveEntryCommand(\n          {\n            source: {\n              ...params.source,\n              handle: toRaw(params.source.handle) as any,\n              parentHandle: params.source.parentHandle\n                ? toRaw(params.source.parentHandle)\n                : undefined,\n            },\n            targetDirHandle: toRaw(params.targetDirHandle),\n            targetDirPath,\n          },\n          {\n            removeEntry: async ({ parentHandle, name, recursive }) => {\n              const parent = toRaw(parentHandle);\n              await parent.removeEntry(name, { recursive });\n            },\n            onFileMoved: async ({ oldPath, newPath }) => {\n              await deps.onEntryPathChanged?.({ oldPath, newPath });\n\n              if (oldPath.startsWith(`${VIDEO_DIR_NAME}/`)) {\n                await deps.proxy.deleteProxy(oldPath);\n                deps.proxy.clearExistingProxies();\n\n                const projectId = deps.getProjectId();\n                if (projectId) {\n                  await deps.thumbnails.clearVideoThumbnails({\n                    projectId,\n                    projectRelativePath: oldPath,\n                  });\n                }\n\n                await deps.proxy.checkExistingProxies([newPath]);\n              }\n            },\n            onDirectoryMoved: async () => {\n              await deps.onDirectoryMoved?.();\n              deps.proxy.clearExistingProxies();\n            },\n          },\n        );\n\n        await loadProjectDirectory();\n      },\n      defaultErrorMessage: 'Failed to move',\n      toastTitle: 'Move error',\n      toastDescription: () => error.value || 'Failed to move',\n      rethrow: true,\n    });\n  }\n\n  async function createTimeline(): Promise<string | null> {\n    const projectDir = await deps.getProjectDirHandle();\n    if (!projectDir) return null;\n\n    return await runWithUiFeedback({\n      action: async () => {\n        const createdPath = await createTimelineCommand({\n          projectDir,\n          timelinesDirName: TIMELINES_DIR_NAME,\n        });\n        await loadProjectDirectory();\n        return createdPath;\n      },\n      defaultErrorMessage: 'Failed to create timeline',\n      toastTitle: 'Timeline error',\n      toastDescription: () => error.value || 'Failed to create timeline',\n    });\n  }\n\n  function getFileIcon(entry: FsEntry): string {\n    if (entry.kind === 'directory') return 'i-heroicons-folder';\n    const ext = entry.name.split('.').pop()?.toLowerCase() ?? '';\n    if (['mp4', 'mov', 'avi', 'mkv', 'webm'].includes(ext)) return 'i-heroicons-film';\n    if (['mp3', 'wav', 'aac', 'flac', 'ogg'].includes(ext)) return 'i-heroicons-musical-note';\n    if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'avif'].includes(ext))\n      return 'i-heroicons-photo';\n    if (ext === 'otio') return 'i-heroicons-document-text';\n    return 'i-heroicons-document';\n  }\n\n  return {\n    rootEntries: deps.rootEntries,\n    isLoading,\n    error,\n    isApiSupported: deps.isApiSupported,\n    getProjectRootDirHandle: deps.getProjectRootDirHandle,\n    sortMode: deps.sortMode,\n    setSortMode: (v: FileTreeSortMode) => {\n      deps.sortMode.value = v;\n    },\n    loadProjectDirectory,\n    toggleDirectory,\n    handleFiles,\n    createFolder,\n    deleteEntry,\n    renameEntry,\n    findEntryByPath,\n    mergeEntries,\n    moveEntry,\n    createTimeline,\n    getFileIcon,\n  };\n}\n\nexport function useFileManager() {\n  const { t } = useI18n();\n  const toast = useToast();\n  const workspaceStore = useWorkspaceStore();\n  const projectStore = useProjectStore();\n  const uiStore = useUiStore();\n  const mediaStore = useMediaStore();\n  const proxyStore = useProxyStore();\n  const selectionStore = useSelectionStore();\n  const focusStore = useFocusStore();\n\n  const rootEntries = ref<FsEntry[]>([]);\n  const sortMode = ref<FileTreeSortMode>('name');\n\n  const isApiSupported = computed(() => workspaceStore.isApiSupported);\n  const showHiddenFiles = computed(() => uiStore.showHiddenFiles);\n\n  function updateSelectionPath(params: { oldPath: string; newPath: string }) {\n    if (uiStore.selectedFsEntry?.path === params.oldPath) {\n      uiStore.selectedFsEntry = {\n        ...uiStore.selectedFsEntry,\n        path: params.newPath,\n        name: params.newPath.split('/').pop() ?? uiStore.selectedFsEntry.name,\n      };\n      focusStore.setTempFocus('left');\n    }\n\n    if (\n      selectionStore.selectedEntity?.source === 'fileManager' &&\n      selectionStore.selectedEntity.path === params.oldPath\n    ) {\n      const updatedEntry = findEntryByPathCore(rootEntries.value, params.newPath);\n      if (updatedEntry) {\n        selectionStore.selectFsEntry(updatedEntry);\n      }\n    }\n  }\n\n  const api = createFileManager({\n    t,\n    toast,\n    isApiSupported,\n    rootEntries,\n    sortMode,\n    showHiddenFiles,\n    isFileTreePathExpanded: (path) => uiStore.isFileTreePathExpanded(path),\n    setFileTreePathExpanded: (path, expanded) => {\n      const projectName = projectStore.currentProjectName;\n      if (!projectName) return;\n      uiStore.setFileTreePathExpanded(projectName, path, expanded);\n    },\n    getExpandedPaths: () => Object.keys(uiStore.fileTreeExpandedPaths),\n    getProjectRootDirHandle: async () => {\n      if (!workspaceStore.projectsHandle || !projectStore.currentProjectName) return null;\n      return await workspaceStore.projectsHandle.getDirectoryHandle(\n        projectStore.currentProjectName,\n      );\n    },\n    getProjectDirHandle: async () => {\n      if (!workspaceStore.projectsHandle || !projectStore.currentProjectName) return null;\n      return await workspaceStore.projectsHandle.getDirectoryHandle(\n        projectStore.currentProjectName,\n      );\n    },\n    getProjectName: () => projectStore.currentProjectName,\n    getProjectId: () => projectStore.currentProjectId,\n    getProjectSize: () => ({\n      width: projectStore.projectSettings.project.width,\n      height: projectStore.projectSettings.project.height,\n    }),\n    onMediaImported: ({ fileHandle, projectRelativePath }) => {\n      void mediaStore.getOrFetchMetadata(fileHandle, projectRelativePath);\n    },\n    proxy: {\n      checkExistingProxies: async (paths) => await proxyStore.checkExistingProxies(paths),\n      deleteProxy: async (path) => await proxyStore.deleteProxy(path),\n      clearExistingProxies: () => proxyStore.existingProxies.clear(),\n    },\n    thumbnails: {\n      clearVideoThumbnails: async ({ projectId, projectRelativePath }) => {\n        await thumbnailGenerator.clearThumbnails({\n          projectId,\n          hash: getClipThumbnailsHash({\n            projectId,\n            projectRelativePath,\n          }),\n        });\n      },\n    },\n    onEntryPathChanged: async ({ oldPath, newPath }) => {\n      delete mediaStore.mediaMetadata[oldPath];\n      delete mediaStore.mediaMetadata[newPath];\n      updateSelectionPath({ oldPath, newPath });\n    },\n    onDirectoryMoved: async () => {\n      mediaStore.resetMediaState();\n    },\n  });\n\n  return api;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/monitor/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/monitor/useMonitorCore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":22,"messageId":"unexpectedAny","endLine":34,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1207,1210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1207,1210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":30,"messageId":"unexpectedAny","endLine":208,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6452,6455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6452,6455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":34,"messageId":"unexpectedAny","endLine":215,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6755,6758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6755,6758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":29,"messageId":"unexpectedAny","endLine":217,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6851,6854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6851,6854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":218,"column":30,"messageId":"unexpectedAny","endLine":218,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6891,6894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6891,6894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":21,"messageId":"unexpectedAny","endLine":219,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6923,6926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6923,6926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":30,"messageId":"unexpectedAny","endLine":231,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7289,7292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7289,7292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":34,"messageId":"unexpectedAny","endLine":232,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7334,7337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7334,7337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":37,"messageId":"unexpectedAny","endLine":233,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7386,7389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7386,7389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":38,"messageId":"unexpectedAny","endLine":234,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7442,7445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7442,7445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":235,"column":39,"messageId":"unexpectedAny","endLine":235,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7500,7503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7500,7503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":34,"messageId":"unexpectedAny","endLine":242,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7812,7815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7812,7815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":21,"messageId":"unexpectedAny","endLine":243,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7848,7851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7848,7851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":89,"messageId":"unexpectedAny","endLine":246,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7955,7958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7955,7958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":94,"messageId":"unexpectedAny","endLine":247,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8054,8057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8054,8057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":282,"column":33,"messageId":"unexpectedAny","endLine":282,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9526,9529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9526,9529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":283,"column":37,"messageId":"unexpectedAny","endLine":283,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9574,9577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9574,9577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":40,"messageId":"unexpectedAny","endLine":284,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9629,9632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9629,9632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":41,"messageId":"unexpectedAny","endLine":285,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9688,9691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9688,9691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":42,"messageId":"unexpectedAny","endLine":286,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9749,9752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9749,9752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":422,"column":26,"messageId":"unexpectedAny","endLine":422,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13691,13694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13691,13694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":429,"column":30,"messageId":"unexpectedAny","endLine":429,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13966,13969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13966,13969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":431,"column":25,"messageId":"unexpectedAny","endLine":431,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14054,14057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14054,14057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":432,"column":26,"messageId":"unexpectedAny","endLine":432,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14090,14093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14090,14093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":433,"column":17,"messageId":"unexpectedAny","endLine":433,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14118,14121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14118,14121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":443,"column":33,"messageId":"unexpectedAny","endLine":443,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14407,14410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14407,14410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":444,"column":26,"messageId":"unexpectedAny","endLine":444,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14451,14454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14451,14454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":30,"messageId":"unexpectedAny","endLine":445,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14492,14495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14492,14495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":446,"column":34,"messageId":"unexpectedAny","endLine":446,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14541,14544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14541,14544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":35,"messageId":"unexpectedAny","endLine":447,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14595,14598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14595,14598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":454,"column":30,"messageId":"unexpectedAny","endLine":454,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14879,14882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14879,14882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":455,"column":17,"messageId":"unexpectedAny","endLine":455,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14911,14914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14911,14914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":458,"column":85,"messageId":"unexpectedAny","endLine":458,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15010,15013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15010,15013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":90,"messageId":"unexpectedAny","endLine":459,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15105,15108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15105,15108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":515,"column":33,"messageId":"unexpectedAny","endLine":515,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17094,17097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17094,17097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":516,"column":37,"messageId":"unexpectedAny","endLine":516,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17142,17145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17142,17145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":517,"column":40,"messageId":"unexpectedAny","endLine":517,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17197,17200],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17197,17200],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":518,"column":41,"messageId":"unexpectedAny","endLine":518,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17256,17259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17256,17259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":519,"column":42,"messageId":"unexpectedAny","endLine":519,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17317,17320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17317,17320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":538,"column":17,"messageId":"unexpectedAny","endLine":538,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17998,18001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17998,18001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":40,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed, onBeforeUnmount, onMounted, ref, watch } from 'vue';\nimport type { Ref } from 'vue';\n\nimport { AudioEngine } from '~/utils/video-editor/AudioEngine';\nimport { clampTimeUs, normalizeTimeUs } from '~/utils/monitor-time';\nimport { getPreviewWorkerClient, setPreviewHostApi } from '~/utils/video-editor/worker-client';\nimport { toWorkerTimelineClips } from '~/composables/timeline/useTimelineExport';\n\nimport type { WorkerTimelineClip } from './types';\n\ninterface MonitorTimelineState {\n  videoItems: Ref<unknown[]>;\n  rawWorkerTimelineClips?: Ref<WorkerTimelineClip[]>;\n  rawWorkerAudioClips?: Ref<WorkerTimelineClip[]>;\n  workerTimelineClips: Ref<WorkerTimelineClip[]>;\n  workerAudioClips: Ref<WorkerTimelineClip[]>;\n  safeDurationUs: Ref<number>;\n  clipSourceSignature: Ref<number>;\n  clipLayoutSignature: Ref<number>;\n  audioClipSourceSignature: Ref<number>;\n  audioClipLayoutSignature: Ref<number>;\n}\n\ninterface MonitorDisplayState {\n  containerEl: Ref<HTMLDivElement | null>;\n  viewportEl: Ref<HTMLDivElement | null>;\n  renderWidth: Ref<number>;\n  renderHeight: Ref<number>;\n  updateCanvasDisplaySize: () => void;\n}\n\ninterface MonitorStoreState {\n  projectStore: {\n    projectSettings: any;\n    getFileHandleByPath: (path: string) => Promise<FileSystemFileHandle | null>;\n  };\n  timelineStore: {\n    duration: number;\n    currentTime: number;\n    isPlaying: boolean;\n    audioVolume: number;\n    audioMuted: boolean;\n  };\n  proxyStore: {\n    getProxyFileHandle: (path: string) => Promise<FileSystemFileHandle | null>;\n  };\n}\n\nexport interface UseMonitorCoreOptions extends MonitorStoreState {\n  monitorTimeline: MonitorTimelineState;\n  monitorDisplay: MonitorDisplayState;\n}\n\nexport function useMonitorCore(options: UseMonitorCoreOptions) {\n  const { t } = useI18n();\n  const { projectStore, timelineStore, proxyStore, monitorTimeline, monitorDisplay } = options;\n\n  const {\n    rawWorkerTimelineClips,\n    rawWorkerAudioClips,\n    workerTimelineClips,\n    workerAudioClips,\n    safeDurationUs,\n    clipSourceSignature,\n    clipLayoutSignature,\n    audioClipSourceSignature,\n    audioClipLayoutSignature,\n  } = monitorTimeline;\n\n  const { containerEl, viewportEl, renderWidth, renderHeight, updateCanvasDisplaySize } =\n    monitorDisplay;\n\n  const isLoading = ref(false);\n  const loadError = ref<string | null>(null);\n\n  const BUILD_DEBOUNCE_MS = 120;\n  const LAYOUT_DEBOUNCE_MS = 50;\n\n  let viewportResizeObserver: ResizeObserver | null = null;\n  let buildRequestId = 0;\n  let lastBuiltSourceSignature = 0;\n  let lastBuiltLayoutSignature = 0;\n  let canvasEl: HTMLCanvasElement | null = null;\n  let compositorReady = false;\n  let compositorWidth = 0;\n  let compositorHeight = 0;\n  let buildInFlight = false;\n  let buildRequested = false;\n  let buildDebounceTimer: number | null = null;\n  let layoutDebounceTimer: number | null = null;\n  let layoutUpdateInFlight = false;\n  let pendingLayoutClips: WorkerTimelineClip[] | null = null;\n  let pendingLayoutAudioClips: WorkerTimelineClip[] | null = null;\n  let renderLoopInFlight = false;\n  let latestRenderTimeUs: number | null = null;\n  let isUnmounted = false;\n  let forceRecreateCompositorNextBuild = false;\n  let currentTimeProvider: (() => number) | null = null;\n  const audioHandleCache = new Map<string, FileSystemFileHandle>();\n\n  const audioEngine = new AudioEngine();\n  const { client } = getPreviewWorkerClient();\n\n  const useProxyInMonitor = computed(() => {\n    return projectStore.projectSettings.monitor?.useProxy !== false;\n  });\n\n  function cloneWorkerPayload<T>(value: T): T {\n    try {\n      if (typeof structuredClone === 'function') {\n        return structuredClone(value);\n      }\n    } catch {\n      // ignore and fallback\n    }\n    return value;\n  }\n\n  function setCurrentTimeProvider(provider: () => number) {\n    currentTimeProvider = provider;\n  }\n\n  function computeAudioDurationUs(clips: WorkerTimelineClip[]): number {\n    let maxEnd = 0;\n    for (const clip of clips) {\n      const end = clip.timelineRange.startUs + clip.timelineRange.durationUs;\n      if (end > maxEnd) maxEnd = end;\n    }\n    return maxEnd;\n  }\n\n  function getAudioSourceKey(path: string) {\n    return `${useProxyInMonitor.value ? 'proxy' : 'source'}:${path}`;\n  }\n\n  async function getFileHandleForAudio(path: string) {\n    const cacheKey = getAudioSourceKey(path);\n    const cached = audioHandleCache.get(cacheKey);\n    if (cached) return cached;\n    if (useProxyInMonitor.value) {\n      const proxyHandle = await proxyStore.getProxyFileHandle(path);\n      if (proxyHandle) {\n        audioHandleCache.set(cacheKey, proxyHandle);\n        return proxyHandle;\n      }\n    }\n    const handle = await projectStore.getFileHandleByPath(path);\n    if (!handle) return null;\n    audioHandleCache.set(cacheKey, handle);\n    return handle;\n  }\n\n  async function flushBuildQueue() {\n    if (buildInFlight) return;\n\n    buildInFlight = true;\n    try {\n      while (buildRequested && !isUnmounted) {\n        buildRequested = false;\n        await buildTimeline();\n      }\n    } finally {\n      buildInFlight = false;\n    }\n  }\n\n  function scheduleLayoutUpdate(\n    layoutClips: WorkerTimelineClip[],\n    audioClips: WorkerTimelineClip[],\n  ) {\n    pendingLayoutClips = layoutClips;\n    pendingLayoutAudioClips = audioClips;\n    if (layoutDebounceTimer !== null) {\n      clearTimeout(layoutDebounceTimer);\n    }\n    layoutDebounceTimer = window.setTimeout(() => {\n      layoutDebounceTimer = null;\n      void flushLayoutUpdateQueue();\n    }, LAYOUT_DEBOUNCE_MS);\n  }\n\n  function getRenderTimeForLayoutUpdate() {\n    if (currentTimeProvider) return currentTimeProvider();\n    return clampToTimeline(timelineStore.currentTime);\n  }\n\n  async function flushLayoutUpdateQueue() {\n    if (layoutUpdateInFlight || isUnmounted) return;\n\n    layoutUpdateInFlight = true;\n    try {\n      while (pendingLayoutClips && pendingLayoutAudioClips) {\n        const layoutClips = pendingLayoutClips;\n        const layoutAudioClips = pendingLayoutAudioClips;\n        pendingLayoutClips = null;\n        pendingLayoutAudioClips = null;\n        try {\n          const mockItems = layoutClips.map(\n            (c) =>\n              ({\n                kind: 'clip',\n                clipType:\n                  c.clipType === 'media' && c.source?.path?.endsWith('.otio')\n                    ? 'timeline'\n                    : c.clipType,\n                id: c.id,\n                layer: c.layer,\n                speed: (c as any).speed,\n                source: c.source,\n                timelineRange: c.timelineRange,\n                sourceRange: c.sourceRange,\n                freezeFrameSourceUs: c.freezeFrameSourceUs,\n                opacity: c.opacity,\n                effects: c.effects,\n                transform: (c as any).transform,\n                backgroundColor: c.backgroundColor,\n                text: (c as any).text,\n                style: (c as any).style,\n              }) as any,\n          );\n\n          const mockAudioItems = layoutAudioClips.map(\n            (c) =>\n              ({\n                kind: 'clip',\n                clipType:\n                  c.clipType === 'media' && c.source?.path?.endsWith('.otio')\n                    ? 'timeline'\n                    : c.clipType,\n                id: c.id,\n                speed: (c as any).speed,\n                audioGain: (c as any).audioGain,\n                audioBalance: (c as any).audioBalance,\n                audioFadeInUs: (c as any).audioFadeInUs,\n                audioFadeOutUs: (c as any).audioFadeOutUs,\n                source: c.source,\n                timelineRange: c.timelineRange,\n                sourceRange: c.sourceRange,\n                freezeFrameSourceUs: c.freezeFrameSourceUs,\n                opacity: c.opacity,\n                effects: c.effects,\n                transform: (c as any).transform,\n              }) as any,\n          );\n\n          const flattenedClips = await toWorkerTimelineClips(mockItems, projectStore as any);\n          const flattenedAudio = await toWorkerTimelineClips(mockAudioItems, projectStore as any);\n\n          workerTimelineClips.value = flattenedClips;\n          workerAudioClips.value = flattenedAudio;\n\n          const payload = cloneWorkerPayload(flattenedClips);\n          const maxDuration = await client.updateTimelineLayout(payload);\n          const audioDuration = computeAudioDurationUs(flattenedAudio);\n          timelineStore.duration = Math.max(maxDuration, audioDuration);\n          lastBuiltLayoutSignature = clipLayoutSignature.value;\n          scheduleRender(getRenderTimeForLayoutUpdate());\n        } catch (error) {\n          console.error('[Monitor] Failed to update timeline layout', error);\n          timelineStore.isPlaying = false;\n          scheduleBuild();\n        }\n      }\n\n      const audioClips = workerAudioClips.value;\n      const audioEngineClips = (\n        await Promise.all(\n          audioClips.map(async (clip) => {\n            try {\n              const path = clip.source?.path;\n              if (!path) return null;\n              const handle = await getFileHandleForAudio(path);\n              if (!handle) return null;\n              return {\n                id: clip.id,\n                sourcePath: getAudioSourceKey(path),\n                fileHandle: handle,\n                startUs: clip.timelineRange.startUs,\n                durationUs: clip.timelineRange.durationUs,\n                sourceStartUs: clip.sourceRange.startUs,\n                sourceDurationUs: clip.sourceRange.durationUs,\n                speed: (clip as any).speed,\n                audioGain: (clip as any).audioGain,\n                audioBalance: (clip as any).audioBalance,\n                audioFadeInUs: (clip as any).audioFadeInUs,\n                audioFadeOutUs: (clip as any).audioFadeOutUs,\n              };\n            } catch {\n              return null;\n            }\n          }),\n        )\n      ).filter((it): it is NonNullable<typeof it> => Boolean(it));\n\n      audioEngine.updateTimelineLayout(audioEngineClips);\n    } finally {\n      layoutUpdateInFlight = false;\n    }\n  }\n\n  function scheduleBuild() {\n    if (buildDebounceTimer !== null) {\n      clearTimeout(buildDebounceTimer);\n    }\n    buildDebounceTimer = window.setTimeout(() => {\n      buildDebounceTimer = null;\n      buildRequested = true;\n      void flushBuildQueue();\n    }, BUILD_DEBOUNCE_MS);\n  }\n\n  function scheduleRender(timeUs: number) {\n    if (isUnmounted) return;\n    latestRenderTimeUs = normalizeTimeUs(timeUs);\n    if (renderLoopInFlight) return;\n\n    renderLoopInFlight = true;\n    const run = async () => {\n      try {\n        while (latestRenderTimeUs !== null) {\n          if (isUnmounted) {\n            latestRenderTimeUs = null;\n            break;\n          }\n          const nextTimeUs = latestRenderTimeUs;\n          latestRenderTimeUs = null;\n          await client.renderFrame(nextTimeUs);\n        }\n      } catch (err) {\n        console.error('[Monitor] Render failed', err);\n      } finally {\n        renderLoopInFlight = false;\n        if (latestRenderTimeUs !== null) {\n          scheduleRender(latestRenderTimeUs);\n        }\n      }\n    };\n\n    void run();\n  }\n\n  function updateStoreTime(timeUs: number) {\n    const normalizedTimeUs = clampToTimeline(timeUs);\n    if (timelineStore.currentTime === normalizedTimeUs) {\n      return;\n    }\n    timelineStore.currentTime = normalizedTimeUs;\n  }\n\n  function clampToTimeline(timeUs: number): number {\n    return clampTimeUs(timeUs, safeDurationUs.value);\n  }\n\n  async function ensureCompositorReady(options?: { forceRecreate?: boolean }) {\n    if (!containerEl.value) {\n      return;\n    }\n\n    const shouldRecreate = options?.forceRecreate ?? false;\n    const targetWidth = renderWidth.value;\n    const targetHeight = renderHeight.value;\n    const needReinit =\n      !compositorReady ||\n      compositorWidth !== targetWidth ||\n      compositorHeight !== targetHeight ||\n      shouldRecreate;\n\n    if (!needReinit) {\n      return;\n    }\n\n    if (shouldRecreate || !canvasEl || needReinit) {\n      const container = containerEl.value;\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n      canvasEl = document.createElement('canvas');\n      canvasEl.style.width = `${targetWidth}px`;\n      canvasEl.style.height = `${targetHeight}px`;\n      canvasEl.style.display = 'block';\n      containerEl.value.appendChild(canvasEl);\n      compositorReady = false;\n    }\n\n    if (!canvasEl) {\n      return;\n    }\n\n    canvasEl.width = targetWidth;\n    canvasEl.height = targetHeight;\n    canvasEl.style.width = `${targetWidth}px`;\n    canvasEl.style.height = `${targetHeight}px`;\n    const offscreen = canvasEl.transferControlToOffscreen();\n    await client.destroyCompositor();\n    await client.initCompositor(offscreen, targetWidth, targetHeight, '#000');\n    compositorReady = true;\n    compositorWidth = targetWidth;\n    compositorHeight = targetHeight;\n  }\n\n  async function buildTimeline() {\n    if (!containerEl.value) return;\n    const requestId = ++buildRequestId;\n    isLoading.value = true;\n    loadError.value = null;\n\n    try {\n      await ensureCompositorReady({ forceRecreate: forceRecreateCompositorNextBuild });\n      forceRecreateCompositorNextBuild = false;\n\n      const rawClips = rawWorkerTimelineClips?.value ?? workerTimelineClips.value;\n      const rawAudio = rawWorkerAudioClips?.value ?? workerAudioClips.value;\n\n      const mockItems = rawClips.map(\n        (c) =>\n          ({\n            kind: 'clip',\n            clipType:\n              c.clipType === 'media' && c.source?.path?.endsWith('.otio') ? 'timeline' : c.clipType,\n            id: c.id,\n            layer: c.layer,\n            speed: (c as any).speed,\n            source: c.source,\n            timelineRange: c.timelineRange,\n            sourceRange: c.sourceRange,\n            freezeFrameSourceUs: c.freezeFrameSourceUs,\n            opacity: c.opacity,\n            effects: c.effects,\n            transform: (c as any).transform,\n            backgroundColor: c.backgroundColor,\n            text: (c as any).text,\n            style: (c as any).style,\n          }) as any,\n      );\n\n      const mockAudioItems = rawAudio.map(\n        (c) =>\n          ({\n            kind: 'clip',\n            clipType:\n              c.clipType === 'media' && c.source?.path?.endsWith('.otio') ? 'timeline' : c.clipType,\n            id: c.id,\n            audioBalance: (c as any).audioBalance,\n            speed: (c as any).speed,\n            audioGain: (c as any).audioGain,\n            audioFadeInUs: (c as any).audioFadeInUs,\n            audioFadeOutUs: (c as any).audioFadeOutUs,\n            source: c.source,\n            timelineRange: c.timelineRange,\n            sourceRange: c.sourceRange,\n            freezeFrameSourceUs: c.freezeFrameSourceUs,\n            opacity: c.opacity,\n            effects: c.effects,\n            transform: (c as any).transform,\n          }) as any,\n      );\n\n      const flattenedClips = await toWorkerTimelineClips(mockItems, projectStore as any);\n      const flattenedAudio = await toWorkerTimelineClips(mockAudioItems, projectStore as any);\n\n      workerTimelineClips.value = flattenedClips;\n      workerAudioClips.value = flattenedAudio;\n\n      const clips = flattenedClips;\n      const audioClips = flattenedAudio;\n      const audioDuration = computeAudioDurationUs(audioClips);\n\n      if (clips.length === 0 && audioClips.length === 0) {\n        await client.clearClips();\n        await audioEngine.loadClips([]);\n        timelineStore.duration = 0;\n        updateStoreTime(0);\n        isLoading.value = false;\n        return;\n      }\n\n      setPreviewHostApi({\n        getFileHandleByPath: async (path) => {\n          if (useProxyInMonitor.value) {\n            const proxyHandle = await proxyStore.getProxyFileHandle(path);\n            if (proxyHandle) return proxyHandle;\n          }\n          return await projectStore.getFileHandleByPath(path);\n        },\n        onExportProgress: () => {},\n      });\n\n      const payload = cloneWorkerPayload(clips);\n      const maxDuration = clips.length > 0 ? await client.loadTimeline(payload) : 0;\n      if (clips.length === 0) {\n        await client.clearClips();\n      }\n\n      await audioEngine.init({\n        sampleRate: projectStore.projectSettings?.project?.sampleRate,\n        audioChannels: projectStore.projectSettings?.project?.audioChannels,\n      });\n\n      const audioEngineClips = (\n        await Promise.all(\n          audioClips.map(async (clip) => {\n            try {\n              const path = clip.source?.path;\n              if (!path) return null;\n              const handle = await getFileHandleForAudio(path);\n              if (!handle) return null;\n              return {\n                id: clip.id,\n                sourcePath: getAudioSourceKey(path),\n                fileHandle: handle,\n                startUs: clip.timelineRange.startUs,\n                durationUs: clip.timelineRange.durationUs,\n                sourceStartUs: clip.sourceRange.startUs,\n                sourceDurationUs: clip.sourceRange.durationUs,\n                speed: (clip as any).speed,\n                audioGain: (clip as any).audioGain,\n                audioBalance: (clip as any).audioBalance,\n                audioFadeInUs: (clip as any).audioFadeInUs,\n                audioFadeOutUs: (clip as any).audioFadeOutUs,\n              };\n            } catch {\n              return null;\n            }\n          }),\n        )\n      ).filter((it): it is NonNullable<typeof it> => Boolean(it));\n      await audioEngine.loadClips(audioEngineClips);\n\n      lastBuiltSourceSignature = clipSourceSignature.value;\n      lastBuiltLayoutSignature = clipLayoutSignature.value;\n\n      timelineStore.duration = normalizeTimeUs(Math.max(maxDuration, audioDuration));\n      updateStoreTime(timelineStore.currentTime);\n      timelineStore.isPlaying = false;\n\n      // Render at current time to avoid surprising playhead jumps.\n      scheduleRender(getRenderTimeForLayoutUpdate());\n    } catch (e: any) {\n      console.error('Failed to build timeline components', e);\n      if (requestId === buildRequestId) {\n        loadError.value =\n          e.message || t('granVideoEditor.monitor.loadError', 'Error loading timeline');\n      }\n    } finally {\n      if (requestId === buildRequestId) {\n        isLoading.value = false;\n      }\n    }\n  }\n\n  watch(clipSourceSignature, () => {\n    scheduleBuild();\n  });\n\n  watch(audioClipSourceSignature, () => {\n    scheduleBuild();\n  });\n\n  watch(\n    () => useProxyInMonitor.value,\n    () => {\n      if (isUnmounted) return;\n\n      timelineStore.isPlaying = false;\n      audioHandleCache.clear();\n      forceRecreateCompositorNextBuild = true;\n      compositorReady = false;\n      scheduleBuild();\n    },\n  );\n\n  watch(clipLayoutSignature, () => {\n    if (isLoading.value || !compositorReady) {\n      return;\n    }\n    if (clipSourceSignature.value !== lastBuiltSourceSignature) {\n      return;\n    }\n    if (clipLayoutSignature.value === lastBuiltLayoutSignature) {\n      return;\n    }\n\n    const layoutClips = rawWorkerTimelineClips?.value ?? workerTimelineClips.value;\n    const layoutAudioClips = rawWorkerAudioClips?.value ?? workerAudioClips.value;\n    scheduleLayoutUpdate(layoutClips, layoutAudioClips);\n  });\n\n  watch(audioClipLayoutSignature, () => {\n    if (isLoading.value || !compositorReady) {\n      return;\n    }\n\n    const layoutClips = rawWorkerTimelineClips?.value ?? workerTimelineClips.value;\n    const layoutAudioClips = rawWorkerAudioClips?.value ?? workerAudioClips.value;\n    scheduleLayoutUpdate(layoutClips, layoutAudioClips);\n  });\n\n  watch(\n    () => [timelineStore.audioVolume, timelineStore.audioMuted],\n    () => {\n      const effectiveVolume = timelineStore.audioMuted ? 0 : timelineStore.audioVolume;\n      audioEngine.setVolume(effectiveVolume);\n    },\n    { immediate: true },\n  );\n\n  watch(\n    () => [\n      projectStore.projectSettings?.project?.width ?? 0,\n      projectStore.projectSettings?.project?.height ?? 0,\n      projectStore.projectSettings?.monitor?.previewResolution ?? 0,\n    ],\n    () => {\n      updateCanvasDisplaySize();\n      compositorReady = false;\n      scheduleBuild();\n    },\n  );\n\n  onMounted(() => {\n    isUnmounted = false;\n    updateCanvasDisplaySize();\n    if (typeof ResizeObserver !== 'undefined' && viewportEl.value) {\n      let scheduled = false;\n      viewportResizeObserver = new ResizeObserver(() => {\n        if (scheduled) return;\n        scheduled = true;\n        requestAnimationFrame(() => {\n          scheduled = false;\n          updateCanvasDisplaySize();\n        });\n      });\n      viewportResizeObserver.observe(viewportEl.value);\n    }\n    scheduleBuild();\n  });\n\n  onBeforeUnmount(() => {\n    isUnmounted = true;\n    timelineStore.isPlaying = false;\n    latestRenderTimeUs = null;\n    if (buildDebounceTimer !== null) {\n      clearTimeout(buildDebounceTimer);\n      buildDebounceTimer = null;\n    }\n    if (layoutDebounceTimer !== null) {\n      clearTimeout(layoutDebounceTimer);\n    }\n\n    try {\n      audioEngine.destroy();\n    } catch (err) {\n      console.error('[Monitor] Failed to destroy AudioEngine', err);\n    }\n\n    viewportResizeObserver?.disconnect();\n    viewportResizeObserver = null;\n    pendingLayoutClips = null;\n    pendingLayoutAudioClips = null;\n    void client.destroyCompositor().catch((error) => {\n      console.error('[Monitor] Failed to destroy compositor on unmount', error);\n    });\n  });\n\n  return {\n    audioEngine,\n    clampToTimeline,\n    isLoading,\n    loadError,\n    scheduleBuild,\n    scheduleRender,\n    setCurrentTimeProvider,\n    updateStoreTime,\n    useProxyInMonitor,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/monitor/useMonitorDisplay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/monitor/useMonitorPlayback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/monitor/useMonitorTimeline.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clampNumber' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"messageId":"unusedVar","endLine":6,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"clampNumber"},"fix":{"range":[282,294],"text":""},"desc":"Remove unused variable \"clampNumber\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":29,"messageId":"unexpectedAny","endLine":54,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2066,2069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2066,2069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":22,"messageId":"unexpectedAny","endLine":68,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2557,2560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2557,2560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":35,"messageId":"unexpectedAny","endLine":70,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2617,2620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2617,2620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":41,"messageId":"unexpectedAny","endLine":84,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3193,3196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3193,3196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":31,"messageId":"unexpectedAny","endLine":88,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3350,3353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3350,3353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":53,"messageId":"unexpectedAny","endLine":89,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3418,3421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3418,3421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":54,"messageId":"unexpectedAny","endLine":90,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3491,3494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3491,3494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":33,"messageId":"unexpectedAny","endLine":102,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3901,3904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3901,3904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":46,"messageId":"unexpectedAny","endLine":116,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4344,4347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4344,4347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":35,"messageId":"unexpectedAny","endLine":121,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4514,4517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4514,4517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":29,"messageId":"unexpectedAny","endLine":122,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4560,4563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4560,4563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":39,"messageId":"unexpectedAny","endLine":156,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5436,5439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5436,5439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":57,"messageId":"unexpectedAny","endLine":215,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7348,7351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7348,7351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":52,"messageId":"unexpectedAny","endLine":219,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7600,7603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7600,7603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":29,"messageId":"unexpectedAny","endLine":220,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7665,7668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7665,7668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":59,"messageId":"unexpectedAny","endLine":221,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7751,7754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7751,7754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":34,"messageId":"unexpectedAny","endLine":222,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7804,7807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7804,7807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":57,"messageId":"unexpectedAny","endLine":243,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8646,8649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8646,8649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":40,"messageId":"unexpectedAny","endLine":252,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8996,8999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8996,8999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":52,"messageId":"unexpectedAny","endLine":254,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9072,9075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9072,9075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":77,"messageId":"unexpectedAny","endLine":254,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9097,9100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9097,9100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":36,"messageId":"unexpectedAny","endLine":259,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9264,9267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9264,9267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":36,"messageId":"unexpectedAny","endLine":265,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9468,9471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9468,9471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":271,"column":22,"messageId":"unexpectedAny","endLine":271,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9614,9617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9614,9617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":59,"messageId":"unexpectedAny","endLine":272,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9700,9703],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9700,9703],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":273,"column":34,"messageId":"unexpectedAny","endLine":273,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9753,9756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9753,9756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":46,"messageId":"unexpectedAny","endLine":279,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9925,9928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9925,9928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":37,"messageId":"unexpectedAny","endLine":280,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9976,9979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9976,9979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":68,"messageId":"unexpectedAny","endLine":281,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10061,10064],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10061,10064],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":49,"messageId":"unexpectedAny","endLine":306,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10877,10880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10877,10880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":307,"column":52,"messageId":"unexpectedAny","endLine":307,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10960,10963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10960,10963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":318,"column":40,"messageId":"unexpectedAny","endLine":318,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11396,11399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11396,11399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":40,"messageId":"unexpectedAny","endLine":320,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11460,11463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11460,11463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":321,"column":40,"messageId":"unexpectedAny","endLine":321,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11527,11530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11527,11530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":57,"messageId":"unexpectedAny","endLine":322,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11614,11617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11614,11617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":323,"column":57,"messageId":"unexpectedAny","endLine":323,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11698,11701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11698,11701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":40,"messageId":"unexpectedAny","endLine":355,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12772,12775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12772,12775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":38,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computed } from 'vue';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport type { TimelineTrack, TimelineTrackItem } from '~/timeline/types';\nimport type { WorkerTimelineClip } from './types';\nimport { normalizeTimeUs } from '~/utils/monitor-time';\nimport { clampNumber, mergeBalance, mergeGain } from '~/utils/audio/envelope';\nimport { buildEffectiveAudioClipItems } from '~/utils/audio/track-bus';\n\nexport function useMonitorTimeline() {\n  const timelineStore = useTimelineStore();\n\n  const videoTracks = computed(\n    () =>\n      (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined)?.filter(\n        (track: TimelineTrack) => track.kind === 'video',\n      ) ?? [],\n  );\n  const audioTracks = computed(\n    () =>\n      (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined)?.filter(\n        (track: TimelineTrack) => track.kind === 'audio',\n      ) ?? [],\n  );\n\n  const videoItems = computed(() =>\n    videoTracks.value\n      .filter((track) => !track.videoHidden)\n      .flatMap((track) =>\n        (track.items ?? []).filter((it: TimelineTrackItem) => it.kind === 'clip'),\n      ),\n  );\n\n  const audioItems = computed(() =>\n    audioTracks.value\n      .flatMap((track) => track.items)\n      .filter((it: TimelineTrackItem) => it.kind === 'clip'),\n  );\n\n  const rawWorkerTimelineClips = computed(() => {\n    const docTracks = (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [];\n    const clips: WorkerTimelineClip[] = [];\n    const videoTracks = docTracks.filter((track) => track.kind === 'video' && !track.videoHidden);\n    const trackCount = videoTracks.length;\n\n    function sanitizeSpeed(raw: unknown): number | undefined {\n      if (raw === undefined) return undefined;\n      const v = Number(raw);\n      if (!Number.isFinite(v)) return undefined;\n      return Math.max(0.1, Math.min(10, v));\n    }\n\n    function sanitizeTransition(raw: unknown): { type: string; durationUs: number } | undefined {\n      if (!raw || typeof raw !== 'object') return undefined;\n      const anyRaw = raw as any;\n      const type = typeof anyRaw.type === 'string' ? anyRaw.type : '';\n      const durationUs = Number(anyRaw.durationUs);\n      if (!type) return undefined;\n      if (!Number.isFinite(durationUs)) return undefined;\n      return {\n        type,\n        durationUs: Math.max(0, Math.round(durationUs)),\n      };\n    }\n\n    for (const [trackIndex, track] of videoTracks.entries()) {\n      for (const item of track.items) {\n        if (item.kind !== 'clip') continue;\n        if ((item as any).disabled) continue;\n\n        const clipType = (item as any).clipType ?? 'media';\n\n        const clipEffects = item.effects ? JSON.parse(JSON.stringify(item.effects)) : undefined;\n        const trackEffects = track.effects ? JSON.parse(JSON.stringify(track.effects)) : undefined;\n        const effects =\n          clipEffects && trackEffects\n            ? [...clipEffects, ...trackEffects]\n            : (clipEffects ?? trackEffects);\n\n        const base: WorkerTimelineClip = {\n          kind: 'clip',\n          clipType,\n          id: item.id,\n          layer: trackCount - 1 - trackIndex,\n          speed: sanitizeSpeed((item as any).speed) ?? 1,\n          freezeFrameSourceUs: item.freezeFrameSourceUs,\n          opacity: item.opacity,\n          effects,\n          transform: (item as any).transform,\n          transitionIn: sanitizeTransition((item as any).transitionIn),\n          transitionOut: sanitizeTransition((item as any).transitionOut),\n          timelineRange: {\n            startUs: item.timelineRange.startUs,\n            durationUs: item.timelineRange.durationUs,\n          },\n          sourceRange: {\n            startUs: item.sourceRange.startUs,\n            durationUs: item.sourceRange.durationUs,\n          },\n        };\n\n        if (clipType === 'media' || clipType === 'timeline') {\n          const path = (item as any).source?.path;\n          if (!path) continue;\n          if (clipType === 'timeline') {\n            clips.push({\n              ...base,\n              source: { path },\n              clipType: 'media',\n            });\n          } else {\n            clips.push({ ...base, source: { path } });\n          }\n        } else if (clipType === 'background') {\n          clips.push({\n            ...base,\n            backgroundColor: String((item as any).backgroundColor ?? '#000000'),\n          });\n        } else if (clipType === 'text') {\n          clips.push({\n            ...base,\n            text: String((item as any).text ?? ''),\n            style: (item as any).style,\n          });\n        } else {\n          clips.push(base);\n        }\n      }\n    }\n    return clips;\n  });\n\n  const rawWorkerAudioClips = computed(() => {\n    const clips: WorkerTimelineClip[] = [];\n\n    function sanitizeSpeed(raw: unknown): number {\n      const v = Number(raw);\n      if (!Number.isFinite(v)) return 1;\n      return Math.max(0.1, Math.min(10, v));\n    }\n\n    const effectiveItems = buildEffectiveAudioClipItems({\n      audioTracks: audioTracks.value,\n      videoTracks: videoTracks.value,\n    });\n\n    for (const item of effectiveItems) {\n      if (item.kind !== 'clip') continue;\n      if (item.clipType !== 'media' && item.clipType !== 'timeline') continue;\n      if (!item.source?.path) continue;\n\n      clips.push({\n        kind: 'clip',\n        clipType: 'media',\n        id: item.id,\n        layer: 0,\n        speed: sanitizeSpeed((item as any).speed),\n        audioGain: item.audioGain,\n        audioBalance: item.audioBalance,\n        audioFadeInUs: item.audioFadeInUs,\n        audioFadeOutUs: item.audioFadeOutUs,\n        source: {\n          path: item.source.path,\n        },\n        timelineRange: {\n          startUs: item.timelineRange.startUs,\n          durationUs: item.timelineRange.durationUs,\n        },\n        sourceRange: {\n          startUs: item.sourceRange.startUs,\n          durationUs: item.sourceRange.durationUs,\n        },\n      });\n    }\n\n    return clips;\n  });\n\n  const workerTimelineClips = ref<WorkerTimelineClip[]>([]);\n  const workerAudioClips = ref<WorkerTimelineClip[]>([]);\n\n  const safeDurationUs = computed(() => normalizeTimeUs(timelineStore.duration));\n\n  function hashString(value: string): number {\n    let hash = 2166136261;\n    for (let index = 0; index < value.length; index += 1) {\n      hash ^= value.charCodeAt(index);\n      hash = Math.imul(hash, 16777619);\n    }\n    return hash >>> 0;\n  }\n\n  function mixHash(hash: number, value: number): number {\n    hash ^= value;\n    hash = Math.imul(hash, 16777619);\n    return hash >>> 0;\n  }\n\n  function mixTime(hash: number, value: number): number {\n    const safeValue = Number.isFinite(value) ? Math.round(value) : 0;\n    const low = safeValue >>> 0;\n    const high = Math.floor(safeValue / 0x1_0000_0000) >>> 0;\n    return mixHash(mixHash(hash, low), high);\n  }\n\n  function mixFloat(hash: number, value: unknown, scale = 1000): number {\n    const n = typeof value === 'number' && Number.isFinite(value) ? value : 0;\n    return mixTime(hash, Math.round(n * scale));\n  }\n\n  const clipSourceSignature = computed(() => {\n    let hash = mixHash(2166136261, videoItems.value.length);\n    for (const item of videoItems.value) {\n      hash = mixHash(hash, hashString(item.id));\n      if (item.kind === 'clip') {\n        hash = mixHash(hash, hashString(String((item as any).clipType ?? '')));\n        if (item.clipType === 'media' && item.source?.path) {\n          hash = mixHash(hash, hashString(item.source.path));\n        } else if (item.clipType === 'background') {\n          hash = mixHash(hash, hashString((item as any).backgroundColor ?? '#000000'));\n        } else if ((item as any).clipType === 'text') {\n          hash = mixHash(hash, hashString(String((item as any).text ?? '')));\n          const style = (item as any).style;\n          if (style) {\n            hash = mixHash(hash, hashString(JSON.stringify(style)));\n          }\n        }\n      }\n    }\n    return hash;\n  });\n\n  const clipLayoutSignature = computed(() => {\n    let hash = mixHash(2166136261, videoItems.value.length);\n    const docTracks = (timelineStore.timelineDoc?.tracks as TimelineTrack[] | undefined) ?? [];\n    const videoTracks = docTracks.filter((t) => t.kind === 'video' && !t.videoHidden);\n    const trackById = new Map<string, TimelineTrack>(videoTracks.map((t) => [t.id, t]));\n\n    for (const item of videoItems.value) {\n      hash = mixHash(hash, hashString(item.id));\n      hash = mixTime(hash, item.timelineRange.startUs);\n      hash = mixTime(hash, item.timelineRange.durationUs);\n      if (item.kind === 'clip') {\n        hash = mixHash(hash, hashString(String((item as any).clipType ?? '')));\n        hash = mixTime(hash, item.sourceRange.startUs);\n        hash = mixTime(hash, item.sourceRange.durationUs);\n\n        if (item.clipType === 'media') {\n          hash = mixTime(hash, item.freezeFrameSourceUs ?? 0);\n        }\n\n        hash = mixFloat(hash, item.opacity ?? 1, 1000);\n        hash = mixFloat(hash, (item as any).speed ?? 1, 1000);\n\n        const clipEffects = Array.isArray((item as any).effects) ? (item as any).effects : null;\n        if (clipEffects) {\n          hash = mixHash(hash, hashString(JSON.stringify(clipEffects)));\n        }\n\n        const transform = (item as any).transform;\n        if (transform) {\n          hash = mixHash(hash, hashString(JSON.stringify(transform)));\n        }\n\n        if (item.clipType === 'background') {\n          const bgColor = (item as any).backgroundColor;\n          if (bgColor) {\n            hash = mixHash(hash, hashString(bgColor));\n          }\n        }\n\n        if ((item as any).clipType === 'text') {\n          hash = mixHash(hash, hashString(String((item as any).text ?? '')));\n          const style = (item as any).style;\n          if (style) {\n            hash = mixHash(hash, hashString(JSON.stringify(style)));\n          }\n        }\n\n        const track = trackById.get((item as any).trackId);\n        if (Array.isArray((track as any)?.effects)) {\n          hash = mixHash(hash, hashString(JSON.stringify((track as any).effects)));\n        }\n      }\n    }\n    return hash;\n  });\n\n  const audioClipLayoutSignature = computed(() => {\n    const allAudioTracks = audioTracks.value;\n    const allVideoTracks = videoTracks.value;\n\n    const hasSolo = [...allAudioTracks, ...allVideoTracks].some((t) => Boolean(t.audioSolo));\n\n    const effectiveItems = buildEffectiveAudioClipItems({\n      audioTracks: allAudioTracks,\n      videoTracks: allVideoTracks,\n    });\n\n    let hash = mixHash(2166136261, effectiveItems.length);\n    hash = mixHash(hash, hasSolo ? 1 : 0);\n    for (const track of [...allAudioTracks, ...allVideoTracks]) {\n      hash = mixHash(hash, hashString(track.id));\n      hash = mixHash(hash, track.audioMuted ? 1 : 0);\n      hash = mixHash(hash, track.audioSolo ? 1 : 0);\n\n      hash = mixFloat(hash, mergeGain((track as any).audioGain, 1) ?? 1, 1000);\n      hash = mixFloat(hash, mergeBalance((track as any).audioBalance, 0) ?? 0, 1000);\n    }\n\n    for (const item of effectiveItems) {\n      hash = mixHash(hash, hashString(item.id));\n      hash = mixTime(hash, item.timelineRange.startUs);\n      hash = mixTime(hash, item.timelineRange.durationUs);\n      if (item.kind === 'clip') {\n        hash = mixTime(hash, item.sourceRange.startUs);\n        hash = mixTime(hash, item.sourceRange.durationUs);\n\n        hash = mixFloat(hash, (item as any).speed ?? 1, 1000);\n\n        hash = mixFloat(hash, (item as any).audioGain ?? 1, 1000);\n        hash = mixFloat(hash, (item as any).audioBalance ?? 0, 1000);\n        hash = mixTime(hash, Math.round(Number((item as any).audioFadeInUs ?? 0)));\n        hash = mixTime(hash, Math.round(Number((item as any).audioFadeOutUs ?? 0)));\n      }\n    }\n    return hash;\n  });\n\n  const audioClipSourceSignature = computed(() => {\n    const allAudioTracks = audioTracks.value;\n    const allVideoTracks = videoTracks.value;\n\n    const hasSolo = [...allAudioTracks, ...allVideoTracks].some((t) => Boolean(t.audioSolo));\n\n    const effectiveItems = buildEffectiveAudioClipItems({\n      audioTracks: allAudioTracks,\n      videoTracks: allVideoTracks,\n    });\n\n    let hash = mixHash(2166136261, effectiveItems.length);\n    hash = mixHash(hash, hasSolo ? 1 : 0);\n    for (const track of [...allAudioTracks, ...allVideoTracks]) {\n      hash = mixHash(hash, hashString(track.id));\n      hash = mixHash(hash, track.audioMuted ? 1 : 0);\n      hash = mixHash(hash, track.audioSolo ? 1 : 0);\n    }\n\n    for (const item of effectiveItems) {\n      hash = mixHash(hash, hashString(item.id));\n      if (item.kind === 'clip') {\n        if (item.clipType === 'media' && item.source?.path) {\n          hash = mixHash(hash, hashString(item.source.path));\n        }\n\n        hash = mixFloat(hash, (item as any).speed ?? 1, 1000);\n      }\n    }\n    return hash;\n  });\n\n  return {\n    videoTracks,\n    videoItems,\n    audioTracks,\n    audioItems,\n    workerTimelineClips,\n    workerAudioClips,\n    safeDurationUs,\n    clipSourceSignature,\n    clipLayoutSignature,\n    audioClipSourceSignature,\n    audioClipLayoutSignature,\n    rawWorkerTimelineClips,\n    rawWorkerAudioClips,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/timeline/useTimelineExport.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolveVideoCodecOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"messageId":"unusedVar","endLine":26,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"resolveVideoCodecOptions"},"fix":{"range":[876,904],"text":""},"desc":"Remove unused variable \"resolveVideoCodecOptions\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":21,"messageId":"unexpectedAny","endLine":81,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2287,2290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2287,2290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":18,"messageId":"unexpectedAny","endLine":176,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5486,5489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5486,5489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":31,"messageId":"unexpectedAny","endLine":178,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5542,5545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5542,5545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":26,"messageId":"unexpectedAny","endLine":194,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6183,6186],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6183,6186],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":78,"messageId":"unexpectedAny","endLine":194,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6235,6238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6235,6238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":33,"messageId":"unexpectedAny","endLine":195,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6279,6282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6279,6282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":23,"messageId":"unexpectedAny","endLine":197,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6329,6332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6329,6332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":27,"messageId":"unexpectedAny","endLine":198,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6367,6370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6367,6370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":30,"messageId":"unexpectedAny","endLine":199,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6412,6415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6412,6415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":31,"messageId":"unexpectedAny","endLine":200,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6461,6464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6461,6464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":32,"messageId":"unexpectedAny","endLine":201,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6512,6515],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6512,6515],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":204,"column":27,"messageId":"unexpectedAny","endLine":204,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6664,6667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6664,6667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":29,"messageId":"unexpectedAny","endLine":216,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7025,7028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7025,7028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":53,"messageId":"unexpectedAny","endLine":294,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10350,10353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10350,10353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":296,"column":34,"messageId":"unexpectedAny","endLine":296,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10475,10478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10475,10478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":50,"messageId":"unexpectedAny","endLine":301,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10741,10744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10741,10744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":51,"messageId":"unexpectedAny","endLine":306,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11038,11041],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11038,11041],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":377,"column":51,"messageId":"unexpectedAny","endLine":377,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14176,14179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14176,14179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":32,"messageId":"unexpectedAny","endLine":379,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14297,14300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14297,14300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":384,"column":48,"messageId":"unexpectedAny","endLine":384,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14553,14556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14553,14556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":389,"column":49,"messageId":"unexpectedAny","endLine":389,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14808,14811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14808,14811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":420,"column":42,"messageId":"unexpectedAny","endLine":420,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15742,15745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15742,15745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":425,"column":31,"messageId":"unexpectedAny","endLine":425,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15892,15895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15892,15895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":426,"column":25,"messageId":"unexpectedAny","endLine":426,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15934,15937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15934,15937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":607,"column":36,"messageId":"unexpectedAny","endLine":607,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21579,21582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21579,21582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":607,"column":69,"messageId":"unexpectedAny","endLine":607,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21612,21615],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21612,21615],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'audioSupport' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":687,"column":28,"messageId":"unusedVar","endLine":687,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":789,"column":22,"messageId":"unexpectedAny","endLine":789,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27192,27195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27192,27195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":29,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, computed } from 'vue';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport {\n  EXPORT_DIR_NAME,\n  VIDEO_DIR_NAME,\n  AUDIO_DIR_NAME,\n  IMAGES_DIR_NAME,\n  TIMELINES_DIR_NAME,\n} from '~/utils/constants';\nimport { parseTimelineFromOtio } from '~/timeline/otioSerializer';\nimport {\n  getExportWorkerClient,\n  setExportHostApi,\n  terminateExportWorker,\n  restartExportWorker,\n} from '~/utils/video-editor/worker-client';\nimport type { ClipTransform, TimelineTrackItem } from '~/timeline/types';\nimport { clampNumber, mergeBalance, mergeGain } from '~/utils/audio/envelope';\nimport { buildEffectiveAudioClipItems } from '~/utils/audio/track-bus';\nimport {\n  BASE_VIDEO_CODEC_OPTIONS,\n  checkAudioCodecSupport,\n  checkVideoCodecSupport,\n  resolveVideoCodecOptions,\n} from '~/utils/webcodecs';\n\nexport interface ExportOptions {\n  format: 'mp4' | 'webm' | 'mkv';\n  videoCodec: string;\n  bitrate: number;\n  bitrateMode?: 'constant' | 'variable';\n  keyframeIntervalSec?: number;\n  exportAlpha?: boolean;\n  metadata?: {\n    title: string;\n    author: string;\n    tags: string;\n  };\n  audioBitrate: number;\n  audio: boolean;\n  audioCodec?: string;\n  audioSampleRate?: number;\n  audioChannels?: 'stereo' | 'mono';\n  width: number;\n  height: number;\n  fps: number;\n}\n\nexport interface WorkerTimelineClip {\n  kind: 'clip';\n  clipType: 'media' | 'adjustment' | 'background' | 'text';\n  id: string;\n  layer: number;\n  speed?: number;\n  audioGain?: number;\n  audioBalance?: number;\n  audioFadeInUs?: number;\n  audioFadeOutUs?: number;\n  source?: { path: string };\n  backgroundColor?: string;\n  text?: string;\n  style?: import('~/timeline/types').TextClipStyle;\n  freezeFrameSourceUs?: number;\n  opacity?: number;\n  effects?: unknown[];\n  transform?: ClipTransform;\n  timelineRange: { startUs: number; durationUs: number };\n  sourceRange: { startUs: number; durationUs: number };\n}\n\nexport async function toWorkerTimelineClips(\n  items: TimelineTrackItem[],\n  projectStore: ReturnType<typeof useProjectStore>,\n  options?: {\n    layer?: number;\n    trackKind?: 'video' | 'audio';\n    visitedPaths?: Set<string>;\n    parentOpacity?: number;\n    parentEffects?: any[];\n  },\n): Promise<WorkerTimelineClip[]> {\n  const clips: WorkerTimelineClip[] = [];\n  const trackKind = options?.trackKind ?? 'video';\n  const visitedPaths = options?.visitedPaths ?? new Set<string>();\n\n  function cloneEffects<T>(effects: T): T {\n    try {\n      if (typeof structuredClone === 'function') {\n        return structuredClone(effects);\n      }\n    } catch {\n      // ignore\n    }\n    return effects;\n  }\n\n  function mergeFadeInUs(input: {\n    childFadeInUs: unknown;\n    parentFadeInUs: unknown;\n    parentLocalStartUs: number;\n  }): number | undefined {\n    const child = clampNumber(input.childFadeInUs, 0, Number.MAX_SAFE_INTEGER);\n    const parent = clampNumber(input.parentFadeInUs, 0, Number.MAX_SAFE_INTEGER);\n    if (!parent || parent <= 0) return child;\n    const remaining = Math.max(0, Math.round(parent - input.parentLocalStartUs));\n    if (remaining <= 0) return child;\n    if (child === undefined) return remaining;\n    return Math.max(child, remaining);\n  }\n\n  function mergeFadeOutUs(input: {\n    childFadeOutUs: unknown;\n    parentFadeOutUs: unknown;\n    parentLocalEndUs: number;\n    parentDurationUs: number;\n  }): number | undefined {\n    const child = clampNumber(input.childFadeOutUs, 0, Number.MAX_SAFE_INTEGER);\n    const parent = clampNumber(input.parentFadeOutUs, 0, Number.MAX_SAFE_INTEGER);\n    if (!parent || parent <= 0) return child;\n    const outStart = Math.max(0, Math.round(input.parentDurationUs - parent));\n    if (input.parentLocalEndUs <= outStart) return child;\n    const remaining = Math.max(\n      0,\n      Math.round(parent - (input.parentDurationUs - input.parentLocalEndUs)),\n    );\n    if (remaining <= 0) return child;\n    if (child === undefined) return remaining;\n    return Math.max(child, remaining);\n  }\n\n  function isProbablyUrlLike(path: string): boolean {\n    return /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(path);\n  }\n\n  function getDirname(path: string): string {\n    const normalized = String(path).replace(/\\\\/g, '/');\n    const parts = normalized.split('/').filter(Boolean);\n    if (parts.length <= 1) return '';\n    parts.pop();\n    return parts.join('/');\n  }\n\n  function joinPaths(left: string, right: string): string {\n    const l = String(left).replace(/\\\\/g, '/').replace(/\\/+$/g, '');\n    const r = String(right).replace(/\\\\/g, '/').replace(/^\\/+/, '');\n    if (!l) return r;\n    if (!r) return l;\n    return `${l}/${r}`;\n  }\n\n  function resolveNestedMediaPath(params: {\n    nestedTimelinePath: string;\n    mediaPath: string;\n  }): string {\n    const mediaPath = String(params.mediaPath);\n    if (!mediaPath) return mediaPath;\n    if (mediaPath.startsWith('/')) return mediaPath;\n    if (isProbablyUrlLike(mediaPath)) return mediaPath;\n    if (\n      mediaPath.startsWith(`${VIDEO_DIR_NAME}/`) ||\n      mediaPath.startsWith(`${AUDIO_DIR_NAME}/`) ||\n      mediaPath.startsWith(`${IMAGES_DIR_NAME}/`) ||\n      mediaPath.startsWith(`${TIMELINES_DIR_NAME}/`)\n    ) {\n      return mediaPath;\n    }\n    const baseDir = getDirname(params.nestedTimelinePath);\n    if (!baseDir) return mediaPath;\n    return joinPaths(baseDir, mediaPath);\n  }\n\n  for (const item of items) {\n    if (item.kind !== 'clip') continue;\n    if ((item as any).disabled) continue;\n\n    const clipType = (item as any).clipType ?? 'media';\n    const parentOpacity = options?.parentOpacity ?? 1;\n    const itemOpacity = item.opacity ?? 1;\n    const combinedOpacity = parentOpacity * itemOpacity;\n\n    const parentEffects = options?.parentEffects ?? [];\n    const itemEffects = Array.isArray(item.effects) ? cloneEffects(item.effects) : [];\n    const combinedEffects =\n      parentEffects.length > 0 ? [...parentEffects, ...itemEffects] : itemEffects;\n\n    const base: WorkerTimelineClip = {\n      kind: 'clip',\n      clipType: clipType === 'timeline' ? 'media' : clipType,\n      id: item.id,\n      layer:\n        options?.layer ??\n        (typeof (item as any).layer === 'number' && Number.isFinite((item as any).layer)\n          ? Math.round((item as any).layer)\n          : 0),\n      speed: (item as any).speed,\n      audioGain: (item as any).audioGain,\n      audioBalance: (item as any).audioBalance,\n      audioFadeInUs: (item as any).audioFadeInUs,\n      audioFadeOutUs: (item as any).audioFadeOutUs,\n      opacity: combinedOpacity,\n      effects: combinedEffects.length > 0 ? combinedEffects : undefined,\n      transform: (item as any).transform,\n      timelineRange: {\n        startUs: item.timelineRange.startUs,\n        durationUs: item.timelineRange.durationUs,\n      },\n      sourceRange: {\n        startUs: item.sourceRange.startUs,\n        durationUs: item.sourceRange.durationUs,\n      },\n    };\n\n    if (clipType === 'media' || clipType === 'timeline') {\n      const path = (item as any).source?.path;\n      if (!path) continue;\n\n      if (clipType === 'timeline') {\n        if (visitedPaths.has(path)) {\n          console.warn('Circular dependency detected in nested timeline:', path);\n          continue;\n        }\n\n        try {\n          const handle = await projectStore.getFileHandleByPath(path);\n          if (handle) {\n            const file = await handle.getFile();\n            const text = await file.text();\n            const nestedDoc = parseTimelineFromOtio(text, {\n              id: 'nested',\n              name: 'nested',\n              fps: 25,\n            });\n\n            const nextVisited = new Set(visitedPaths).add(path);\n\n            if (trackKind === 'video') {\n              const nestedVideoTracks = nestedDoc.tracks.filter(\n                (t) => t.kind === 'video' && !t.videoHidden,\n              );\n              for (let i = 0; i < nestedVideoTracks.length; i++) {\n                const track = nestedVideoTracks[i];\n                if (!track) continue;\n                const nestedLayer = (options?.layer ?? 0) + (nestedVideoTracks.length - 1 - i);\n\n                const trackEffects = Array.isArray(track.effects)\n                  ? cloneEffects(track.effects)\n                  : [];\n                const combinedTrackEffects =\n                  combinedEffects.length > 0 ? [...combinedEffects, ...trackEffects] : trackEffects;\n\n                const nestedWorkerClips = await toWorkerTimelineClips(track.items, projectStore, {\n                  layer: nestedLayer,\n                  trackKind: 'video',\n                  visitedPaths: nextVisited,\n                  parentOpacity: combinedOpacity,\n                  parentEffects: combinedTrackEffects,\n                });\n\n                for (const nClip of nestedWorkerClips) {\n                  const resolvedNClip: WorkerTimelineClip =\n                    nClip.clipType === 'media' && nClip.source?.path\n                      ? {\n                          ...nClip,\n                          source: {\n                            path: resolveNestedMediaPath({\n                              nestedTimelinePath: path,\n                              mediaPath: nClip.source.path,\n                            }),\n                          },\n                        }\n                      : nClip;\n\n                  const nStartUs = resolvedNClip.timelineRange.startUs;\n                  const nEndUs = nStartUs + resolvedNClip.timelineRange.durationUs;\n\n                  const windowStartUs = item.sourceRange.startUs;\n                  const windowEndUs = windowStartUs + item.sourceRange.durationUs;\n\n                  const overlapStartUs = Math.max(nStartUs, windowStartUs);\n                  const overlapEndUs = Math.min(nEndUs, windowEndUs);\n\n                  if (overlapStartUs < overlapEndUs) {\n                    const visibleDurationUs = overlapEndUs - overlapStartUs;\n                    const parentStartUs =\n                      item.timelineRange.startUs + (overlapStartUs - windowStartUs);\n                    const sourceShiftUs = overlapStartUs - nStartUs;\n\n                    clips.push({\n                      ...resolvedNClip,\n                      id: `${item.id}_nested_${resolvedNClip.id}`,\n                      layer: nestedLayer,\n                      audioGain: mergeGain((item as any).audioGain, resolvedNClip.audioGain),\n                      audioBalance: mergeBalance(\n                        (item as any).audioBalance,\n                        resolvedNClip.audioBalance,\n                      ),\n                      audioFadeInUs: mergeFadeInUs({\n                        childFadeInUs: resolvedNClip.audioFadeInUs,\n                        parentFadeInUs: (item as any).audioFadeInUs,\n                        parentLocalStartUs: overlapStartUs - windowStartUs,\n                      }),\n                      audioFadeOutUs: mergeFadeOutUs({\n                        childFadeOutUs: resolvedNClip.audioFadeOutUs,\n                        parentFadeOutUs: (item as any).audioFadeOutUs,\n                        parentLocalEndUs: overlapEndUs - windowStartUs,\n                        parentDurationUs: Math.max(0, Math.round(item.timelineRange.durationUs)),\n                      }),\n                      timelineRange: {\n                        startUs: parentStartUs,\n                        durationUs: visibleDurationUs,\n                      },\n                      sourceRange: {\n                        startUs: resolvedNClip.sourceRange.startUs + sourceShiftUs,\n                        durationUs: visibleDurationUs,\n                      },\n                    });\n                  }\n                }\n              }\n            } else if (trackKind === 'audio') {\n              const nestedAudioItems = buildEffectiveAudioClipItems({\n                audioTracks: nestedDoc.tracks.filter((t) => t.kind === 'audio'),\n                videoTracks: nestedDoc.tracks.filter((t) => t.kind === 'video'),\n              });\n\n              const nestedWorkerClips = await toWorkerTimelineClips(\n                nestedAudioItems,\n                projectStore,\n                {\n                  layer: 0,\n                  trackKind: 'audio',\n                  visitedPaths: nextVisited,\n                  parentOpacity: combinedOpacity,\n                  parentEffects: combinedEffects,\n                },\n              );\n\n              for (const nClip of nestedWorkerClips) {\n                const resolvedNClip: WorkerTimelineClip =\n                  nClip.clipType === 'media' && nClip.source?.path\n                    ? {\n                        ...nClip,\n                        source: {\n                          path: resolveNestedMediaPath({\n                            nestedTimelinePath: path,\n                            mediaPath: nClip.source.path,\n                          }),\n                        },\n                      }\n                    : nClip;\n\n                const nStartUs = resolvedNClip.timelineRange.startUs;\n                const nEndUs = nStartUs + resolvedNClip.timelineRange.durationUs;\n\n                const windowStartUs = item.sourceRange.startUs;\n                const windowEndUs = windowStartUs + item.sourceRange.durationUs;\n\n                const overlapStartUs = Math.max(nStartUs, windowStartUs);\n                const overlapEndUs = Math.min(nEndUs, windowEndUs);\n\n                if (overlapStartUs < overlapEndUs) {\n                  const visibleDurationUs = overlapEndUs - overlapStartUs;\n                  const parentStartUs =\n                    item.timelineRange.startUs + (overlapStartUs - windowStartUs);\n                  const sourceShiftUs = overlapStartUs - nStartUs;\n\n                  const parentLocalStartUs = overlapStartUs - windowStartUs;\n                  const parentLocalEndUs = overlapEndUs - windowStartUs;\n                  const parentDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n\n                  clips.push({\n                    ...resolvedNClip,\n                    id: `${item.id}_nested_${resolvedNClip.id}`,\n                    layer: 0,\n                    audioGain: mergeGain((item as any).audioGain, resolvedNClip.audioGain),\n                    audioBalance: mergeBalance(\n                      (item as any).audioBalance,\n                      resolvedNClip.audioBalance,\n                    ),\n                    audioFadeInUs: mergeFadeInUs({\n                      childFadeInUs: resolvedNClip.audioFadeInUs,\n                      parentFadeInUs: (item as any).audioFadeInUs,\n                      parentLocalStartUs,\n                    }),\n                    audioFadeOutUs: mergeFadeOutUs({\n                      childFadeOutUs: resolvedNClip.audioFadeOutUs,\n                      parentFadeOutUs: (item as any).audioFadeOutUs,\n                      parentLocalEndUs,\n                      parentDurationUs,\n                    }),\n                    timelineRange: {\n                      startUs: parentStartUs,\n                      durationUs: visibleDurationUs,\n                    },\n                    sourceRange: {\n                      startUs: resolvedNClip.sourceRange.startUs + sourceShiftUs,\n                      durationUs: visibleDurationUs,\n                    },\n                  });\n                }\n              }\n            }\n            continue;\n          }\n        } catch (e) {\n          console.error('Failed to expand nested timeline', e);\n        }\n      }\n\n      clips.push({\n        ...base,\n        source: { path },\n        freezeFrameSourceUs: item.freezeFrameSourceUs,\n      });\n    } else if (clipType === 'background') {\n      clips.push({\n        ...base,\n        backgroundColor: String((item as any).backgroundColor ?? '#000000'),\n      });\n    } else if (clipType === 'text') {\n      clips.push({\n        ...base,\n        text: String((item as any).text ?? ''),\n        style: (item as any).style,\n      });\n    } else {\n      clips.push(base);\n    }\n  }\n  return clips;\n}\n\nexport function getExt(fmt: 'mp4' | 'webm' | 'mkv'): 'mp4' | 'webm' | 'mkv' {\n  if (fmt === 'webm') return 'webm';\n  if (fmt === 'mkv') return 'mkv';\n  return 'mp4';\n}\n\nexport function sanitizeBaseName(name: string): string {\n  return name\n    .replace(/\\.[^.]+$/, '')\n    .replace(/[^a-zA-Z0-9._-]+/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_+|_+$/g, '');\n}\n\nexport function resolveNextAvailableFilename(\n  existingNames: ReadonlySet<string>,\n  base: string,\n  ext: string,\n): string {\n  const normalizedBase = sanitizeBaseName(base);\n  const normalizedExt = String(ext).replace(/^\\.+/, '').toLowerCase();\n\n  const direct = `${normalizedBase}.${normalizedExt}`;\n  if (normalizedBase && normalizedExt && !existingNames.has(direct)) return direct;\n\n  let index = 1;\n  while (index < 1000) {\n    const candidate = `${normalizedBase}_${String(index).padStart(3, '0')}.${normalizedExt}`;\n    if (!existingNames.has(candidate)) return candidate;\n    index++;\n  }\n\n  throw new Error('Failed to generate a unique filename');\n}\n\nexport function resolveExportCodecs(\n  format: 'mp4' | 'webm' | 'mkv',\n  selectedVideoCodec: string,\n  selectedAudioCodec: 'aac' | 'opus',\n) {\n  if (format === 'webm') {\n    return {\n      videoCodec: 'vp09.00.10.08',\n      audioCodec: 'opus' as const,\n    };\n  }\n\n  if (format === 'mkv') {\n    return {\n      videoCodec: 'av01.0.05M.08',\n      audioCodec: 'opus' as const,\n    };\n  }\n\n  return {\n    videoCodec: selectedVideoCodec,\n    audioCodec: selectedAudioCodec,\n  };\n}\n\nexport function useTimelineExport() {\n  const workspaceStore = useWorkspaceStore();\n  const projectStore = useProjectStore();\n  const timelineStore = useTimelineStore();\n\n  let cachedExportDir: FileSystemDirectoryHandle | null = null;\n  let cachedProjectName: string | null = null;\n  let cachedProjectsHandle: FileSystemDirectoryHandle | null = null;\n  let cachedExportFilenames: Set<string> | null = null;\n  let inflightExportFilenames: Promise<Set<string>> | null = null;\n\n  const isExporting = ref(false);\n  const exportProgress = ref(0);\n  const exportError = ref<string | null>(null);\n  const exportPhase = ref<'encoding' | 'saving' | null>(null);\n  const exportWarnings = ref<string[]>([]);\n\n  const cancelRequested = ref(false);\n\n  const outputFilename = ref('');\n  const filenameError = ref<string | null>(null);\n\n  const outputFormat = ref<'mp4' | 'webm' | 'mkv'>('mp4');\n  const videoCodec = ref('avc1.640032');\n  const bitrateMbps = ref<number>(5);\n  const excludeAudio = ref(false);\n  const audioCodec = ref<'aac' | 'opus'>('aac');\n  const audioBitrateKbps = ref<number>(128);\n  const exportWidth = ref<number>(1920);\n  const exportHeight = ref<number>(1080);\n  const exportFps = ref<number>(30);\n  const resolutionFormat = ref<string>('1080p');\n  const orientation = ref<'landscape' | 'portrait'>('landscape');\n  const aspectRatio = ref<string>('16:9');\n  const isCustomResolution = ref<boolean>(false);\n\n  const bitrateMode = ref<'constant' | 'variable'>('variable');\n  const keyframeIntervalSec = ref<number>(2);\n  const exportAlpha = ref<boolean>(false);\n  const metadataTitle = ref<string>('');\n  const metadataAuthor = ref<string>('');\n  const metadataTags = ref<string>('');\n\n  const videoCodecSupport = ref<Record<string, boolean>>({});\n  const isLoadingCodecSupport = ref(false);\n\n  const ext = computed(() => getExt(outputFormat.value));\n\n  const bitrateBps = computed(() => {\n    const value = Number(bitrateMbps.value);\n    if (!Number.isFinite(value)) return 5_000_000;\n    const clamped = Math.min(200, Math.max(0.2, value));\n    return Math.round(clamped * 1_000_000);\n  });\n\n  const normalizedExportWidth = computed(() => {\n    const value = Number(exportWidth.value);\n    if (!Number.isFinite(value) || value <= 0) return 1920;\n    return Math.round(value);\n  });\n\n  const normalizedExportHeight = computed(() => {\n    const value = Number(exportHeight.value);\n    if (!Number.isFinite(value) || value <= 0) return 1080;\n    return Math.round(value);\n  });\n\n  const normalizedExportFps = computed(() => {\n    const value = Number(exportFps.value);\n    if (!Number.isFinite(value) || value <= 0) return 30;\n    return Math.round(Math.min(240, Math.max(1, value)));\n  });\n\n  function resetExportFsCache() {\n    cachedExportDir = null;\n    cachedProjectName = null;\n    cachedProjectsHandle = null;\n    cachedExportFilenames = null;\n    inflightExportFilenames = null;\n  }\n\n  function isExportDirCacheValid() {\n    return (\n      cachedExportDir !== null &&\n      cachedProjectsHandle === workspaceStore.projectsHandle &&\n      cachedProjectName === projectStore.currentProjectName\n    );\n  }\n\n  async function ensureExportDir(): Promise<FileSystemDirectoryHandle> {\n    if (!workspaceStore.projectsHandle || !projectStore.currentProjectName) {\n      resetExportFsCache();\n      throw new Error('Project is not opened');\n    }\n\n    if (isExportDirCacheValid() && cachedExportDir) {\n      return cachedExportDir;\n    }\n\n    const projectDir = await workspaceStore.projectsHandle.getDirectoryHandle(\n      projectStore.currentProjectName,\n    );\n    cachedExportDir = await projectDir.getDirectoryHandle(EXPORT_DIR_NAME, { create: true });\n    cachedProjectName = projectStore.currentProjectName;\n    cachedProjectsHandle = workspaceStore.projectsHandle;\n    cachedExportFilenames = null;\n    inflightExportFilenames = null;\n    return cachedExportDir;\n  }\n\n  async function listExportFilenames(exportDir: FileSystemDirectoryHandle): Promise<Set<string>> {\n    const names = new Set<string>();\n    const iterator = (exportDir as any).values?.() ?? (exportDir as any).entries?.();\n    if (!iterator) return names;\n\n    for await (const value of iterator) {\n      const handle = Array.isArray(value) ? value[1] : value;\n      if (handle?.kind === 'file' && typeof handle?.name === 'string') {\n        names.add(handle.name);\n      }\n    }\n    return names;\n  }\n\n  async function loadExportFilenames(options?: { force?: boolean }): Promise<Set<string>> {\n    if (options?.force) {\n      cachedExportFilenames = null;\n      inflightExportFilenames = null;\n    }\n\n    if (cachedExportFilenames) {\n      return cachedExportFilenames;\n    }\n\n    if (inflightExportFilenames) {\n      return inflightExportFilenames;\n    }\n\n    inflightExportFilenames = (async () => {\n      const exportDir = await ensureExportDir();\n      const names = await listExportFilenames(exportDir);\n      cachedExportFilenames = names;\n      inflightExportFilenames = null;\n      return names;\n    })();\n\n    return inflightExportFilenames;\n  }\n\n  async function preloadExportIndex() {\n    await loadExportFilenames({ force: true });\n  }\n\n  function rememberExportedFilename(filename: string) {\n    if (!cachedExportFilenames) {\n      cachedExportFilenames = new Set<string>();\n    }\n    cachedExportFilenames.add(filename);\n  }\n\n  async function getNextAvailableFilename(base: string, ext: string) {\n    const names = await loadExportFilenames();\n\n    return resolveNextAvailableFilename(names, base, ext);\n  }\n\n  async function validateFilename() {\n    const trimmed = outputFilename.value.trim();\n    if (!trimmed) {\n      filenameError.value = 'Filename is required';\n      return false;\n    }\n\n    if (!trimmed.toLowerCase().endsWith(`.${ext.value}`)) {\n      filenameError.value = `Filename must end with .${ext.value}`;\n      return false;\n    }\n\n    const names = await loadExportFilenames();\n    if (names.has(trimmed)) {\n      filenameError.value = 'A file with this name already exists';\n      return false;\n    }\n\n    filenameError.value = null;\n    return true;\n  }\n\n  async function loadCodecSupport() {\n    if (isLoadingCodecSupport.value) return;\n    isLoadingCodecSupport.value = true;\n    try {\n      const [videoSupport, audioSupport] = await Promise.all([\n        checkVideoCodecSupport(BASE_VIDEO_CODEC_OPTIONS),\n        (async () => {\n          try {\n            const { canEncodeAudio } = await import('mediabunny');\n            const [aac, opus] = await Promise.all([\n              canEncodeAudio('aac', {\n                numberOfChannels: 2,\n                sampleRate: 48000,\n                bitrate: 128_000,\n              }),\n              canEncodeAudio('opus', {\n                numberOfChannels: 2,\n                sampleRate: 48000,\n                bitrate: 128_000,\n              }),\n            ]);\n            return { aac: !!aac, opus: !!opus } as const;\n          } catch {\n            const support = await checkAudioCodecSupport([\n              { value: 'mp4a.40.2', label: 'AAC' },\n              { value: 'opus', label: 'Opus' },\n            ]);\n            return {\n              aac: support['mp4a.40.2'] !== false,\n              opus: support['opus'] !== false,\n            } as const;\n          }\n        })(),\n      ]);\n\n      videoCodecSupport.value = videoSupport;\n\n      if (typeof window !== 'undefined') {\n        const stored = window.localStorage.getItem('gran-audio-codec-support');\n        if (stored) {\n          try {\n            audioCodec.value = 'aac';\n          } catch (e) {\n            console.error('Failed to load stored audio codec support', e);\n          }\n        }\n      }\n    } finally {\n      isLoadingCodecSupport.value = false;\n    }\n  }\n\n  async function exportTimelineToFile(\n    options: ExportOptions,\n    fileHandle: FileSystemFileHandle,\n    onProgress: (progress: number) => void,\n  ): Promise<void> {\n    const doc = timelineStore.timelineDoc;\n    const allVideoTracks = doc?.tracks?.filter((track) => track.kind === 'video') ?? [];\n    const videoTracks = allVideoTracks.filter((track) => !track.videoHidden);\n    const allAudioTracks = doc?.tracks?.filter((track) => track.kind === 'audio') ?? [];\n\n    const videoClips: WorkerTimelineClip[] = [];\n    for (let index = 0; index < videoTracks.length; index++) {\n      const track = videoTracks[index];\n      if (!track) continue;\n\n      const trackEffects = track.effects ? JSON.parse(JSON.stringify(track.effects)) : [];\n      const clips = await toWorkerTimelineClips(track.items ?? [], projectStore, {\n        layer: videoTracks.length - 1 - index,\n        trackKind: 'video',\n        parentEffects: trackEffects,\n      });\n\n      videoClips.push(...clips);\n    }\n\n    const effectiveAudioItems = buildEffectiveAudioClipItems({\n      audioTracks: allAudioTracks,\n      videoTracks: allVideoTracks,\n    });\n\n    const audioClips = await toWorkerTimelineClips(effectiveAudioItems, projectStore, {\n      trackKind: 'audio',\n    });\n\n    if (!videoClips.length && !audioClips.length) throw new Error('Timeline is empty');\n\n    const { client } = getExportWorkerClient();\n\n    setExportHostApi({\n      getFileHandleByPath: async (path) => projectStore.getFileHandleByPath(path),\n      onExportProgress: (progress) => onProgress(progress / 100),\n      onExportPhase: (phase) => {\n        exportPhase.value = phase;\n      },\n      onExportWarning: (message) => {\n        exportWarnings.value.push(message);\n      },\n    });\n\n    const finalOptions = {\n      ...options,\n      audioSampleRate: projectStore.projectSettings?.project?.sampleRate,\n      audioChannels: projectStore.projectSettings?.project?.audioChannels,\n    };\n    await (client as any).exportTimeline(fileHandle, finalOptions, videoClips, audioClips);\n  }\n\n  async function cancelExport() {\n    if (!isExporting.value) return;\n    if (cancelRequested.value) return;\n    cancelRequested.value = true;\n\n    try {\n      const { client } = getExportWorkerClient();\n      await client.cancelExport();\n    } catch (e) {\n      // Ignore and rely on fallback terminate\n      console.warn('Failed to request cooperative export cancel', e);\n    }\n\n    // Fallback: if export is still running after a grace period, terminate the worker.\n    setTimeout(() => {\n      if (!isExporting.value) return;\n      try {\n        terminateExportWorker('Export cancelled by user');\n        restartExportWorker();\n      } catch (e) {\n        console.error('Failed to cancel export worker', e);\n      }\n    }, 1500);\n  }\n\n  return {\n    isExporting,\n    exportProgress,\n    exportError,\n    exportPhase,\n    exportWarnings,\n    cancelRequested,\n    outputFilename,\n    filenameError,\n    outputFormat,\n    videoCodec,\n    bitrateMbps,\n    excludeAudio,\n    audioCodec,\n    audioBitrateKbps,\n    exportWidth,\n    exportHeight,\n    exportFps,\n    resolutionFormat,\n    orientation,\n    aspectRatio,\n    isCustomResolution,\n    bitrateMode,\n    keyframeIntervalSec,\n    exportAlpha,\n    metadataTitle,\n    metadataAuthor,\n    metadataTags,\n    videoCodecSupport,\n    isLoadingCodecSupport,\n    ext,\n    bitrateBps,\n    normalizedExportWidth,\n    normalizedExportHeight,\n    normalizedExportFps,\n    ensureExportDir,\n    preloadExportIndex,\n    validateFilename,\n    getNextAvailableFilename,\n    rememberExportedFilename,\n    loadCodecSupport,\n    exportTimelineToFile,\n    cancelExport,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/timeline/useTimelineInteraction.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'computed' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"messageId":"unusedVar","endLine":2,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"computed"},"fix":{"range":[54,63],"text":""},"desc":"Remove unused variable \"computed\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":51,"messageId":"unexpectedAny","endLine":303,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9849,9852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9849,9852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":363,"column":51,"messageId":"unexpectedAny","endLine":363,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11907,11910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11907,11910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":478,"column":43,"messageId":"unexpectedAny","endLine":478,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16036,16039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16036,16039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":481,"column":15,"messageId":"unexpected","endLine":481,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[16151,16151],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":530,"column":26,"messageId":"unexpectedAny","endLine":530,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17978,17981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17978,17981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":535,"column":12,"messageId":"unexpectedAny","endLine":535,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18084,18087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18084,18087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":537,"column":41,"messageId":"unexpectedAny","endLine":537,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18210,18213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18210,18213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":605,"column":46,"messageId":"unexpectedAny","endLine":605,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20196,20199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20196,20199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":606,"column":45,"messageId":"unexpectedAny","endLine":606,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20287,20290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20287,20290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":608,"column":17,"messageId":"unexpected","endLine":608,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[20359,20359],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":616,"column":39,"messageId":"unexpectedAny","endLine":616,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20636,20639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20636,20639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":616,"column":56,"messageId":"unexpectedAny","endLine":616,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20653,20656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20653,20656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":620,"column":47,"messageId":"unexpectedAny","endLine":620,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20742,20745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20742,20745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":621,"column":69,"messageId":"unexpectedAny","endLine":621,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20815,20818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20815,20818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":621,"column":77,"messageId":"unexpectedAny","endLine":621,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20823,20826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20823,20826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ComputedRef, Ref } from 'vue';\nimport { computed, onBeforeUnmount, onMounted, ref } from 'vue';\n\nimport type { TimelineTrack } from '~/timeline/types';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useHistoryStore } from '~/stores/history.store';\nimport { useTimelineSettingsStore } from '~/stores/timelineSettings.store';\nimport { selectTimelineDurationUs } from '~/timeline/selectors';\n\nexport const BASE_PX_PER_SECOND = 10;\n\nexport function zoomToPxPerSecond(zoom: number) {\n  const parsed = Number(zoom);\n  const safePos = Number.isFinite(parsed) ? parsed : 50;\n  const pos = Math.min(100, Math.max(0, safePos));\n\n  // Logarithmic scale where 50 => 1x. Each 10 points ~= 2x change.\n  // pxPerSecond = BASE * 2 ^ ((pos - 50) / 10)\n  const exponent = (pos - 50) / 10;\n  const factor = Math.pow(2, exponent);\n  return BASE_PX_PER_SECOND * factor;\n}\n\nexport function timeUsToPx(timeUs: number, zoom = 100) {\n  const pxPerSecond = zoomToPxPerSecond(zoom);\n  return (timeUs / 1e6) * pxPerSecond;\n}\n\nexport function pxToTimeUs(px: number, zoom = 100) {\n  const pxPerSecond = zoomToPxPerSecond(zoom);\n  return Math.max(0, Math.round((px / pxPerSecond) * 1e6));\n}\n\nexport function pxToDeltaUs(px: number, zoom = 100) {\n  const pxPerSecond = zoomToPxPerSecond(zoom);\n  return Math.round((px / pxPerSecond) * 1e6);\n}\n\nexport interface TimelineZoomAnchor {\n  anchorTimeUs: number;\n  anchorViewportX: number;\n}\n\nexport function computeAnchoredScrollLeft(params: {\n  prevZoom: number;\n  nextZoom: number;\n  prevScrollLeft: number;\n  viewportWidth: number;\n  anchor: TimelineZoomAnchor;\n}): number {\n  const { nextZoom, prevScrollLeft, viewportWidth, anchor } = params;\n\n  const safeViewportWidth = Number.isFinite(viewportWidth) ? Math.max(0, viewportWidth) : 0;\n  const safePrevScrollLeft = Number.isFinite(prevScrollLeft) ? Math.max(0, prevScrollLeft) : 0;\n\n  const anchorTimeUs = Number.isFinite(anchor.anchorTimeUs)\n    ? Math.max(0, Math.round(anchor.anchorTimeUs))\n    : 0;\n  const anchorViewportXRaw = Number.isFinite(anchor.anchorViewportX)\n    ? anchor.anchorViewportX\n    : safeViewportWidth / 2;\n  const anchorViewportX = Math.min(safeViewportWidth, Math.max(0, anchorViewportXRaw));\n\n  const anchorPxAtNextZoom = timeUsToPx(anchorTimeUs, nextZoom);\n  const nextScrollLeft = anchorPxAtNextZoom - anchorViewportX;\n\n  if (!Number.isFinite(nextScrollLeft)) return safePrevScrollLeft;\n  return Math.max(0, nextScrollLeft);\n}\n\nfunction sanitizeFps(value: unknown): number {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return 30;\n  const rounded = Math.round(parsed);\n  if (rounded < 1) return 1;\n  if (rounded > 240) return 240;\n  return rounded;\n}\n\nfunction quantizeDeltaUsToFrames(deltaUs: number, fps: number): number {\n  const safeDeltaUs = Number.isFinite(deltaUs) ? Math.round(deltaUs) : 0;\n  const safeFps = sanitizeFps(fps);\n  const framesFloat = (safeDeltaUs * safeFps) / 1e6;\n  const frames = Math.round(framesFloat);\n  return Math.round((frames * 1e6) / safeFps);\n}\n\nfunction quantizeStartUsToFrames(startUs: number, fps: number): number {\n  const safeFps = sanitizeFps(fps);\n  const frame = Math.round((Math.max(0, startUs) * safeFps) / 1e6);\n  return Math.round((frame * 1e6) / safeFps);\n}\n\nfunction sanitizeSnapTargetsUs(targets: number[]): number[] {\n  const result: number[] = [];\n  for (const v of targets) {\n    if (!Number.isFinite(v)) continue;\n    result.push(Math.max(0, Math.round(v)));\n  }\n  result.sort((a, b) => a - b);\n  // Deduplicate\n  const uniq: number[] = [];\n  for (const x of result) {\n    if (uniq.length === 0 || uniq[uniq.length - 1] !== x) uniq.push(x);\n  }\n  return uniq;\n}\n\nfunction pickBestSnapCandidateUs(params: {\n  rawUs: number;\n  thresholdUs: number;\n  targetsUs: number[];\n}): { snappedUs: number; distUs: number } {\n  const rawUs = Math.round(params.rawUs);\n  let best = rawUs;\n  let bestDist = Math.max(0, Math.round(params.thresholdUs));\n  for (const target of params.targetsUs) {\n    const dist = Math.abs(rawUs - target);\n    if (dist < bestDist) {\n      bestDist = dist;\n      best = target;\n    }\n  }\n  return { snappedUs: best, distUs: bestDist };\n}\n\n/**\n * Returns the snapped startUs considering clip-snap and frame-snap settings.\n * @param rawStartUs - raw candidate position in microseconds\n * @param fps - timeline fps\n * @param zoom - timeline zoom\n * @param snapThresholdPx - snap threshold in pixels\n * @param snapTargetsUs - precomputed snap targets in microseconds\n * @param enableFrameSnap - whether frame snapping is active\n * @param enableClipSnap - whether clip snapping is active\n */\nfunction computeSnappedStartUs(params: {\n  rawStartUs: number;\n  draggingItemDurationUs: number;\n  fps: number;\n  zoom: number;\n  snapThresholdPx: number;\n  snapTargetsUs: number[];\n  enableFrameSnap: boolean;\n  enableClipSnap: boolean;\n  frameOffsetUs: number;\n}): number {\n  const {\n    rawStartUs,\n    draggingItemDurationUs,\n    fps,\n    zoom,\n    snapThresholdPx,\n    snapTargetsUs,\n    enableFrameSnap,\n    enableClipSnap,\n    frameOffsetUs,\n  } = params;\n  const thresholdUs = Math.round((snapThresholdPx / zoomToPxPerSecond(zoom)) * 1e6);\n\n  let best = rawStartUs;\n  let bestDist = thresholdUs;\n\n  if (enableClipSnap) {\n    const rawEndUs = rawStartUs + Math.max(0, Math.round(draggingItemDurationUs));\n\n    for (const target of snapTargetsUs) {\n      const distStart = Math.abs(rawStartUs - target);\n      if (distStart < bestDist) {\n        bestDist = distStart;\n        best = target;\n      }\n\n      const distEnd = Math.abs(rawEndUs - target);\n      if (distEnd < bestDist) {\n        bestDist = distEnd;\n        best = target - Math.max(0, Math.round(draggingItemDurationUs));\n      }\n    }\n  }\n\n  if (enableFrameSnap && bestDist >= thresholdUs) {\n    const offsetUs = Number.isFinite(frameOffsetUs) ? Math.round(frameOffsetUs) : 0;\n    best = quantizeStartUsToFrames(rawStartUs - offsetUs, fps) + offsetUs;\n  }\n\n  return Math.max(0, best);\n}\n\nfunction computeSnapTargetsUs(params: {\n  tracks: TimelineTrack[];\n  excludeItemId: string;\n  includeTimelineStart: boolean;\n  includeTimelineEndUs: number | null;\n  includePlayheadUs: number | null;\n}): number[] {\n  const targets: number[] = [];\n  if (params.includeTimelineStart) targets.push(0);\n  if (\n    typeof params.includeTimelineEndUs === 'number' &&\n    Number.isFinite(params.includeTimelineEndUs)\n  ) {\n    targets.push(params.includeTimelineEndUs);\n  }\n  if (typeof params.includePlayheadUs === 'number' && Number.isFinite(params.includePlayheadUs)) {\n    targets.push(params.includePlayheadUs);\n  }\n\n  for (const track of params.tracks) {\n    for (const it of track.items) {\n      if (it.kind !== 'clip') continue;\n      if (it.id === params.excludeItemId) continue;\n      targets.push(it.timelineRange.startUs);\n      targets.push(it.timelineRange.startUs + it.timelineRange.durationUs);\n    }\n  }\n\n  return sanitizeSnapTargetsUs(targets);\n}\n\nexport interface TimelineMovePreview {\n  itemId: string;\n  trackId: string;\n  startUs: number;\n}\n\nexport function useTimelineInteraction(\n  scrollEl: Ref<HTMLElement | null>,\n  tracks: ComputedRef<TimelineTrack[]>,\n) {\n  const timelineStore = useTimelineStore();\n  const historyStore = useHistoryStore();\n  const settingsStore = useTimelineSettingsStore();\n\n  const isDraggingPlayhead = ref(false);\n  const draggingItemId = ref<string | null>(null);\n  const draggingTrackId = ref<string | null>(null);\n  const dragOriginTrackId = ref<string | null>(null);\n  const draggingMode = ref<'move' | 'trim_start' | 'trim_end' | null>(null);\n  const dragAnchorClientX = ref(0);\n  const dragAnchorStartUs = ref(0);\n  const dragAnchorDurationUs = ref(0);\n  const dragFrameOffsetUs = ref(0);\n  const dragLastAppliedQuantizedDeltaUs = ref(0);\n  const dragSnapTargetsUs = ref<number[]>([]);\n  const dragAnchorItemDurationUs = ref(0);\n  const hasPendingTimelinePersist = ref(false);\n  const lastDragClientX = ref(0);\n  const pendingDragClientX = ref<number | null>(null);\n  const pendingDragClientY = ref<number | null>(null);\n\n  const movePreview = ref<TimelineMovePreview | null>(null);\n  const pendingMoveCommit = ref<{\n    fromTrackId: string;\n    toTrackId: string;\n    itemId: string;\n    startUs: number;\n  } | null>(null);\n\n  const dragStartSnapshot = ref<import('~/timeline/types').TimelineDocument | null>(null);\n  const lastDragAppliedCmd = ref<import('~/timeline/commands').TimelineCommand | null>(null);\n  const dragCancelRequested = ref(false);\n\n  let dragRafId: number | null = null;\n\n  function getLocalX(e: MouseEvent): number {\n    const target = e.currentTarget as HTMLElement | null;\n    const rect = target?.getBoundingClientRect();\n    const scrollX = scrollEl.value?.scrollLeft ?? 0;\n    if (!rect) return 0;\n    return e.clientX - rect.left + scrollX;\n  }\n\n  function seekByMouseEvent(e: MouseEvent) {\n    const x = getLocalX(e);\n    timelineStore.currentTime = pxToTimeUs(x, timelineStore.timelineZoom);\n  }\n\n  function onTimeRulerMouseDown(e: MouseEvent) {\n    if (e.button !== 0) return;\n    seekByMouseEvent(e);\n    startPlayheadDrag(e);\n  }\n\n  function startPlayheadDrag(e: MouseEvent) {\n    if (e.button !== 0) return;\n    isDraggingPlayhead.value = true;\n    window.addEventListener('mousemove', onGlobalMouseMove);\n    window.addEventListener('mouseup', onGlobalMouseUp);\n    window.addEventListener('keydown', onGlobalKeyDown);\n  }\n\n  function selectItem(e: MouseEvent, itemId: string) {\n    e.stopPropagation();\n    timelineStore.toggleSelection(itemId, { multi: e.shiftKey || e.metaKey || e.ctrlKey });\n  }\n\n  function startMoveItem(e: MouseEvent, trackId: string, itemId: string, startUs: number) {\n    if (e.button !== 0) return;\n    e.stopPropagation();\n\n    const item = tracks.value.find((t) => t.id === trackId)?.items.find((it) => it.id === itemId);\n    if (item?.kind === 'clip' && Boolean((item as any).locked)) return;\n\n    if (!timelineStore.selectedItemIds.includes(itemId)) {\n      timelineStore.toggleSelection(itemId);\n    }\n\n    draggingMode.value = 'move';\n    draggingTrackId.value = trackId;\n    dragOriginTrackId.value = trackId;\n    draggingItemId.value = itemId;\n    dragAnchorClientX.value = e.clientX;\n    lastDragClientX.value = e.clientX;\n    dragAnchorStartUs.value = startUs;\n    dragAnchorDurationUs.value =\n      tracks.value.find((t) => t.id === trackId)?.items.find((it) => it.id === itemId)\n        ?.timelineRange.durationUs ?? 0;\n    dragAnchorItemDurationUs.value = dragAnchorDurationUs.value;\n    const fps = sanitizeFps(timelineStore.timelineDoc?.timebase?.fps);\n    const q = quantizeStartUsToFrames(startUs, fps);\n    dragFrameOffsetUs.value = Math.round(startUs - q);\n    dragLastAppliedQuantizedDeltaUs.value = 0;\n\n    const timelineEndUs = Number.isFinite(timelineStore.duration)\n      ? Math.max(0, Math.round(timelineStore.duration))\n      : null;\n    dragSnapTargetsUs.value = computeSnapTargetsUs({\n      tracks: tracks.value,\n      excludeItemId: itemId,\n      includeTimelineStart: true,\n      includeTimelineEndUs: timelineEndUs,\n      includePlayheadUs: timelineStore.currentTime,\n    });\n\n    dragStartSnapshot.value = timelineStore.timelineDoc;\n    lastDragAppliedCmd.value = null;\n    dragCancelRequested.value = false;\n\n    movePreview.value = {\n      itemId,\n      trackId,\n      startUs,\n    };\n    pendingMoveCommit.value = null;\n\n    window.addEventListener('mousemove', onGlobalMouseMove);\n    window.addEventListener('mouseup', onGlobalMouseUp);\n    window.addEventListener('keydown', onGlobalKeyDown);\n  }\n\n  function startTrimItem(\n    e: MouseEvent,\n    input: { trackId: string; itemId: string; edge: 'start' | 'end'; startUs: number },\n  ) {\n    if (e.button !== 0) return;\n    e.preventDefault();\n    e.stopPropagation();\n\n    const item = tracks.value\n      .find((t) => t.id === input.trackId)\n      ?.items.find((it) => it.id === input.itemId);\n    if (item?.kind === 'clip' && Boolean((item as any).locked)) return;\n\n    draggingMode.value = input.edge === 'start' ? 'trim_start' : 'trim_end';\n    draggingTrackId.value = input.trackId;\n    draggingItemId.value = input.itemId;\n    dragAnchorClientX.value = e.clientX;\n    lastDragClientX.value = e.clientX;\n    dragAnchorStartUs.value = input.startUs;\n    dragLastAppliedQuantizedDeltaUs.value = 0;\n\n    const currentItem = tracks.value\n      .find((t) => t.id === input.trackId)\n      ?.items.find((it) => it.id === input.itemId);\n    const durationUs = currentItem?.kind === 'clip' ? currentItem.timelineRange.durationUs : 0;\n    dragAnchorItemDurationUs.value = Math.max(0, Math.round(Number(durationUs ?? 0)));\n\n    const timelineEndUs = Number.isFinite(timelineStore.duration)\n      ? Math.max(0, Math.round(timelineStore.duration))\n      : null;\n    dragSnapTargetsUs.value = computeSnapTargetsUs({\n      tracks: tracks.value,\n      excludeItemId: input.itemId,\n      includeTimelineStart: true,\n      includeTimelineEndUs: timelineEndUs,\n      includePlayheadUs: timelineStore.currentTime,\n    });\n\n    dragCancelRequested.value = false;\n\n    window.addEventListener('mousemove', onGlobalMouseMove);\n    window.addEventListener('mouseup', onGlobalMouseUp);\n    window.addEventListener('keydown', onGlobalKeyDown);\n  }\n\n  function onGlobalKeyDown(e: KeyboardEvent) {\n    if (e.key !== 'Escape') return;\n\n    const hasActiveDrag = Boolean(draggingMode.value) || isDraggingPlayhead.value;\n    if (!hasActiveDrag) return;\n\n    dragCancelRequested.value = true;\n    e.preventDefault();\n    onGlobalMouseUp();\n  }\n\n  function applyDragFromPendingClientX() {\n    const mode = draggingMode.value;\n    const trackId = draggingTrackId.value;\n    const itemId = draggingItemId.value;\n    const clientX = pendingDragClientX.value;\n    const clientY = pendingDragClientY.value;\n\n    pendingDragClientX.value = null;\n    pendingDragClientY.value = null;\n    dragRafId = null;\n\n    if (!mode || !trackId || !itemId || clientX === null || clientY === null) return;\n\n    const fps = sanitizeFps(timelineStore.timelineDoc?.timebase?.fps);\n    const zoom = timelineStore.timelineZoom;\n    const enableFrameSnap = settingsStore.frameSnapMode === 'frames';\n    const enableClipSnap = settingsStore.clipSnapMode === 'clips';\n    const snapThresholdPx = settingsStore.snapThresholdPx;\n    const overlapMode = settingsStore.overlapMode;\n\n    if (mode === 'move') {\n      const dxPx = clientX - dragAnchorClientX.value;\n      const rawDeltaUs = pxToDeltaUs(dxPx, zoom);\n      const rawStartUs = Math.max(0, dragAnchorStartUs.value + rawDeltaUs);\n\n      const startUs = computeSnappedStartUs({\n        rawStartUs,\n        draggingItemDurationUs: dragAnchorDurationUs.value,\n        fps,\n        zoom,\n        snapThresholdPx,\n        snapTargetsUs: dragSnapTargetsUs.value,\n        enableFrameSnap,\n        enableClipSnap,\n        frameOffsetUs: dragFrameOffsetUs.value,\n      });\n\n      const trackEl = document.elementFromPoint(clientX, clientY)?.closest('[data-track-id]');\n      const hoverTrackId = trackEl?.getAttribute('data-track-id');\n      let targetTrackId = trackId;\n\n      if (hoverTrackId && hoverTrackId !== trackId) {\n        const fromTrack = tracks.value.find((t) => t.id === trackId);\n        const toTrack = tracks.value.find((t) => t.id === hoverTrackId);\n        if (fromTrack && toTrack && fromTrack.kind === toTrack.kind) {\n          targetTrackId = hoverTrackId;\n        }\n      }\n\n      if (overlapMode === 'pseudo') {\n        movePreview.value = { itemId, trackId: targetTrackId, startUs };\n        pendingMoveCommit.value = {\n          fromTrackId: dragOriginTrackId.value ?? trackId,\n          toTrackId: targetTrackId,\n          itemId,\n          startUs,\n        };\n        draggingTrackId.value = targetTrackId;\n        return;\n      }\n\n      try {\n        const cmd = {\n          type: 'move_item_to_track',\n          fromTrackId: trackId,\n          toTrackId: targetTrackId,\n          itemId,\n          startUs,\n        } as const;\n        timelineStore.applyTimeline(cmd, { saveMode: 'none', skipHistory: true });\n        lastDragAppliedCmd.value = cmd as any;\n        draggingTrackId.value = targetTrackId;\n        hasPendingTimelinePersist.value = true;\n      } catch {}\n      return;\n    }\n\n    // Trim modes\n    const dxPx = clientX - dragAnchorClientX.value;\n    const rawDeltaUs = pxToDeltaUs(dxPx, zoom);\n\n    const thresholdUs = Math.round((snapThresholdPx / zoomToPxPerSecond(zoom)) * 1e6);\n    const anchorStartUs = Math.max(0, Math.round(dragAnchorStartUs.value));\n    const anchorDurationUs = Math.max(0, Math.round(dragAnchorItemDurationUs.value));\n    const anchorEndUs = anchorStartUs + anchorDurationUs;\n\n    const rawEdgeUs = mode === 'trim_start' ? anchorStartUs + rawDeltaUs : anchorEndUs + rawDeltaUs;\n\n    let snappedEdgeUs = Math.round(rawEdgeUs);\n    let bestDist = thresholdUs;\n\n    if (enableClipSnap) {\n      const clipSnap = pickBestSnapCandidateUs({\n        rawUs: rawEdgeUs,\n        thresholdUs,\n        targetsUs: dragSnapTargetsUs.value,\n      });\n      snappedEdgeUs = clipSnap.snappedUs;\n      bestDist = clipSnap.distUs;\n    }\n\n    if (enableFrameSnap && bestDist >= thresholdUs) {\n      snappedEdgeUs = quantizeStartUsToFrames(rawEdgeUs, fps);\n    }\n\n    // Convert snapped edge back to delta relative to current edge (so we stay compatible with timeline commands)\n    const desiredDeltaUs =\n      mode === 'trim_start' ? snappedEdgeUs - anchorStartUs : snappedEdgeUs - anchorEndUs;\n    const desiredQuantizedDeltaUs = enableFrameSnap\n      ? quantizeDeltaUsToFrames(desiredDeltaUs, fps)\n      : Math.round(desiredDeltaUs);\n\n    const nextStepDeltaUs = desiredQuantizedDeltaUs - dragLastAppliedQuantizedDeltaUs.value;\n    lastDragClientX.value = clientX;\n    if (nextStepDeltaUs === 0) return;\n    dragLastAppliedQuantizedDeltaUs.value = desiredQuantizedDeltaUs;\n\n    const cmdEdge = mode === 'trim_start' ? 'start' : 'end';\n    const cmdType = overlapMode === 'pseudo' ? 'overlay_trim_item' : 'trim_item';\n\n    try {\n      const cmd = {\n        type: cmdType as any,\n        trackId,\n        itemId,\n        edge: cmdEdge,\n        deltaUs: nextStepDeltaUs,\n      } as any;\n      timelineStore.applyTimeline(cmd, { saveMode: 'none', skipHistory: true });\n      lastDragAppliedCmd.value = cmd as any;\n      hasPendingTimelinePersist.value = true;\n    } catch {\n      // Keep last applied quantized delta unchanged on failure? We intentionally keep it,\n      // so the user can continue dragging and we only apply deltas when possible.\n    }\n  }\n\n  function scheduleDragApply() {\n    if (dragRafId !== null) return;\n    dragRafId = requestAnimationFrame(() => {\n      applyDragFromPendingClientX();\n    });\n  }\n\n  function onGlobalMouseMove(e: MouseEvent) {\n    if (isDraggingPlayhead.value) {\n      if (e.buttons === 0) {\n        onGlobalMouseUp();\n        return;\n      }\n      const scrollerRect = scrollEl.value?.getBoundingClientRect();\n      if (!scrollerRect) return;\n      const scrollX = scrollEl.value?.scrollLeft ?? 0;\n      const x = e.clientX - scrollerRect.left + scrollX;\n      timelineStore.currentTime = pxToTimeUs(x, timelineStore.timelineZoom);\n      return;\n    }\n\n    const mode = draggingMode.value;\n    const trackId = draggingTrackId.value;\n    const itemId = draggingItemId.value;\n    if (!mode || !trackId || !itemId) return;\n\n    if (e.buttons === 0) {\n      onGlobalMouseUp();\n      return;\n    }\n\n    pendingDragClientX.value = e.clientX;\n    pendingDragClientY.value = e.clientY;\n    scheduleDragApply();\n  }\n\n  function onGlobalMouseUp() {\n    const cancel = dragCancelRequested.value;\n    dragCancelRequested.value = false;\n\n    if (dragRafId !== null) {\n      cancelAnimationFrame(dragRafId);\n      dragRafId = null;\n    }\n\n    if (!cancel) {\n      applyDragFromPendingClientX();\n    }\n\n    if (!cancel && draggingMode.value === 'move' && settingsStore.overlapMode === 'pseudo') {\n      const commit = pendingMoveCommit.value;\n      if (commit) {\n        try {\n          const cmd = {\n            type: 'overlay_place_item',\n            fromTrackId: commit.fromTrackId,\n            toTrackId: commit.toTrackId,\n            itemId: commit.itemId,\n            startUs: commit.startUs,\n          } as const;\n          timelineStore.applyTimeline(cmd as any, { saveMode: 'none', skipHistory: true });\n          lastDragAppliedCmd.value = cmd as any;\n          hasPendingTimelinePersist.value = true;\n        } catch {}\n      }\n    }\n\n    const snapshot = dragStartSnapshot.value;\n    const appliedCmd = lastDragAppliedCmd.value;\n    const currDoc = timelineStore.timelineDoc;\n    if (!cancel && snapshot && appliedCmd && currDoc && snapshot !== currDoc) {\n      historyStore.push(appliedCmd as any, snapshot as any);\n    }\n\n    if (cancel && snapshot) {\n      timelineStore.timelineDoc = snapshot as any;\n      timelineStore.duration = selectTimelineDurationUs(snapshot as any) as any;\n    }\n\n    if (!cancel && hasPendingTimelinePersist.value) {\n      void timelineStore.requestTimelineSave({ immediate: true });\n      hasPendingTimelinePersist.value = false;\n    }\n\n    isDraggingPlayhead.value = false;\n    draggingMode.value = null;\n    draggingItemId.value = null;\n    draggingTrackId.value = null;\n    dragOriginTrackId.value = null;\n    pendingDragClientX.value = null;\n    pendingDragClientY.value = null;\n\n    movePreview.value = null;\n    pendingMoveCommit.value = null;\n\n    dragStartSnapshot.value = null;\n    lastDragAppliedCmd.value = null;\n\n    window.removeEventListener('mousemove', onGlobalMouseMove);\n    window.removeEventListener('mouseup', onGlobalMouseUp);\n    window.removeEventListener('keydown', onGlobalKeyDown);\n  }\n\n  onMounted(() => {});\n\n  onBeforeUnmount(() => {\n    if (dragRafId !== null) {\n      cancelAnimationFrame(dragRafId);\n      dragRafId = null;\n    }\n    window.removeEventListener('mousemove', onGlobalMouseMove);\n    window.removeEventListener('mouseup', onGlobalMouseUp);\n    window.removeEventListener('keydown', onGlobalKeyDown);\n  });\n\n  return {\n    isDraggingPlayhead,\n    draggingMode,\n    draggingItemId,\n    movePreview,\n    onTimeRulerMouseDown,\n    startPlayheadDrag,\n    selectItem,\n    startMoveItem,\n    startTrimItem,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/useDraggedFile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/composables/useFileManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/effects/core/registry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":52,"messageId":"unexpectedAny","endLine":5,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[125,128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[125,128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":43,"messageId":"unexpectedAny","endLine":34,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[735,738],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[735,738],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":60,"messageId":"unexpectedAny","endLine":37,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[835,838],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[835,838],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":69,"messageId":"unexpectedAny","endLine":43,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1029,1032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1029,1032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":57,"messageId":"unexpectedAny","endLine":47,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1143,1146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1143,1146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Filter } from 'pixi.js';\n\nexport type EffectType = string;\n\nexport interface EffectManifest<T = Record<string, any>> {\n  type: EffectType;\n  name: string;\n  description: string;\n  icon: string;\n  defaultValues: T;\n  controls: EffectControl<T>[];\n  createFilter: () => Filter;\n  updateFilter: (filter: Filter, values: T) => void;\n}\n\nexport type EffectControl<T> =\n  | {\n      kind: 'slider';\n      key: keyof T;\n      label: string;\n      min: number;\n      max: number;\n      step: number;\n      format?: (v: number) => string;\n    }\n  | { kind: 'toggle'; key: keyof T; label: string };\n\nexport interface BaseClipEffect {\n  id: string;\n  type: EffectType;\n  enabled: boolean;\n}\n\nexport type ClipEffect<T = Record<string, any>> = BaseClipEffect & T;\n\n// Registry\nconst effectsRegistry = new Map<EffectType, EffectManifest<any>>();\n\nexport function registerEffect<T>(manifest: EffectManifest<T>) {\n  effectsRegistry.set(manifest.type, manifest);\n}\n\nexport function getEffectManifest(type: EffectType): EffectManifest<any> | undefined {\n  return effectsRegistry.get(type);\n}\n\nexport function getAllEffectManifests(): EffectManifest<any>[] {\n  return Array.from(effectsRegistry.values());\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/effects/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/effects/video/blur/manifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/effects/video/color-adjustment/manifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/application/fileManagerCommands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/application/fileManagerService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":57,"messageId":"unexpectedAny","endLine":106,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3902,3905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3902,3905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Ref } from 'vue';\nimport type { FsEntry } from '~/types/fs';\nimport {\n  findEntryByPath as findEntryByPathCore,\n  mergeEntries as mergeEntriesCore,\n  updateEntryByPath,\n} from '~/file-manager/core/tree';\nimport { AUDIO_DIR_NAME, FILES_DIR_NAME, IMAGES_DIR_NAME, VIDEO_DIR_NAME } from '~/utils/constants';\n\ninterface FsDirectoryHandleWithIteration extends FileSystemDirectoryHandle {\n  values?: () => AsyncIterable<FileSystemHandle>;\n  entries?: () => AsyncIterable<[string, FileSystemHandle]>;\n}\n\ntype DirectoryIterator = (\n  dirHandle: FileSystemDirectoryHandle,\n) => AsyncIterable<FileSystemHandle> | null;\n\nexport interface FileManagerServiceDeps {\n  rootEntries: Ref<FsEntry[]>;\n  sortMode: Ref<'name' | 'modified'>;\n  showHiddenFiles: () => boolean;\n  hasPersistedFileTreeState?: () => boolean;\n  isPathExpanded: (path: string) => boolean;\n  setPathExpanded: (path: string, expanded: boolean) => void;\n  getExpandedPaths: () => string[];\n  getDirectoryIterator?: DirectoryIterator;\n  sanitizeHandle: <T extends object>(handle: T) => T;\n  sanitizeParentHandle: (handle: FileSystemDirectoryHandle) => FileSystemDirectoryHandle;\n  checkExistingProxies: (videoPaths: string[]) => Promise<void>;\n  onError?: (params: { title?: string; message: string; error?: unknown }) => void;\n}\n\nexport interface FileManagerService {\n  readDirectory: (dirHandle: FileSystemDirectoryHandle, basePath?: string) => Promise<FsEntry[]>;\n  findEntryByPath: (path: string) => FsEntry | null;\n  mergeEntries: (prev: FsEntry[] | undefined, next: FsEntry[]) => FsEntry[];\n  toggleDirectory: (entry: FsEntry) => Promise<void>;\n  refreshExpandedChildren: (entries: FsEntry[]) => Promise<void>;\n  expandPersistedDirectories: () => Promise<void>;\n  loadProjectDirectory: (projectDir: FileSystemDirectoryHandle) => Promise<void>;\n}\n\nexport function createFileManagerService(deps: FileManagerServiceDeps): FileManagerService {\n  const getDirectoryIterator: DirectoryIterator =\n    deps.getDirectoryIterator ??\n    ((dirHandle) => {\n      const iterator =\n        (dirHandle as FsDirectoryHandleWithIteration).values?.() ??\n        (dirHandle as FsDirectoryHandleWithIteration).entries?.();\n      if (!iterator) return null;\n      return (async function* () {\n        for await (const value of iterator) {\n          const handle = (Array.isArray(value) ? value[1] : value) as FileSystemHandle;\n          yield handle;\n        }\n      })();\n    });\n\n  async function attachLastModified(entries: FsEntry[]): Promise<FsEntry[]> {\n    const next = await Promise.all(\n      entries.map(async (entry) => {\n        if (entry.kind !== 'file') return entry;\n        try {\n          const file = await (entry.handle as FileSystemFileHandle).getFile();\n          return { ...entry, lastModified: file.lastModified };\n        } catch {\n          return { ...entry, lastModified: undefined };\n        }\n      }),\n    );\n    return next;\n  }\n\n  function compareEntries(a: FsEntry, b: FsEntry): number {\n    if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;\n\n    if (deps.sortMode.value === 'modified') {\n      const am = a.lastModified ?? 0;\n      const bm = b.lastModified ?? 0;\n      if (am !== bm) return bm - am;\n    }\n\n    return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });\n  }\n\n  async function readDirectory(\n    dirHandle: FileSystemDirectoryHandle,\n    basePath = '',\n  ): Promise<FsEntry[]> {\n    const entries: FsEntry[] = [];\n\n    const iterator = getDirectoryIterator(dirHandle);\n    if (!iterator) {\n      deps.onError?.({\n        title: 'File manager error',\n        message: 'Failed to read directory: iteration is not available',\n      });\n      return entries;\n    }\n\n    try {\n      for await (const rawHandle of iterator) {\n        if (!deps.showHiddenFiles() && rawHandle.name.startsWith('.')) continue;\n\n        const handle = deps.sanitizeHandle(rawHandle as any);\n        const parentHandle = deps.sanitizeParentHandle(dirHandle);\n\n        entries.push({\n          name: handle.name,\n          kind: handle.kind,\n          handle,\n          parentHandle,\n          children: undefined,\n          expanded: false,\n          path: basePath ? `${basePath}/${handle.name}` : handle.name,\n          lastModified: undefined,\n        });\n      }\n    } catch (e) {\n      deps.onError?.({\n        title: 'File manager error',\n        message: `Failed to read directory${basePath ? `: ${basePath}` : ''}`,\n        error: e,\n      });\n      return entries;\n    }\n\n    const entriesWithModified =\n      deps.sortMode.value === 'modified' ? await attachLastModified(entries) : entries;\n\n    const videoPaths = entriesWithModified\n      .filter((e) => e.kind === 'file' && e.path?.startsWith(`${VIDEO_DIR_NAME}/`))\n      .map((e) => e.path!);\n    if (videoPaths.length > 0) {\n      await deps.checkExistingProxies(videoPaths);\n    }\n\n    return [...entriesWithModified].sort(compareEntries);\n  }\n\n  function mergeEntries(prev: FsEntry[] | undefined, next: FsEntry[]): FsEntry[] {\n    return mergeEntriesCore(prev, next, {\n      isPathExpanded: (path) => deps.isPathExpanded(path),\n    });\n  }\n\n  function findEntryByPath(path: string): FsEntry | null {\n    return findEntryByPathCore(deps.rootEntries.value, path);\n  }\n\n  async function toggleDirectory(entry: FsEntry) {\n    if (entry.kind !== 'directory') return;\n\n    const path = entry.path;\n    if (!path) return;\n\n    const current = findEntryByPathCore(deps.rootEntries.value, path);\n    if (!current || current.kind !== 'directory') return;\n\n    const nextExpanded = !current.expanded;\n\n    const applyExpandedState = (expanded: boolean) => {\n      deps.rootEntries.value = updateEntryByPath(deps.rootEntries.value, path, (e) => ({\n        ...e,\n        expanded,\n      }));\n      deps.setPathExpanded(path, expanded);\n    };\n\n    if (!nextExpanded) {\n      applyExpandedState(false);\n      return;\n    }\n\n    applyExpandedState(true);\n\n    const afterExpand = findEntryByPathCore(deps.rootEntries.value, path);\n    if (!afterExpand || afterExpand.kind !== 'directory') return;\n    if (afterExpand.children !== undefined) return;\n\n    try {\n      const children = await readDirectory(afterExpand.handle as FileSystemDirectoryHandle, path);\n      deps.rootEntries.value = updateEntryByPath(deps.rootEntries.value, path, (e) => ({\n        ...e,\n        children,\n      }));\n    } catch (e) {\n      applyExpandedState(false);\n      deps.onError?.({\n        title: 'File manager error',\n        message: `Failed to read folder: ${path}`,\n        error: e,\n      });\n    }\n  }\n\n  async function refreshExpandedChildren(entries: FsEntry[]): Promise<void> {\n    for (const entry of entries) {\n      if (entry.kind !== 'directory') continue;\n      if (!entry.expanded) continue;\n      if (entry.children === undefined) continue;\n\n      try {\n        const nextChildren = await readDirectory(\n          entry.handle as FileSystemDirectoryHandle,\n          entry.path,\n        );\n        if (entry.path) {\n          const merged = mergeEntries(entry.children, nextChildren);\n          deps.rootEntries.value = updateEntryByPath(deps.rootEntries.value, entry.path, (e) => ({\n            ...e,\n            children: merged,\n          }));\n        }\n      } catch (e) {\n        deps.onError?.({\n          title: 'File manager error',\n          message: `Failed to refresh directory${entry.path ? `: ${entry.path}` : ''}`,\n          error: e,\n        });\n      }\n\n      if (entry.children) {\n        await refreshExpandedChildren(entry.children);\n      }\n    }\n  }\n\n  async function expandPersistedDirectories() {\n    const expandedPaths = deps.getExpandedPaths();\n    if (expandedPaths.length === 0) return;\n\n    const sortedPaths = [...expandedPaths].sort((a, b) => a.length - b.length);\n\n    for (const path of sortedPaths) {\n      const parts = path.split('/').filter(Boolean);\n      if (parts.length === 0) continue;\n\n      let currentList = deps.rootEntries.value;\n      let currentPath = '';\n\n      for (const part of parts) {\n        currentPath = currentPath ? `${currentPath}/${part}` : part;\n        const entry = currentList.find((e) => e.kind === 'directory' && e.name === part);\n        if (!entry) break;\n\n        if (!entry.expanded) {\n          await toggleDirectory(entry);\n        } else if (entry.children === undefined) {\n          entry.children = await readDirectory(\n            entry.handle as FileSystemDirectoryHandle,\n            entry.path,\n          );\n        }\n\n        if (!deps.isPathExpanded(currentPath)) {\n          deps.setPathExpanded(currentPath, true);\n        }\n\n        currentList = entry.children ?? [];\n      }\n    }\n  }\n\n  async function loadProjectDirectory(projectDir: FileSystemDirectoryHandle) {\n    const nextRoot = await readDirectory(projectDir);\n    deps.rootEntries.value = mergeEntries(deps.rootEntries.value, nextRoot);\n\n    await refreshExpandedChildren(deps.rootEntries.value);\n    await expandPersistedDirectories();\n\n    if (deps.hasPersistedFileTreeState?.()) {\n      return;\n    }\n\n    for (const entry of deps.rootEntries.value) {\n      if (\n        entry.kind === 'directory' &&\n        (entry.name === VIDEO_DIR_NAME ||\n          entry.name === AUDIO_DIR_NAME ||\n          entry.name === FILES_DIR_NAME ||\n          entry.name === IMAGES_DIR_NAME)\n      ) {\n        if (!entry.expanded) {\n          await toggleDirectory(entry);\n        }\n      }\n    }\n  }\n\n  return {\n    readDirectory,\n    findEntryByPath,\n    mergeEntries,\n    toggleDirectory,\n    refreshExpandedChildren,\n    expandPersistedDirectories,\n    loadProjectDirectory,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/core/path.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/core/rules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/core/tree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/file-manager/fs/ops.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":15,"messageId":"unexpectedAny","endLine":28,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[939,942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[939,942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface FsDirectoryHandleWithIteration extends FileSystemDirectoryHandle {\n  values?: () => AsyncIterable<FileSystemHandle>;\n  entries?: () => AsyncIterable<[string, FileSystemHandle]>;\n}\n\nfunction getDirectoryIterator(\n  handle: FileSystemDirectoryHandle,\n): AsyncIterable<FileSystemHandle> | AsyncIterable<[string, FileSystemHandle]> | null {\n  return (\n    (handle as FsDirectoryHandleWithIteration).values?.() ??\n    (handle as FsDirectoryHandleWithIteration).entries?.() ??\n    null\n  );\n}\n\nexport async function assertEntryDoesNotExist(params: {\n  targetDirHandle: FileSystemDirectoryHandle;\n  entryName: string;\n  kind: 'file' | 'directory';\n}) {\n  try {\n    if (params.kind === 'file') {\n      await params.targetDirHandle.getFileHandle(params.entryName);\n    } else {\n      await params.targetDirHandle.getDirectoryHandle(params.entryName);\n    }\n    throw new Error(`Target already exists: ${params.entryName}`);\n  } catch (e: any) {\n    if (e?.name !== 'NotFoundError') throw e;\n  }\n}\n\nexport async function copyFileToDirectory(params: {\n  sourceHandle: FileSystemFileHandle;\n  fileName: string;\n  targetDirHandle: FileSystemDirectoryHandle;\n}) {\n  const file = await params.sourceHandle.getFile();\n  const targetHandle = await params.targetDirHandle.getFileHandle(params.fileName, {\n    create: true,\n  });\n\n  const createWritable = (targetHandle as FileSystemFileHandle).createWritable;\n  if (typeof createWritable !== 'function') {\n    throw new Error('Failed to move file: createWritable is not available');\n  }\n\n  const writable = await (targetHandle as FileSystemFileHandle).createWritable();\n  await writable.write(file);\n  await writable.close();\n}\n\nexport async function copyDirectoryRecursive(params: {\n  sourceDirHandle: FileSystemDirectoryHandle;\n  targetDirHandle: FileSystemDirectoryHandle;\n}): Promise<void> {\n  const iterator = getDirectoryIterator(params.sourceDirHandle);\n  if (!iterator) return;\n\n  for await (const value of iterator) {\n    const handle = (Array.isArray(value) ? value[1] : value) as\n      | FileSystemFileHandle\n      | FileSystemDirectoryHandle;\n\n    if (handle.kind === 'file') {\n      await copyFileToDirectory({\n        sourceHandle: handle as FileSystemFileHandle,\n        fileName: handle.name,\n        targetDirHandle: params.targetDirHandle,\n      });\n      continue;\n    }\n\n    const nextTargetDir = await params.targetDirHandle.getDirectoryHandle(handle.name, {\n      create: true,\n    });\n    await copyDirectoryRecursive({\n      sourceDirHandle: handle as FileSystemDirectoryHandle,\n      targetDirHandle: nextTargetDir,\n    });\n  }\n}\n\nexport async function renameDirectoryFallback(params: {\n  sourceDirHandle: FileSystemDirectoryHandle;\n  sourceName: string;\n  parentDirHandle: FileSystemDirectoryHandle;\n  newName: string;\n}): Promise<void> {\n  const nextDir = await params.parentDirHandle.getDirectoryHandle(params.newName, {\n    create: true,\n  });\n  await copyDirectoryRecursive({\n    sourceDirHandle: params.sourceDirHandle,\n    targetDirHandle: nextDir,\n  });\n  await params.parentDirHandle.removeEntry(params.sourceName, { recursive: true });\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/i18n.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/pages/index.vue","messages":[{"ruleId":"vue/multi-word-component-names","severity":1,"message":"Component name \"index\" should always be multi-word.","line":1,"column":1,"messageId":"unexpected"},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fm' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":7,"messageId":"unusedVar","endLine":29,"endColumn":9},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":9,"messageId":"unexpectedAny","endLine":185,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6111,6114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6111,6114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'playbackSpeedMatch' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":408,"column":9,"messageId":"unusedVar","endLine":408,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":415,"column":11,"messageId":"unexpectedAny","endLine":415,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12200,12203],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12200,12203],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport { Splitpanes, Pane } from 'splitpanes';\nimport 'splitpanes/dist/splitpanes.css';\nimport { useLocalStorage } from '@vueuse/core';\nimport TimelineExportModal from '~/components/TimelineExportModal.vue';\nimport EditorSettingsModal from '~/components/EditorSettingsModal.vue';\nimport ProjectSettingsModal from '~/components/ProjectSettingsModal.vue';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { useTimelineStore } from '~/stores/timeline.store';\nimport { useUiStore } from '~/stores/ui.store';\nimport { useMediaStore } from '~/stores/media.store';\nimport { storeToRefs } from 'pinia';\nimport { useFileManager } from '~/composables/fileManager/useFileManager';\nimport { getEffectiveHotkeyBindings } from '~/utils/hotkeys/effectiveHotkeys';\nimport { hotkeyFromKeyboardEvent, isEditableTarget } from '~/utils/hotkeys/hotkeyUtils';\nimport TimelineTabs from '~/components/timeline/TimelineTabs.vue';\nimport { DEFAULT_HOTKEYS, type HotkeyCommandId } from '~/utils/hotkeys/defaultHotkeys';\n\nconst { t } = useI18n();\nconst workspaceStore = useWorkspaceStore();\nconst projectStore = useProjectStore();\nconst timelineStore = useTimelineStore();\nconst uiStore = useUiStore();\nconst mediaStore = useMediaStore();\nconst focusStore = useFocusStore();\nconst selectionStore = useSelectionStore();\nconst fm = useFileManager();\n\nconst { currentTimelinePath } = storeToRefs(projectStore);\n\nconst isExportModalOpen = ref(false);\nconst isEditorSettingsOpen = ref(false);\nconst isProjectSettingsOpen = ref(false);\n\nfunction onGlobalDragOver(e: DragEvent) {\n  const types = e.dataTransfer?.types;\n  if (!types) return;\n  // Ignore internal drags (files dragged within the app from the file manager)\n  if (types.includes('application/gran-internal-file')) return;\n  if (types.includes('Files')) {\n    uiStore.isGlobalDragging = true;\n  }\n}\n\nfunction onGlobalDragLeave(e: DragEvent) {\n  if (!e.relatedTarget) {\n    uiStore.isGlobalDragging = false;\n  }\n}\n\nasync function onGlobalDrop(e: DragEvent) {\n  uiStore.isGlobalDragging = false;\n\n  // if uiStore.isFileManagerDragging is true, filemanager itself will handle the drop\n  if (uiStore.isFileManagerDragging) return;\n\n  // Snapshot files synchronously â dataTransfer.files becomes empty after any await\n  const files = e.dataTransfer?.files ? Array.from(e.dataTransfer.files) : [];\n  if (files.length === 0) return;\n  if (!workspaceStore.projectsHandle || !projectStore.currentProjectName) return;\n\n  const { useFileManager } = await import('~/composables/fileManager/useFileManager');\n  const fm = useFileManager();\n  await fm.handleFiles(files);\n}\n\nlet volumeHoldTimeout: number | null = null;\nlet volumeHoldInterval: number | null = null;\nlet volumeHoldKeyCode: string | null = null;\n\nlet zoomHoldTimeout: number | null = null;\nlet zoomHoldInterval: number | null = null;\nlet zoomHoldKeyCode: string | null = null;\n\nconst suppressedKeyupCodes = new Set<string>();\n\nfunction clearVolumeHoldTimers() {\n  if (volumeHoldTimeout !== null) {\n    window.clearTimeout(volumeHoldTimeout);\n    volumeHoldTimeout = null;\n  }\n  if (volumeHoldInterval !== null) {\n    window.clearInterval(volumeHoldInterval);\n    volumeHoldInterval = null;\n  }\n  volumeHoldKeyCode = null;\n}\n\nfunction clearZoomHoldTimers() {\n  if (zoomHoldTimeout !== null) {\n    window.clearTimeout(zoomHoldTimeout);\n    zoomHoldTimeout = null;\n  }\n  if (zoomHoldInterval !== null) {\n    window.clearInterval(zoomHoldInterval);\n    zoomHoldInterval = null;\n  }\n  zoomHoldKeyCode = null;\n}\n\nfunction startVolumeHotkeyHold(params: { step: number; keyCode: string }) {\n  clearVolumeHoldTimers();\n  volumeHoldKeyCode = params.keyCode;\n\n  timelineStore.setAudioVolume(timelineStore.audioVolume + params.step);\n\n  volumeHoldTimeout = window.setTimeout(() => {\n    volumeHoldInterval = window.setInterval(() => {\n      timelineStore.setAudioVolume(timelineStore.audioVolume + params.step);\n    }, 60);\n  }, 350);\n}\n\nfunction startZoomHotkeyHold(params: { step: number; keyCode: string }) {\n  clearZoomHoldTimers();\n  zoomHoldKeyCode = params.keyCode;\n\n  timelineStore.setTimelineZoom(timelineStore.timelineZoom + params.step);\n\n  zoomHoldTimeout = window.setTimeout(() => {\n    zoomHoldInterval = window.setInterval(() => {\n      timelineStore.setTimelineZoom(timelineStore.timelineZoom + params.step);\n    }, 60);\n  }, 350);\n}\n\nasync function onGlobalKeydown(e: KeyboardEvent) {\n  if (e.defaultPrevented) return;\n  if (e.repeat) return;\n\n  if (document.querySelector('[role=\"dialog\"]')) return;\n\n  if (e.key === 'Tab' && focusStore.tempFocus !== 'none') {\n    e.preventDefault();\n    focusStore.handleFocusHotkey();\n    return;\n  }\n\n  if (isEditableTarget(e.target)) return;\n  if (isEditableTarget(document.activeElement)) return;\n\n  const combo = hotkeyFromKeyboardEvent(e);\n  if (!combo) return;\n\n  const effective = getEffectiveHotkeyBindings(workspaceStore.userSettings.hotkeys);\n\n  const cmdOrder = DEFAULT_HOTKEYS.commands.map((c) => c.id);\n  const matched: HotkeyCommandId[] = [];\n  for (const cmdId of cmdOrder) {\n    const bindings = effective[cmdId];\n    if (bindings.includes(combo)) {\n      matched.push(cmdId);\n    }\n  }\n  if (matched.length === 0) return;\n\n  const focusAware = (() => {\n    const order: HotkeyCommandId[] = [];\n\n    const timeline = matched.filter((c) => c.startsWith('timeline.'));\n    const playback = matched.filter((c) => c.startsWith('playback.'));\n    const general = matched.filter((c) => c.startsWith('general.'));\n\n    if (focusStore.canUseTimelineHotkeys) {\n      order.push(...timeline, ...general, ...playback);\n    } else if (focusStore.canUsePlaybackHotkeys) {\n      order.push(...playback, ...general, ...timeline);\n    } else {\n      order.push(...general, ...timeline, ...playback);\n    }\n\n    return order[0] ?? matched[0]!;\n  })();\n\n  if (document.activeElement instanceof HTMLElement) {\n    if (!isEditableTarget(document.activeElement)) {\n      document.activeElement.blur();\n    }\n  }\n\n  e.preventDefault();\n  e.stopPropagation();\n  (e as any).stopImmediatePropagation?.();\n  suppressedKeyupCodes.add(e.code);\n\n  const cmd: string = focusAware;\n  if (cmd === 'general.focus') {\n    focusStore.handleFocusHotkey();\n    return;\n  }\n\n  if (cmd === 'general.undo') {\n    timelineStore.undoTimeline();\n    return;\n  }\n\n  if (cmd === 'general.redo') {\n    timelineStore.redoTimeline();\n    return;\n  }\n\n  if (cmd === 'general.delete') {\n    const selected = selectionStore.selectedEntity;\n    if (selected?.source === 'fileManager') {\n      uiStore.pendingFsEntryDelete = selected.entry;\n    } else if (selected?.source === 'timeline') {\n      if (selected.kind === 'track') {\n        timelineStore.deleteTrack(selected.trackId, { allowNonEmpty: true });\n        selectionStore.clearSelection();\n      } else {\n        timelineStore.deleteFirstSelectedItem();\n      }\n    } else if (timelineStore.selectedItemIds.length > 0) {\n      timelineStore.deleteFirstSelectedItem();\n    }\n    return;\n  }\n\n  if (cmd === 'general.deselect') {\n    selectionStore.clearSelection();\n    timelineStore.clearSelection();\n    timelineStore.selectTrack(null);\n    return;\n  }\n\n  if (cmd === 'timeline.rippleDelete') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.rippleDeleteFirstSelectedItem();\n    return;\n  }\n\n  if (cmd === 'timeline.trimToPlayheadLeft') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.trimToPlayheadLeftNoRipple();\n    return;\n  }\n\n  if (cmd === 'timeline.trimToPlayheadRight') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.trimToPlayheadRightNoRipple();\n    return;\n  }\n\n  if (cmd === 'timeline.rippleTrimLeft') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.rippleTrimLeft();\n    return;\n  }\n\n  if (cmd === 'timeline.rippleTrimRight') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.rippleTrimRight();\n    return;\n  }\n\n  if (cmd === 'timeline.advancedRippleTrimLeft') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.advancedRippleTrimLeft();\n    return;\n  }\n\n  if (cmd === 'timeline.advancedRippleTrimRight') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.advancedRippleTrimRight();\n    return;\n  }\n\n  if (cmd === 'timeline.jumpPrevBoundary') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.jumpToPrevClipBoundary();\n    return;\n  }\n\n  if (cmd === 'timeline.jumpNextBoundary') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.jumpToNextClipBoundary();\n    return;\n  }\n\n  if (cmd === 'timeline.jumpPrevBoundaryTrack') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.jumpToPrevClipBoundary({ currentTrackOnly: true });\n    return;\n  }\n\n  if (cmd === 'timeline.jumpNextBoundaryTrack') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.jumpToNextClipBoundary({ currentTrackOnly: true });\n    return;\n  }\n\n  if (cmd === 'timeline.splitAtPlayhead') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.splitClipAtPlayhead();\n    return;\n  }\n\n  if (cmd === 'timeline.splitAllAtPlayhead') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.splitAllClipsAtPlayhead();\n    return;\n  }\n\n  if (cmd === 'timeline.zoomIn') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    startZoomHotkeyHold({ step: 3, keyCode: e.code });\n    return;\n  }\n\n  if (cmd === 'timeline.zoomOut') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    startZoomHotkeyHold({ step: -3, keyCode: e.code });\n    return;\n  }\n\n  if (cmd === 'timeline.zoomReset') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    timelineStore.setTimelineZoom(50);\n    return;\n  }\n\n  if (cmd === 'timeline.toggleDisableClip') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.toggleDisableTargetClip();\n    return;\n  }\n\n  if (cmd === 'timeline.toggleMuteClip') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.toggleMuteTargetClip();\n    return;\n  }\n\n  // --- Timeline Tabs ---\n  if (cmd.startsWith('timeline.tab')) {\n    const tabIndexStr = cmd.replace('timeline.tab', '');\n    const tabIndex = parseInt(tabIndexStr, 10);\n    if (!isNaN(tabIndex)) {\n      const openPaths = projectStore.projectSettings.timelines.openPaths;\n      if (tabIndex > 0 && tabIndex <= openPaths.length) {\n        const path = openPaths[tabIndex - 1];\n        if (path) {\n          projectStore.openTimelineFile(path);\n        }\n      }\n    }\n    return;\n  }\n\n  // --- Playback ---\n  if (cmd === 'playback.toggle') {\n    if (timelineStore.isPlaying) {\n      timelineStore.togglePlayback();\n    } else {\n      timelineStore.setPlaybackSpeed(1);\n      timelineStore.togglePlayback();\n    }\n    return;\n  }\n\n  if (cmd === 'playback.toStart') {\n    if (!focusStore.canUsePlaybackHotkeys) return;\n    timelineStore.goToStart();\n    return;\n  }\n\n  if (cmd === 'playback.toEnd') {\n    if (!focusStore.canUsePlaybackHotkeys) return;\n    timelineStore.goToEnd();\n    return;\n  }\n\n  if (cmd === 'general.mute') {\n    timelineStore.toggleAudioMuted();\n    return;\n  }\n\n  if (cmd === 'general.volumeUp') {\n    startVolumeHotkeyHold({ step: 0.05, keyCode: e.code });\n    return;\n  }\n\n  if (cmd === 'general.volumeDown') {\n    startVolumeHotkeyHold({ step: -0.05, keyCode: e.code });\n    return;\n  }\n\n  if (cmd === 'timeline.toggleVisibilityTrack') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.toggleVisibilityTargetTrack();\n    return;\n  }\n\n  if (cmd === 'timeline.toggleMuteTrack') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.toggleMuteTargetTrack();\n    return;\n  }\n\n  if (cmd === 'timeline.toggleSoloTrack') {\n    if (!focusStore.canUseTimelineHotkeys) return;\n    void timelineStore.toggleSoloTargetTrack();\n    return;\n  }\n\n  const playbackSpeedMatch = cmd.match(/^playback\\.(forward|backward)([\\d_]+)$/);\n}\n\nfunction onGlobalKeyup(e: KeyboardEvent) {\n  if (suppressedKeyupCodes.has(e.code)) {\n    e.preventDefault();\n    e.stopPropagation();\n    (e as any).stopImmediatePropagation?.();\n    suppressedKeyupCodes.delete(e.code);\n  }\n\n  if (volumeHoldKeyCode && e.code === volumeHoldKeyCode) {\n    clearVolumeHoldTimers();\n  }\n  if (zoomHoldKeyCode && e.code === zoomHoldKeyCode) {\n    clearZoomHoldTimers();\n  }\n}\n\nfunction onGlobalBlur() {\n  suppressedKeyupCodes.clear();\n  clearVolumeHoldTimers();\n  clearZoomHoldTimers();\n}\n\nonMounted(() => {\n  window.addEventListener('keydown', onGlobalKeydown, true);\n  window.addEventListener('keyup', onGlobalKeyup, true);\n  window.addEventListener('blur', onGlobalBlur);\n});\n\nonUnmounted(() => {\n  window.removeEventListener('keydown', onGlobalKeydown, true);\n  window.removeEventListener('keyup', onGlobalKeyup, true);\n  window.removeEventListener('blur', onGlobalBlur);\n  clearVolumeHoldTimers();\n  clearZoomHoldTimers();\n});\n\nuseHead({\n  title: t('navigation.granVideoEditor'),\n});\n\nconst mainSplitSizes = useLocalStorage<number[]>('gran-editor-main-split-v4', [40, 60]);\nconst topSplitSizes = useLocalStorage<number[]>('gran-editor-top-split-v4', [20, 60, 20]);\n\nfunction onMainSplitResize(event: { panes: { size: number }[] }) {\n  if (Array.isArray(event?.panes)) {\n    mainSplitSizes.value = event.panes.map((p) => p.size);\n  }\n}\n\nfunction onTopSplitResize(event: { panes: { size: number }[] }) {\n  if (Array.isArray(event?.panes)) {\n    topSplitSizes.value = event.panes.map((p) => p.size);\n  }\n}\n\nconst newProjectName = ref('');\nconst isStartingUp = ref(true);\n\nwatch(currentTimelinePath, async (newPath) => {\n  if (newPath && projectStore.currentProjectName) {\n    focusStore.setActiveTimelinePath(newPath);\n    await timelineStore.loadTimeline();\n    void timelineStore.loadTimelineMetadata();\n  }\n});\n\nonMounted(async () => {\n  try {\n    await workspaceStore.init();\n\n    if (\n      workspaceStore.workspaceHandle &&\n      workspaceStore.userSettings.openLastProjectOnStart &&\n      workspaceStore.lastProjectName &&\n      workspaceStore.projects.includes(workspaceStore.lastProjectName)\n    ) {\n      await projectStore.openProject(workspaceStore.lastProjectName);\n      uiStore.restoreFileTreeStateOnce(workspaceStore.lastProjectName);\n      // Timeline will be loaded by watcher on currentTimelinePath change\n    }\n  } finally {\n    isStartingUp.value = false;\n  }\n});\n\nasync function createNewProject() {\n  if (!newProjectName.value.trim()) return;\n  await projectStore.createProject(newProjectName.value.trim());\n  if (workspaceStore.userSettings.openLastProjectOnStart) {\n    await projectStore.openProject(newProjectName.value.trim());\n    // Timeline will be loaded by watcher\n  }\n  newProjectName.value = '';\n}\n\nfunction leaveProject() {\n  timelineStore.resetTimelineState();\n  mediaStore.resetMediaState();\n  projectStore.closeProject();\n}\n</script>\n\n<template>\n  <div\n    class=\"flex flex-col h-screen w-screen overflow-hidden bg-ui-bg text-ui-text\"\n    @dragover.prevent=\"onGlobalDragOver\"\n    @dragleave.prevent=\"onGlobalDragLeave\"\n    @drop.prevent=\"onGlobalDrop\"\n  >\n    <!-- Loading Screen -->\n    <div v-if=\"isStartingUp\" class=\"flex flex-col items-center justify-center flex-1 bg-ui-bg\">\n      <UIcon\n        name=\"i-heroicons-arrow-path\"\n        class=\"w-10 h-10 text-primary-500 shrink-0 animate-spin\"\n      />\n      <span class=\"mt-4 text-ui-text-muted font-medium tracking-wide animate-pulse\">\n        {{ t('common.loading', 'Loading...') }}\n      </span>\n    </div>\n\n    <!-- Welcome / Select Folder Screen -->\n    <div\n      v-else-if=\"!workspaceStore.workspaceHandle\"\n      class=\"flex flex-col items-center justify-center flex-1 bg-linear-to-br from-primary-950 via-ui-bg-elevated to-black p-6\"\n    >\n      <div\n        class=\"max-w-md w-full text-center space-y-6 bg-ui-bg-elevated/50 p-8 rounded-2xl backdrop-blur-sm border border-ui-border/50 shadow-2xl\"\n      >\n        <div\n          class=\"mx-auto w-16 h-16 bg-primary-500/20 rounded-full flex items-center justify-center mb-6\"\n        >\n          <UIcon name=\"i-heroicons-film\" class=\"w-8 h-8 text-primary-400\" />\n        </div>\n\n        <h1\n          class=\"text-3xl font-bold bg-clip-text text-transparent bg-linear-to-r from-primary-300 to-primary-200\"\n        >\n          Gran Video Editor\n        </h1>\n\n        <p class=\"text-ui-text-muted\">\n          {{\n            t(\n              'granVideoEditor.welcome.selectFolder',\n              'Select a workspace folder on your computer. This folder will store all your project files, media proxies, and cache.',\n            )\n          }}\n        </p>\n\n        <div\n          v-if=\"workspaceStore.error\"\n          class=\"text-error-400 text-sm bg-error-400/10 p-3 rounded-lg border border-error-400/20\"\n        >\n          {{ workspaceStore.error }}\n        </div>\n\n        <UButton\n          v-if=\"workspaceStore.isApiSupported\"\n          size=\"lg\"\n          variant=\"solid\"\n          color=\"primary\"\n          icon=\"i-heroicons-folder-open\"\n          class=\"w-full justify-center transition-all hover:scale-[1.02]\"\n          :label=\"t('granVideoEditor.welcome.openWorkspace', 'Select Workspace Folder')\"\n          :loading=\"workspaceStore.isLoading\"\n          @click=\"workspaceStore.openWorkspace\"\n        />\n        <div v-else class=\"text-orange-400 text-sm\">\n          {{\n            t(\n              'granVideoEditor.fileManager.unsupported',\n              'File System Access API is not supported in this browser',\n            )\n          }}\n        </div>\n      </div>\n    </div>\n\n    <!-- Projects List Screen -->\n    <div\n      v-else-if=\"!projectStore.currentProjectName\"\n      class=\"flex flex-col flex-1 bg-ui-bg p-8 overflow-y-auto\"\n    >\n      <div class=\"max-w-5xl w-full mx-auto space-y-8 pb-12\">\n        <div class=\"flex items-center justify-between\">\n          <div>\n            <h1 class=\"text-2xl font-bold text-ui-text\">\n              {{ t('granVideoEditor.projects.title', 'Projects') }}\n            </h1>\n            <p class=\"text-ui-text-muted text-sm mt-1\">\n              Workspace: {{ workspaceStore.workspaceHandle?.name }}\n            </p>\n          </div>\n          <UButton\n            size=\"sm\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-arrow-left-on-rectangle\"\n            :label=\"t('granVideoEditor.projects.changeWorkspace', 'Change Workspace')\"\n            @click=\"workspaceStore.resetWorkspace\"\n          />\n        </div>\n\n        <div v-if=\"workspaceStore.error\" class=\"text-error-400 text-sm\">\n          {{ workspaceStore.error }}\n        </div>\n\n        <!-- Last Project Hero Section -->\n        <div\n          v-if=\"\n            workspaceStore.lastProjectName &&\n            workspaceStore.projects.includes(workspaceStore.lastProjectName)\n          \"\n          class=\"bg-linear-to-r from-primary-950/80 to-primary-900/40 border border-primary-500/30 rounded-2xl p-8 flex flex-col md:flex-row items-center justify-between gap-6\"\n        >\n          <div class=\"space-y-2\">\n            <span class=\"text-primary-400 text-xs font-bold uppercase tracking-widest\">\n              {{ t('granVideoEditor.projects.continueWorking', 'Continue Working') }}\n            </span>\n            <h2 class=\"text-3xl font-bold text-ui-text\">{{ workspaceStore.lastProjectName }}</h2>\n          </div>\n          <UButton\n            size=\"xl\"\n            color=\"primary\"\n            class=\"px-8 shadow-lg shadow-primary-500/20\"\n            icon=\"i-heroicons-play\"\n            :label=\"t('granVideoEditor.projects.openLast', 'Open Project')\"\n            @click=\"\n              async () => {\n                if (workspaceStore.lastProjectName) {\n                  leaveProject();\n                  await projectStore.openProject(workspaceStore.lastProjectName);\n                  uiStore.restoreFileTreeStateOnce(workspaceStore.lastProjectName);\n                  await timelineStore.loadTimeline();\n                  void timelineStore.loadTimelineMetadata();\n                }\n              }\n            \"\n          />\n        </div>\n\n        <div class=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6\">\n          <!-- Create New Project Card -->\n          <div\n            class=\"bg-ui-bg-elevated border border-ui-border rounded-xl p-6 flex flex-col gap-4 shadow-xl\"\n          >\n            <h3 class=\"font-medium text-ui-text\">\n              {{ t('granVideoEditor.projects.newProject', 'New Project') }}\n            </h3>\n            <UInput\n              v-model=\"newProjectName\"\n              :placeholder=\"t('granVideoEditor.projects.projectNamePlaceholder', 'Project Name')\"\n              @keyup.enter=\"createNewProject\"\n            />\n            <UButton\n              color=\"primary\"\n              variant=\"soft\"\n              class=\"justify-center mt-auto\"\n              :loading=\"workspaceStore.isLoading\"\n              :disabled=\"!newProjectName.trim()\"\n              :label=\"t('common.create', 'Create')\"\n              @click=\"createNewProject\"\n            />\n          </div>\n\n          <!-- Existing Projects -->\n          <div\n            v-for=\"project in workspaceStore.projects\"\n            :key=\"project\"\n            class=\"bg-ui-bg-elevated border border-ui-border rounded-xl p-6 flex flex-col hover:border-primary-500/50 hover:bg-ui-bg-accent transition-all cursor-pointer group shadow-lg\"\n            @click=\"\n              async () => {\n                leaveProject();\n                await projectStore.openProject(project);\n                uiStore.restoreFileTreeStateOnce(project);\n                await timelineStore.loadTimeline();\n                void timelineStore.loadTimelineMetadata();\n              }\n            \"\n          >\n            <div class=\"flex items-center gap-3 mb-4\">\n              <div\n                class=\"w-10 h-10 rounded-lg bg-ui-bg-accent flex items-center justify-center group-hover:bg-primary-500/10 transition-colors\"\n              >\n                <UIcon\n                  name=\"i-heroicons-film\"\n                  class=\"w-5 h-5 text-ui-text-muted group-hover:text-primary-400 transition-colors\"\n                />\n              </div>\n              <h3\n                class=\"font-medium text-ui-text truncate group-hover:text-primary-300 transition-colors\"\n              >\n                {{ project }}\n              </h3>\n            </div>\n            <div class=\"mt-auto flex justify-end\">\n              <UButton\n                size=\"sm\"\n                variant=\"ghost\"\n                color=\"primary\"\n                icon=\"i-heroicons-arrow-right\"\n                class=\"opacity-0 group-hover:opacity-100 transition-all translate-x-1 group-hover:translate-x-0\"\n                :label=\"t('common.open', 'Open')\"\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Editor Screen -->\n    <template v-else>\n      <div\n        class=\"flex items-center justify-between px-4 py-2.5 bg-ui-bg-elevated border-b border-ui-border\"\n      >\n        <div class=\"flex items-center gap-2 h-full flex-1 min-w-0\">\n          <UButton\n            size=\"sm\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-arrow-left\"\n            class=\"shrink-0\"\n            @click=\"leaveProject\"\n          />\n\n          <div\n            class=\"flex items-center gap-2 px-2 py-1 rounded-md hover:bg-ui-bg-accent cursor-pointer transition-colors shrink-0\"\n            @click=\"isProjectSettingsOpen = true\"\n          >\n            <span class=\"text-ui-text font-bold text-sm truncate max-w-[200px]\">\n              {{ projectStore.currentProjectName }}\n            </span>\n            <UIcon name=\"i-heroicons-pencil-square-20-solid\" class=\"w-4 h-4 text-ui-text-muted\" />\n          </div>\n\n          <!-- Timeline Tabs relocated from bottom -->\n          <TimelineTabs />\n        </div>\n\n        <div class=\"flex items-center gap-2\">\n          <UButton\n            size=\"sm\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-arrow-uturn-left\"\n            :disabled=\"!timelineStore.historyStore.canUndo\"\n            :title=\"t('common.undo') + ' (Ctrl+Z)'\"\n            @click=\"timelineStore.undoTimeline()\"\n          />\n          <UButton\n            size=\"sm\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-arrow-uturn-right\"\n            :disabled=\"!timelineStore.historyStore.canRedo\"\n            :title=\"t('common.redo') + ' (Ctrl+Shift+Z)'\"\n            @click=\"timelineStore.redoTimeline()\"\n          />\n\n          <div class=\"w-px h-4 bg-ui-border mx-1\" />\n\n          <UButton\n            size=\"sm\"\n            variant=\"ghost\"\n            color=\"neutral\"\n            icon=\"i-heroicons-cog-6-tooth\"\n            :title=\"t('videoEditor.settings.title', 'Editor settings')\"\n            @click=\"isEditorSettingsOpen = true\"\n          />\n          <UButton\n            size=\"sm\"\n            variant=\"soft\"\n            color=\"primary\"\n            icon=\"i-heroicons-arrow-down-tray\"\n            :disabled=\"timelineStore.duration <= 0\"\n            :label=\"t('videoEditor.export.confirm', 'Export')\"\n            @click=\"isExportModalOpen = true\"\n          />\n        </div>\n      </div>\n\n      <ClientOnly>\n        <Splitpanes\n          class=\"flex-1 min-h-0 editor-splitpanes\"\n          horizontal\n          @resized=\"onMainSplitResize\"\n        >\n          <Pane :size=\"mainSplitSizes[0]\" min-size=\"10\">\n            <Splitpanes class=\"editor-splitpanes\" @resized=\"onTopSplitResize\">\n              <Pane :size=\"topSplitSizes[0]\" min-size=\"5\">\n                <FileManager class=\"h-full\" />\n              </Pane>\n              <Pane :size=\"topSplitSizes[1]\" min-size=\"10\">\n                <Monitor class=\"h-full\" />\n              </Pane>\n              <Pane :size=\"topSplitSizes[2]\" min-size=\"5\">\n                <Preview class=\"h-full\" />\n              </Pane>\n            </Splitpanes>\n          </Pane>\n          <Pane :size=\"mainSplitSizes[1]\" min-size=\"10\">\n            <Timeline class=\"h-full\" />\n          </Pane>\n        </Splitpanes>\n      </ClientOnly>\n\n      <TimelineExportModal v-model:open=\"isExportModalOpen\" @exported=\"() => {}\" />\n\n      <EditorSettingsModal v-model:open=\"isEditorSettingsOpen\" />\n\n      <ProjectSettingsModal v-model:open=\"isProjectSettingsOpen\" />\n\n      <div\n        v-if=\"uiStore.isGlobalDragging && !uiStore.isFileManagerDragging\"\n        class=\"fixed inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-xs transition-opacity pointer-events-none\"\n      >\n        <div\n          class=\"flex flex-col items-center justify-center p-12 bg-ui-bg-elevated/90 border border-primary-500/50 rounded-3xl shadow-2xl animate-pulse-slow\"\n        >\n          <UIcon name=\"i-heroicons-arrow-down-tray\" class=\"w-20 h-20 text-primary-500 mb-6\" />\n          <h2 class=\"text-3xl font-bold text-white mb-2 text-center\">\n            {{ t('videoEditor.fileManager.actions.dropFilesHere', 'Drop files here') }}\n          </h2>\n          <div class=\"space-y-4 text-center max-w-md\">\n            <p class=\"text-lg text-ui-text-muted\">\n              {{\n                t(\n                  'videoEditor.fileManager.actions.dropFilesGlobalDescription',\n                  'Release files to automatically save them to the project sources folder',\n                )\n              }}\n            </p>\n            <div\n              class=\"flex items-center justify-center gap-2 py-2 px-4 bg-primary-500/10 rounded-xl border border-primary-400/20\"\n            >\n              <UIcon name=\"i-heroicons-folder\" class=\"w-5 h-5 text-primary-400\" />\n              <p class=\"text-sm font-medium text-primary-400\">\n                {{\n                  t(\n                    'videoEditor.fileManager.actions.dropToFolderHint',\n                    'Drag to the File Manager on the left to upload to a specific folder',\n                  )\n                }}\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </template>\n  </div>\n</template>\n\n<style>\n/* Custom theme for splitpanes matching Gran Video Editor dark mode */\n.editor-splitpanes {\n  background-color: transparent;\n}\n.editor-splitpanes .splitpanes__pane {\n  background-color: transparent;\n}\n.editor-splitpanes > .splitpanes__splitter {\n  background-color: var(--color-ui-border);\n  position: relative;\n  box-sizing: border-box;\n}\n.editor-splitpanes > .splitpanes__splitter:before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  transition: background-color 0.2s;\n  background-color: transparent;\n  z-index: 10;\n}\n.editor-splitpanes > .splitpanes__splitter:hover:before {\n  background-color: var(--color-primary-500);\n}\n.editor-splitpanes.splitpanes--vertical > .splitpanes__splitter {\n  width: 2px;\n  cursor: col-resize;\n}\n.editor-splitpanes.splitpanes--vertical > .splitpanes__splitter:before {\n  left: -3px;\n  right: -3px;\n  height: 100%;\n}\n.editor-splitpanes.splitpanes--horizontal > .splitpanes__splitter {\n  height: 2px;\n  cursor: row-resize;\n}\n.editor-splitpanes.splitpanes--horizontal > .splitpanes__splitter:before {\n  top: -3px;\n  bottom: -3px;\n  width: 100%;\n}\n</style>\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/plugins/effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/plugins/i18n.client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/repositories/gran-fs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/repositories/project-meta.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/repositories/project-settings.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/repositories/workspace-handle.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/repositories/workspace-settings.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/focus.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/history.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/media.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":18,"messageId":"unexpectedAny","endLine":24,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[631,634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[631,634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":50,"messageId":"unexpectedAny","endLine":150,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4481,4484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4481,4484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia';\nimport { ref } from 'vue';\n\nimport { useWorkspaceStore } from './workspace.store';\nimport { useProjectStore } from './project.store';\nimport { getExportWorkerClient } from '~/utils/video-editor/worker-client';\nimport { getProjectCacheSegments } from '~/utils/vardata-paths';\n\nexport interface MediaMetadata {\n  source: {\n    size: number;\n    lastModified: number;\n  };\n  duration: number;\n  video?: {\n    width: number;\n    height: number;\n    displayWidth: number;\n    displayHeight: number;\n    rotation: number;\n    codec: string;\n    parsedCodec: string;\n    fps: number;\n    colorSpace?: any;\n  };\n  audio?: {\n    codec: string;\n    parsedCodec: string;\n    sampleRate: number;\n    channels: number;\n  };\n  audioPeaks?: number[][];\n}\n\nexport const useMediaStore = defineStore('media', () => {\n  const workspaceStore = useWorkspaceStore();\n  const projectStore = useProjectStore();\n\n  const mediaMetadata = ref<Record<string, MediaMetadata>>({});\n\n  function resetMediaState() {\n    mediaMetadata.value = {};\n  }\n\n  function getCacheFileName(projectRelativePath: string): string {\n    return `${encodeURIComponent(projectRelativePath)}.json`;\n  }\n\n  async function ensureCacheDir(): Promise<FileSystemDirectoryHandle | null> {\n    if (!workspaceStore.workspaceHandle || !projectStore.currentProjectId) return null;\n    const parts = getProjectCacheSegments(projectStore.currentProjectId);\n    let dir = workspaceStore.workspaceHandle;\n    for (const segment of parts) {\n      dir = await dir.getDirectoryHandle(segment, { create: true });\n    }\n    return dir;\n  }\n\n  async function ensureFilesMetaDir(): Promise<FileSystemDirectoryHandle | null> {\n    const projectCacheDir = await ensureCacheDir();\n    if (!projectCacheDir) return null;\n    return await projectCacheDir.getDirectoryHandle('files-meta', { create: true });\n  }\n\n  async function getOrFetchMetadataByPath(path: string, options?: { forceRefresh?: boolean }) {\n    const handle = await projectStore.getFileHandleByPath(path);\n    if (!handle) return null;\n    return await getOrFetchMetadata(handle, path, options);\n  }\n\n  async function getOrFetchMetadata(\n    fileHandle: FileSystemFileHandle,\n    projectRelativePath: string,\n    options?: { forceRefresh?: boolean },\n  ): Promise<MediaMetadata | null> {\n    const file = await fileHandle.getFile();\n    const cacheKey = projectRelativePath;\n\n    const fileType = typeof file.type === 'string' ? file.type : '';\n    const isKnownMediaByMime =\n      fileType.startsWith('video/') ||\n      fileType.startsWith('audio/') ||\n      fileType.startsWith('image/');\n    const isKnownMediaByExt = (() => {\n      const ext = projectRelativePath.split('.').pop()?.toLowerCase() ?? '';\n      if (!ext) return false;\n      return [\n        // Video\n        'mp4',\n        'mov',\n        'mkv',\n        'webm',\n        'm4v',\n        'avi',\n        // Audio\n        'mp3',\n        'wav',\n        'ogg',\n        'm4a',\n        'aac',\n        'flac',\n        // Images\n        'png',\n        'jpg',\n        'jpeg',\n        'webp',\n        'bmp',\n        'gif',\n        'tiff',\n        'tif',\n      ].includes(ext);\n    })();\n\n    if (!isKnownMediaByMime && !isKnownMediaByExt) return null;\n\n    if (!options?.forceRefresh && mediaMetadata.value[cacheKey]) {\n      const cached = mediaMetadata.value[cacheKey]!;\n      if (cached.source.size === file.size && cached.source.lastModified === file.lastModified) {\n        return cached;\n      }\n    }\n\n    const metaDir = await ensureFilesMetaDir();\n    const cacheFileName = getCacheFileName(projectRelativePath);\n\n    if (!options?.forceRefresh && metaDir) {\n      try {\n        const cacheHandle = await metaDir.getFileHandle(cacheFileName);\n        const cacheFile = await cacheHandle.getFile();\n        const text = await cacheFile.text();\n        const parsed = JSON.parse(text) as MediaMetadata;\n        if (parsed.source.size === file.size && parsed.source.lastModified === file.lastModified) {\n          mediaMetadata.value[cacheKey] = parsed;\n          return parsed;\n        }\n      } catch {\n        // Cache miss\n      }\n    }\n\n    try {\n      const { client } = getExportWorkerClient();\n      const meta = await client.extractMetadata(fileHandle);\n\n      if (meta) {\n        mediaMetadata.value[cacheKey] = meta;\n\n        if (metaDir) {\n          const cacheHandle = await metaDir.getFileHandle(cacheFileName, { create: true });\n          const writable = await (cacheHandle as any).createWritable();\n          await writable.write(JSON.stringify(meta, null, 2));\n          await writable.close();\n        }\n\n        return meta;\n      }\n      return null;\n    } catch (e) {\n      console.error('Failed to fetch metadata for', projectRelativePath, e);\n      return null;\n    }\n  }\n\n  function setAudioPeaks(projectRelativePath: string, peaks: number[][]) {\n    if (mediaMetadata.value[projectRelativePath]) {\n      mediaMetadata.value[projectRelativePath].audioPeaks = peaks;\n    }\n  }\n\n  return {\n    mediaMetadata,\n    getOrFetchMetadataByPath,\n    getOrFetchMetadata,\n    resetMediaState,\n    setAudioPeaks,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/project.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/proxy.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":26,"messageId":"unexpectedAny","endLine":104,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3457,3460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3457,3460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":28,"messageId":"unexpectedAny","endLine":184,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6176,6179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6176,6179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":190,"column":38,"messageId":"dynamicDelete","endLine":190,"endColumn":57},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":193,"column":34,"messageId":"dynamicDelete","endLine":193,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":17,"messageId":"unexpectedAny","endLine":198,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6751,6754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6751,6754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":202,"column":34,"messageId":"dynamicDelete","endLine":202,"endColumn":53},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":205,"column":30,"messageId":"dynamicDelete","endLine":205,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":17,"messageId":"unexpectedAny","endLine":236,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7986,7989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7986,7989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ref, watch, markRaw } from 'vue';\nimport { defineStore } from 'pinia';\nimport PQueue from 'p-queue';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { useProjectStore } from '~/stores/project.store';\nimport { getExportWorkerClient, setExportHostApi } from '~/utils/video-editor/worker-client';\nimport { VIDEO_DIR_NAME } from '~/utils/constants';\nimport { getProjectProxiesSegments } from '~/utils/vardata-paths';\n\nexport const useProxyStore = defineStore('proxy', () => {\n  const workspaceStore = useWorkspaceStore();\n  const projectStore = useProjectStore();\n\n  const generatingProxies = ref<Set<string>>(new Set());\n  const existingProxies = ref<Set<string>>(new Set());\n  const proxyProgress = ref<Record<string, number>>({});\n  const proxyAbortControllers = ref<Record<string, AbortController>>({});\n  // Tracks paths currently executing in worker (not just queued)\n  const activeWorkerPaths = ref<Set<string>>(new Set());\n\n  const proxyQueue = ref(\n    markRaw(new PQueue({ concurrency: workspaceStore.userSettings.optimization.proxyConcurrency })),\n  );\n\n  watch(\n    () => workspaceStore.userSettings.optimization.proxyConcurrency,\n    (val) => {\n      proxyQueue.value.concurrency = val;\n    },\n  );\n\n  function getProxyFileName(projectRelativePath: string): string {\n    return `${encodeURIComponent(projectRelativePath)}.webm`;\n  }\n\n  async function ensureProjectProxiesDir(): Promise<FileSystemDirectoryHandle | null> {\n    if (!workspaceStore.workspaceHandle || !projectStore.currentProjectId) return null;\n    try {\n      const parts = getProjectProxiesSegments(projectStore.currentProjectId);\n      let dir = workspaceStore.workspaceHandle;\n      for (const segment of parts) {\n        dir = await dir.getDirectoryHandle(segment, { create: true });\n      }\n      return dir;\n    } catch {\n      return null;\n    }\n  }\n\n  async function checkExistingProxies(paths: string[]) {\n    const dir = await ensureProjectProxiesDir();\n    if (!dir) return;\n\n    for (const path of paths) {\n      if (!path.startsWith(`${VIDEO_DIR_NAME}/`)) continue;\n      try {\n        await dir.getFileHandle(getProxyFileName(path));\n        existingProxies.value.add(path);\n      } catch {\n        existingProxies.value.delete(path);\n      }\n    }\n  }\n\n  async function generateProxy(\n    fileHandle: FileSystemFileHandle,\n    projectRelativePath: string,\n    options?: { signal?: AbortSignal },\n  ): Promise<void> {\n    if (generatingProxies.value.has(projectRelativePath)) return;\n    if (!projectRelativePath.startsWith(`${VIDEO_DIR_NAME}/`)) return;\n\n    const dir = await ensureProjectProxiesDir();\n    if (!dir) throw new Error('Could not access proxies directory');\n\n    generatingProxies.value.add(projectRelativePath);\n    proxyProgress.value[projectRelativePath] = 0;\n\n    const controller = new AbortController();\n    proxyAbortControllers.value = {\n      ...proxyAbortControllers.value,\n      [projectRelativePath]: controller,\n    };\n\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) controller.abort();\n      else {\n        signal.addEventListener(\n          'abort',\n          () => {\n            controller.abort();\n          },\n          { once: true },\n        );\n      }\n    }\n\n    try {\n      await proxyQueue.value.add(async () => {\n        try {\n          if (controller.signal.aborted) {\n            const abortErr = new Error('Proxy generation cancelled');\n            (abortErr as any).name = 'AbortError';\n            throw abortErr;\n          }\n\n          // Mark as actively executing in worker\n          activeWorkerPaths.value.add(projectRelativePath);\n\n          const proxyFilename = getProxyFileName(projectRelativePath);\n          const targetHandle = await dir.getFileHandle(proxyFilename, { create: true });\n\n          const { optimization } = workspaceStore.userSettings;\n\n          let width = 1280;\n          let height = 720;\n          if (optimization.proxyResolution === '360p') {\n            width = 640;\n            height = 360;\n          } else if (optimization.proxyResolution === '480p') {\n            width = 854;\n            height = 480;\n          } else if (optimization.proxyResolution === '1080p') {\n            width = 1920;\n            height = 1080;\n          }\n\n          const { client } = getExportWorkerClient();\n\n          setExportHostApi({\n            getFileHandleByPath: async (path) => projectStore.getFileHandleByPath(path),\n            onExportProgress: (progress) => {\n              proxyProgress.value[projectRelativePath] = progress;\n            },\n          });\n\n          const meta = await client.extractMetadata(fileHandle);\n          const durationUs = Math.round((meta.duration || 0) * 1_000_000);\n\n          if (!durationUs) throw new Error('Invalid video duration');\n\n          const videoClips = [\n            {\n              kind: 'clip',\n              id: 'proxy_video',\n              layer: 0,\n              source: { path: projectRelativePath },\n              timelineRange: { startUs: 0, durationUs },\n              sourceRange: { startUs: 0, durationUs },\n            },\n          ];\n\n          const audioClips = meta.audio\n            ? [\n                {\n                  kind: 'clip',\n                  id: 'proxy_audio',\n                  layer: 0,\n                  source: { path: projectRelativePath },\n                  timelineRange: { startUs: 0, durationUs },\n                  sourceRange: { startUs: 0, durationUs },\n                },\n              ]\n            : [];\n\n          const isOpusAudio =\n            typeof meta.audio?.codec === 'string' &&\n            meta.audio.codec.toLowerCase().startsWith('opus');\n\n          const exportOptions = {\n            format: 'webm',\n            videoCodec: 'vp09.00.10.08',\n            bitrate: optimization.proxyVideoBitrateMbps * 1_000_000,\n            audioBitrate: optimization.proxyAudioBitrateKbps * 1000,\n            audio: !!meta.audio,\n            audioCodec: 'opus',\n            audioPassthrough: optimization.proxyCopyOpusAudio && isOpusAudio,\n            width,\n            height,\n            fps: meta.video?.fps || 30,\n          };\n\n          await (client as any).exportTimeline(targetHandle, exportOptions, videoClips, audioClips);\n\n          existingProxies.value.add(projectRelativePath);\n        } finally {\n          activeWorkerPaths.value.delete(projectRelativePath);\n          generatingProxies.value.delete(projectRelativePath);\n          delete proxyProgress.value[projectRelativePath];\n\n          const nextControllers = { ...proxyAbortControllers.value };\n          delete nextControllers[projectRelativePath];\n          proxyAbortControllers.value = nextControllers;\n        }\n      });\n    } catch (e) {\n      if ((e as any)?.name === 'AbortError') {\n        return;\n      }\n      generatingProxies.value.delete(projectRelativePath);\n      delete proxyProgress.value[projectRelativePath];\n\n      const nextControllers = { ...proxyAbortControllers.value };\n      delete nextControllers[projectRelativePath];\n      proxyAbortControllers.value = nextControllers;\n      throw e;\n    }\n  }\n\n  async function cancelProxyGeneration(projectRelativePath: string) {\n    const controller = proxyAbortControllers.value[projectRelativePath];\n    if (controller && !controller.signal.aborted) {\n      controller.abort();\n    }\n\n    // If this path is actively running in worker, cancel via worker API\n    if (activeWorkerPaths.value.has(projectRelativePath)) {\n      try {\n        const { client } = getExportWorkerClient();\n        await client.cancelExport();\n      } catch {\n        // ignore\n      }\n    }\n  }\n\n  async function deleteProxy(projectRelativePath: string) {\n    if (!projectRelativePath.startsWith(`${VIDEO_DIR_NAME}/`)) return;\n    const dir = await ensureProjectProxiesDir();\n    if (!dir) return;\n\n    try {\n      await dir.removeEntry(getProxyFileName(projectRelativePath));\n      existingProxies.value.delete(projectRelativePath);\n    } catch (e: any) {\n      if (e?.name !== 'NotFoundError') {\n        console.warn('Failed to delete proxy', e);\n      }\n    }\n  }\n\n  async function getProxyFileHandle(\n    projectRelativePath: string,\n  ): Promise<FileSystemFileHandle | null> {\n    if (!projectRelativePath.startsWith(`${VIDEO_DIR_NAME}/`)) return null;\n    const dir = await ensureProjectProxiesDir();\n    if (!dir) return null;\n\n    try {\n      return await dir.getFileHandle(getProxyFileName(projectRelativePath));\n    } catch {\n      return null;\n    }\n  }\n\n  async function getProxyFile(projectRelativePath: string): Promise<File | null> {\n    if (!projectRelativePath.startsWith(`${VIDEO_DIR_NAME}/`)) return null;\n    const dir = await ensureProjectProxiesDir();\n    if (!dir) return null;\n\n    try {\n      const handle = await dir.getFileHandle(getProxyFileName(projectRelativePath));\n      return await handle.getFile();\n    } catch {\n      return null;\n    }\n  }\n\n  return {\n    generatingProxies,\n    existingProxies,\n    proxyProgress,\n    checkExistingProxies,\n    generateProxy,\n    cancelProxyGeneration,\n    deleteProxy,\n    getProxyFileHandle,\n    getProxyFile,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/selection.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/timeline-media-usage.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":17,"messageId":"unexpectedAny","endLine":142,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4315,4318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4315,4318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia';\nimport { computed, ref } from 'vue';\n\nimport { useProjectStore } from './project.store';\nimport { useWorkspaceStore } from './workspace.store';\n\nimport { parseTimelineFromOtio } from '~/timeline/otioSerializer';\nimport { createTimelineDocId } from '~/timeline/id';\n\nimport {\n  computeMediaUsageByTimelineDocs,\n  type MediaPathToTimelinesMap,\n} from '~/utils/timeline-media-usage';\n\ninterface FsDirectoryHandleWithIteration extends FileSystemDirectoryHandle {\n  values?: () => AsyncIterable<FileSystemHandle>;\n  entries?: () => AsyncIterable<[string, FileSystemHandle]>;\n}\n\nexport const useTimelineMediaUsageStore = defineStore('timeline-media-usage', () => {\n  const projectStore = useProjectStore();\n  const workspaceStore = useWorkspaceStore();\n\n  const mediaPathToTimelines = ref<MediaPathToTimelinesMap>({});\n  const isLoading = ref(false);\n  const error = ref<string | null>(null);\n  const lastScanAt = ref<number | null>(null);\n\n  const isReady = computed(() =>\n    Boolean(workspaceStore.projectsHandle && projectStore.currentProjectName),\n  );\n\n  async function getProjectDirHandle(): Promise<FileSystemDirectoryHandle | null> {\n    if (!workspaceStore.projectsHandle || !projectStore.currentProjectName) return null;\n    try {\n      return await workspaceStore.projectsHandle.getDirectoryHandle(\n        projectStore.currentProjectName,\n      );\n    } catch {\n      return null;\n    }\n  }\n\n  async function listTimelineFiles(params: {\n    projectDir: FileSystemDirectoryHandle;\n    maxEntries?: number;\n  }): Promise<string[]> {\n    const maxEntries = params.maxEntries ?? 50_000;\n    let seen = 0;\n\n    const result: string[] = [];\n\n    const walk = async (dir: FileSystemDirectoryHandle, basePath: string) => {\n      const iterator =\n        (dir as FsDirectoryHandleWithIteration).values?.() ??\n        (dir as FsDirectoryHandleWithIteration).entries?.();\n      if (!iterator) return;\n\n      for await (const value of iterator) {\n        if (seen >= maxEntries) {\n          throw new Error('Project too large to scan timelines');\n        }\n        seen += 1;\n\n        const handle = (Array.isArray(value) ? value[1] : value) as\n          | FileSystemFileHandle\n          | FileSystemDirectoryHandle;\n\n        const fullPath = basePath ? `${basePath}/${handle.name}` : handle.name;\n\n        if (handle.kind === 'directory') {\n          await walk(handle as FileSystemDirectoryHandle, fullPath);\n          continue;\n        }\n\n        if (fullPath.toLowerCase().endsWith('.otio')) {\n          result.push(fullPath);\n        }\n      }\n    };\n\n    await walk(params.projectDir, '');\n\n    return result;\n  }\n\n  async function readTimelineDocByPath(params: { timelinePath: string }) {\n    const handle = await projectStore.getFileHandleByPath(params.timelinePath);\n    if (!handle) return null;\n\n    const file = await handle.getFile();\n    const text = await file.text();\n\n    const nameFromPath = params.timelinePath.split('/').pop() ?? params.timelinePath;\n    const id = projectStore.currentProjectName\n      ? createTimelineDocId(projectStore.currentProjectName)\n      : createTimelineDocId('unknown');\n\n    return {\n      timelinePath: params.timelinePath,\n      timelineName: nameFromPath,\n      timelineDoc: parseTimelineFromOtio(text, {\n        id,\n        name: nameFromPath,\n        fps: projectStore.projectSettings.project.fps,\n      }),\n    };\n  }\n\n  async function refreshUsage() {\n    if (!isReady.value) {\n      mediaPathToTimelines.value = {};\n      error.value = null;\n      lastScanAt.value = null;\n      return;\n    }\n\n    const projectDir = await getProjectDirHandle();\n    if (!projectDir) {\n      mediaPathToTimelines.value = {};\n      error.value = 'Project directory is not available';\n      lastScanAt.value = null;\n      return;\n    }\n\n    isLoading.value = true;\n    error.value = null;\n\n    try {\n      const timelinePaths = await listTimelineFiles({ projectDir });\n\n      const timelines = (\n        await Promise.all(\n          timelinePaths.map(async (timelinePath) => await readTimelineDocByPath({ timelinePath })),\n        )\n      )\n        .filter(Boolean)\n        .map((t) => t!);\n\n      mediaPathToTimelines.value = computeMediaUsageByTimelineDocs(timelines).mediaPathToTimelines;\n      lastScanAt.value = Date.now();\n    } catch (e: any) {\n      mediaPathToTimelines.value = {};\n      error.value = String(e?.message ?? e);\n      lastScanAt.value = null;\n    } finally {\n      isLoading.value = false;\n    }\n  }\n\n  return {\n    mediaPathToTimelines,\n    isLoading,\n    error,\n    lastScanAt,\n    refreshUsage,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/timeline.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":42,"messageId":"unexpectedAny","endLine":41,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1571,1574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1571,1574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":50,"messageId":"unexpectedAny","endLine":41,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1579,1582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1579,1582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":30,"messageId":"unexpectedAny","endLine":43,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1627,1630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1627,1630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":30,"messageId":"unexpectedAny","endLine":50,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1834,1837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1834,1837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":30,"messageId":"unexpectedAny","endLine":55,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2061,2064],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2061,2064],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":40,"messageId":"unexpectedAny","endLine":59,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2176,2179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2176,2179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":48,"messageId":"unexpectedAny","endLine":59,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2184,2187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2184,2187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":28,"messageId":"unexpectedAny","endLine":61,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2230,2233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2230,2233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":28,"messageId":"unexpectedAny","endLine":68,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2409,2412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2409,2412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":39,"messageId":"unexpectedAny","endLine":99,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3400,3403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3400,3403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'allTrackIds' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":559,"column":11,"messageId":"unusedVar","endLine":559,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":926,"column":58,"messageId":"unexpectedAny","endLine":926,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30319,30322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30319,30322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1476,"column":41,"messageId":"unexpectedAny","endLine":1476,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46147,46150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46147,46150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1483,"column":17,"messageId":"unexpectedAny","endLine":1483,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46388,46391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46388,46391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1557,"column":17,"messageId":"unexpectedAny","endLine":1557,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[48500,48503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[48500,48503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unsafe-finally","severity":2,"message":"Unsafe usage of ReturnStatement.","line":1562,"column":48,"messageId":"unsafeUsage","endLine":1562,"endColumn":55},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1612,"column":30,"messageId":"unexpectedAny","endLine":1612,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50435,50438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50435,50438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore, storeToRefs } from 'pinia';\nimport { ref } from 'vue';\nimport PQueue from 'p-queue';\n\nimport type { TimelineDocument, TimelineMarker } from '~/timeline/types';\nimport type { TimelineCommand } from '~/timeline/commands';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport { parseTimelineFromOtio, serializeTimelineToOtio } from '~/timeline/otioSerializer';\nimport { selectTimelineDurationUs } from '~/timeline/selectors';\nimport { quantizeTimeUsToFrames, getDocFps, usToFrame, frameToUs } from '~/timeline/commands/utils';\nimport { VIDEO_DIR_NAME } from '~/utils/constants';\n\nimport { useProjectStore } from './project.store';\nimport { useMediaStore } from './media.store';\nimport { useHistoryStore } from './history.store';\nimport { useWorkspaceStore } from './workspace.store';\nimport { useProxyStore } from './proxy.store';\n\nexport const useTimelineStore = defineStore('timeline', () => {\n  const projectStore = useProjectStore();\n  const mediaStore = useMediaStore();\n  const historyStore = useHistoryStore();\n  const workspaceStore = useWorkspaceStore();\n  const proxyStore = useProxyStore();\n\n  const pendingDebouncedHistory = ref<{\n    snapshot: TimelineDocument;\n    cmd: TimelineCommand;\n    timeoutId: number;\n  } | null>(null);\n\n  function clearPendingDebouncedHistory() {\n    const pending = pendingDebouncedHistory.value;\n    if (!pending) return;\n    window.clearTimeout(pending.timeoutId);\n    pendingDebouncedHistory.value = null;\n  }\n\n  const projectRefs = (() => {\n    try {\n      return storeToRefs(projectStore as any) as any;\n    } catch {\n      return projectStore as any;\n    }\n  })();\n\n  const currentProjectName =\n    projectRefs?.currentProjectName && typeof projectRefs.currentProjectName === 'object'\n      ? projectRefs.currentProjectName\n      : ref((projectStore as any)?.currentProjectName ?? null);\n\n  const currentTimelinePath =\n    projectRefs?.currentTimelinePath && typeof projectRefs.currentTimelinePath === 'object'\n      ? projectRefs.currentTimelinePath\n      : ref((projectStore as any)?.currentTimelinePath ?? null);\n\n  const mediaRefs = (() => {\n    try {\n      return storeToRefs(mediaStore as any) as any;\n    } catch {\n      return mediaStore as any;\n    }\n  })();\n\n  const mediaMetadata =\n    mediaRefs?.mediaMetadata && typeof mediaRefs.mediaMetadata === 'object'\n      ? mediaRefs.mediaMetadata\n      : ref((mediaStore as any)?.mediaMetadata ?? {});\n\n  const DEFAULT_IMAGE_DURATION_US = 5_000_000;\n  const DEFAULT_IMAGE_SOURCE_DURATION_US = DEFAULT_IMAGE_DURATION_US;\n\n  const timelineDoc = ref<TimelineDocument | null>(null);\n\n  const isTimelineDirty = ref(false);\n  const isSavingTimeline = ref(false);\n  const timelineSaveError = ref<string | null>(null);\n\n  const isPlaying = ref(false);\n  const playbackSpeed = ref(1);\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const audioVolume = ref(1);\n  const audioMuted = ref(false);\n  const playbackGestureHandler = ref<((nextPlaying: boolean) => void) | null>(null);\n\n  const timelineZoom = ref(50);\n\n  const selectedItemIds = ref<string[]>([]);\n  const selectedTrackId = ref<string | null>(null);\n  const hoveredTrackId = ref<string | null>(null);\n  const selectedTransition = ref<{\n    trackId: string;\n    itemId: string;\n    edge: 'in' | 'out';\n  } | null>(null);\n\n  function getMarkers(): TimelineMarker[] {\n    const raw = (timelineDoc.value as any)?.metadata?.gran?.markers;\n    return Array.isArray(raw) ? (raw as TimelineMarker[]) : [];\n  }\n\n  function generateMarkerId(): string {\n    return `marker_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;\n  }\n\n  function addMarkerAtPlayhead() {\n    applyTimeline({\n      type: 'add_marker',\n      id: generateMarkerId(),\n      timeUs: currentTime.value,\n      text: '',\n    });\n  }\n\n  function updateMarker(markerId: string, patch: { timeUs?: number; text?: string }) {\n    applyTimeline({\n      type: 'update_marker',\n      id: markerId,\n      timeUs: patch.timeUs,\n      text: patch.text,\n    });\n  }\n\n  function removeMarker(markerId: string) {\n    applyTimeline({ type: 'remove_marker', id: markerId });\n  }\n\n  let persistTimelineTimeout: number | null = null;\n  let loadTimelineRequestId = 0;\n  let timelineRevision = 0;\n  let savedTimelineRevision = 0;\n\n  const timelineSaveQueue = new PQueue({ concurrency: 1 });\n\n  function clearSelection() {\n    selectedItemIds.value = [];\n    selectedTransition.value = null;\n  }\n\n  function clearSelectedTransition() {\n    selectedTransition.value = null;\n  }\n\n  function selectTransition(input: { trackId: string; itemId: string; edge: 'in' | 'out' } | null) {\n    selectedTrackId.value = null;\n    selectedItemIds.value = [];\n    selectedTransition.value = input;\n  }\n\n  function setPlaybackSpeed(speed: number) {\n    const parsed = Number(speed);\n    if (!Number.isFinite(parsed)) return;\n\n    const abs = Math.abs(parsed);\n    const clampedAbs = Math.max(0.1, Math.min(10, abs));\n\n    const sign = parsed < 0 ? -1 : 1;\n    playbackSpeed.value = clampedAbs * sign;\n  }\n\n  function setClipFreezeFrameFromPlayhead(input: { trackId: string; itemId: string }) {\n    const doc = timelineDoc.value;\n    if (!doc) throw new Error('Timeline not loaded');\n\n    const track = doc.tracks.find((t) => t.id === input.trackId) ?? null;\n    if (!track) throw new Error('Track not found');\n\n    const item = track.items.find((it) => it.id === input.itemId);\n    if (!item || item.kind !== 'clip') throw new Error('Clip not found');\n    if (item.clipType !== 'media') throw new Error('Only media clips can freeze frame');\n\n    const fps = getDocFps(doc);\n\n    const clipStartUs = item.timelineRange.startUs;\n    const clipEndUs = clipStartUs + item.timelineRange.durationUs;\n    const playheadUs = currentTime.value;\n\n    const usePlayhead = playheadUs >= clipStartUs && playheadUs < clipEndUs;\n    const localUs = usePlayhead ? playheadUs - clipStartUs : 0;\n    const sourceUsRaw = item.sourceRange.startUs + localUs;\n    const sourceUs = quantizeTimeUsToFrames(sourceUsRaw, fps, 'round');\n\n    updateClipProperties(input.trackId, input.itemId, { freezeFrameSourceUs: sourceUs });\n  }\n\n  function resetClipFreezeFrame(input: { trackId: string; itemId: string }) {\n    updateClipProperties(input.trackId, input.itemId, { freezeFrameSourceUs: undefined });\n  }\n\n  function selectTrack(trackId: string | null) {\n    selectedTrackId.value = trackId;\n    if (trackId) {\n      selectedTransition.value = null;\n      selectedItemIds.value = [];\n    }\n  }\n\n  function getHotkeyTargetClip(): { trackId: string; itemId: string } | null {\n    const doc = timelineDoc.value;\n    if (!doc) return null;\n\n    const selectedId = selectedItemIds.value[0];\n    if (selectedId) {\n      for (const track of doc.tracks) {\n        for (const it of track.items) {\n          if (it.kind !== 'clip') continue;\n          if (it.id !== selectedId) continue;\n          return { trackId: track.id, itemId: it.id };\n        }\n      }\n    }\n\n    const trackId = selectedTrackId.value;\n    if (!trackId) return null;\n    const track = doc.tracks.find((t) => t.id === trackId) ?? null;\n    if (!track) return null;\n\n    const atUs = currentTime.value;\n    for (const it of track.items) {\n      if (it.kind !== 'clip') continue;\n      const startUs = it.timelineRange.startUs;\n      const endUs = startUs + it.timelineRange.durationUs;\n      if (atUs >= startUs && atUs < endUs) {\n        return { trackId: track.id, itemId: it.id };\n      }\n    }\n\n    return null;\n  }\n\n  function getSelectedOrActiveTrackId(): string | null {\n    const doc = timelineDoc.value;\n    if (!doc) return null;\n\n    const selectedId = selectedItemIds.value[0];\n    if (selectedId) {\n      for (const track of doc.tracks) {\n        for (const it of track.items) {\n          if (it.kind !== 'clip') continue;\n          if (it.id === selectedId) return track.id;\n        }\n      }\n    }\n\n    return selectedTrackId.value;\n  }\n\n  function computeCutUs(doc: TimelineDocument, atUs: number): number {\n    const fps = getDocFps(doc);\n    const q = quantizeTimeUsToFrames(Number(atUs), fps, 'round');\n    const frame = usToFrame(q, fps, 'round');\n    return frameToUs(frame, fps);\n  }\n\n  async function trimToPlayheadLeftNoRipple() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    applyTimeline(\n      { type: 'split_item', trackId: target.trackId, itemId: target.itemId, atUs: cutUs },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    const updatedDoc = timelineDoc.value;\n    if (!updatedDoc) return;\n    const updatedTrack = updatedDoc.tracks.find((t) => t.id === target.trackId) ?? null;\n    if (!updatedTrack) return;\n\n    const right =\n      updatedTrack.items\n        .filter((it) => it.kind === 'clip')\n        .find((it) => it.timelineRange.startUs === cutUs) ?? null;\n    if (!right || right.kind !== 'clip') return;\n\n    applyTimeline(\n      { type: 'delete_items', trackId: target.trackId, itemIds: [right.id] },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function trimToPlayheadRightNoRipple() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    applyTimeline(\n      { type: 'split_item', trackId: target.trackId, itemId: target.itemId, atUs: cutUs },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    const updatedDoc = timelineDoc.value;\n    if (!updatedDoc) return;\n    const updatedTrack = updatedDoc.tracks.find((t) => t.id === target.trackId) ?? null;\n    if (!updatedTrack) return;\n\n    const left =\n      updatedTrack.items.filter((it) => it.kind === 'clip').find((it) => it.id === target.itemId) ??\n      null;\n    if (!left || left.kind !== 'clip') return;\n\n    applyTimeline(\n      { type: 'delete_items', trackId: target.trackId, itemIds: [left.id] },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  function rippleDeleteRange(input: { trackIds: string[]; startUs: number; endUs: number }) {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const startUs = computeCutUs(doc, input.startUs);\n    const endUs = computeCutUs(doc, input.endUs);\n    if (!(endUs > startUs)) return;\n\n    const deltaUs = endUs - startUs;\n    const trackIdSet = new Set(input.trackIds);\n\n    const splitTargets: Array<{ trackId: string; itemId: string }> = [];\n    for (const track of doc.tracks) {\n      if (!trackIdSet.has(track.id)) continue;\n      for (const it of track.items) {\n        if (it.kind !== 'clip') continue;\n        splitTargets.push({ trackId: track.id, itemId: it.id });\n      }\n    }\n\n    const splitAt = (atUs: number) => {\n      for (const t of splitTargets) {\n        applyTimeline(\n          { type: 'split_item', trackId: t.trackId, itemId: t.itemId, atUs },\n          { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n        );\n      }\n    };\n\n    splitAt(endUs);\n    splitAt(startUs);\n\n    const updated = timelineDoc.value;\n    if (!updated) return;\n\n    for (const track of updated.tracks) {\n      if (!trackIdSet.has(track.id)) continue;\n\n      const toDelete: string[] = [];\n      for (const it of track.items) {\n        if (it.kind !== 'clip') continue;\n        const itStart = it.timelineRange.startUs;\n        const center = itStart + it.timelineRange.durationUs / 2;\n\n        if (center >= startUs && center <= endUs) {\n          toDelete.push(it.id);\n        }\n      }\n\n      if (toDelete.length > 0) {\n        applyTimeline(\n          { type: 'delete_items', trackId: track.id, itemIds: toDelete },\n          { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n        );\n      }\n    }\n\n    const afterDelete = timelineDoc.value;\n    if (!afterDelete) return;\n\n    const EPSILON = 10;\n    for (const track of afterDelete.tracks) {\n      if (!trackIdSet.has(track.id)) continue;\n\n      const clips = track.items\n        .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n        .slice()\n        .sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n      for (const clip of clips) {\n        const clipStart = clip.timelineRange.startUs;\n        if (clipStart >= endUs - EPSILON) {\n          applyTimeline(\n            {\n              type: 'move_item',\n              trackId: track.id,\n              itemId: clip.id,\n              startUs: Math.max(0, clipStart - deltaUs),\n            },\n            { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n          );\n        }\n      }\n    }\n  }\n\n  async function rippleTrimRight() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n\n    // Check if playhead is within the target clip\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    const deltaUs = endUs - cutUs;\n    if (deltaUs <= 0) return;\n\n    // 1. Trim the target clip (shrink duration)\n    applyTimeline(\n      {\n        type: 'trim_item',\n        trackId: target.trackId,\n        itemId: target.itemId,\n        edge: 'end',\n        deltaUs: -deltaUs,\n      },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    // 2. Shift all subsequent clips on the same track left by deltaUs\n    const updatedDoc = timelineDoc.value;\n    if (!updatedDoc) return;\n    const updatedTrack = updatedDoc.tracks.find((t) => t.id === target.trackId) ?? null;\n    if (!updatedTrack) return;\n\n    const subsequentClips = updatedTrack.items\n      .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n      .filter((it) => it.timelineRange.startUs >= endUs - 10); // Use a small epsilon\n\n    for (const clip of subsequentClips) {\n      applyTimeline(\n        {\n          type: 'move_item',\n          trackId: target.trackId,\n          itemId: clip.id,\n          startUs: Math.max(0, clip.timelineRange.startUs - deltaUs),\n        },\n        { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n      );\n    }\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function rippleTrimLeft() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n\n    // Check if playhead is within the target clip\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    const deltaUs = cutUs - startUs;\n    if (deltaUs <= 0) return;\n\n    // 1. Trim the target clip (shrink duration from start)\n    applyTimeline(\n      {\n        type: 'trim_item',\n        trackId: target.trackId,\n        itemId: target.itemId,\n        edge: 'start',\n        deltaUs: deltaUs,\n      },\n      { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n    );\n\n    // 2. Shift the trimmed clip and all subsequent clips on the same track left by deltaUs\n    const updatedDoc = timelineDoc.value;\n    if (!updatedDoc) return;\n    const updatedTrack = updatedDoc.tracks.find((t) => t.id === target.trackId) ?? null;\n    if (!updatedTrack) return;\n\n    const clipsToShift = updatedTrack.items\n      .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n      .filter((it) => it.timelineRange.startUs >= cutUs - 10); // Target clip is now at cutUs, subsequent are later\n\n    for (const clip of clipsToShift) {\n      applyTimeline(\n        {\n          type: 'move_item',\n          trackId: target.trackId,\n          itemId: clip.id,\n          startUs: Math.max(0, clip.timelineRange.startUs - deltaUs),\n        },\n        { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n      );\n    }\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function advancedRippleTrimRight() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    if (selectedItemIds.value.length !== 1) return;\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n\n    // Check if playhead is within the target clip\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    const deltaUs = endUs - cutUs;\n    if (deltaUs <= 0) return;\n\n    const allTrackIds = doc.tracks.map((t) => t.id);\n\n    // 1. Split all tracks at cutUs and endUs\n    const splitAt = (atUs: number) => {\n      for (const t of doc.tracks) {\n        for (const it of t.items) {\n          if (it.kind !== 'clip') continue;\n          const itStart = it.timelineRange.startUs;\n          const itEnd = itStart + it.timelineRange.durationUs;\n          if (atUs > itStart && atUs < itEnd) {\n            applyTimeline(\n              { type: 'split_item', trackId: t.id, itemId: it.id, atUs, ignoreLocks: true },\n              { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n            );\n          }\n        }\n      }\n    };\n\n    splitAt(endUs);\n    splitAt(cutUs);\n\n    const updated = timelineDoc.value;\n    if (!updated) return;\n\n    // 2. Delete all items in the cut range (cutUs to endUs) on all tracks\n    for (const t of updated.tracks) {\n      const toDelete: string[] = [];\n      for (const it of t.items) {\n        if (it.kind !== 'clip') continue;\n        const itStart = it.timelineRange.startUs;\n        const center = itStart + it.timelineRange.durationUs / 2;\n\n        if (center >= cutUs && center <= endUs) {\n          toDelete.push(it.id);\n        }\n      }\n\n      if (toDelete.length > 0) {\n        applyTimeline(\n          { type: 'delete_items', trackId: t.id, itemIds: toDelete, ignoreLocks: true },\n          { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n        );\n      }\n    }\n\n    const afterDelete = timelineDoc.value;\n    if (!afterDelete) return;\n\n    const EPSILON = 10;\n    // 3. Shift all remaining clips that start at or after endUs to the left by deltaUs\n    for (const t of afterDelete.tracks) {\n      const clips = t.items\n        .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n        .slice()\n        .sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n      for (const clip of clips) {\n        const clipStart = clip.timelineRange.startUs;\n        if (clipStart >= endUs - EPSILON) {\n          applyTimeline(\n            {\n              type: 'move_item',\n              trackId: t.id,\n              itemId: clip.id,\n              startUs: Math.max(0, clipStart - deltaUs),\n              ignoreLocks: true,\n            },\n            { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n          );\n        }\n      }\n    }\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function advancedRippleTrimLeft() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    if (selectedItemIds.value.length !== 1) return;\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const startUs = item.timelineRange.startUs;\n    const endUs = startUs + item.timelineRange.durationUs;\n\n    // Check if playhead is within the target clip\n    if (!(cutUs > startUs && cutUs < endUs)) return;\n\n    const deltaUs = cutUs - startUs;\n    if (deltaUs <= 0) return;\n\n    // 1. Split all tracks at startUs and cutUs\n    const splitAt = (atUs: number) => {\n      for (const t of doc.tracks) {\n        for (const it of t.items) {\n          if (it.kind !== 'clip') continue;\n          const itStart = it.timelineRange.startUs;\n          const itEnd = itStart + it.timelineRange.durationUs;\n          if (atUs > itStart && atUs < itEnd) {\n            applyTimeline(\n              { type: 'split_item', trackId: t.id, itemId: it.id, atUs, ignoreLocks: true },\n              { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n            );\n          }\n        }\n      }\n    };\n\n    splitAt(cutUs);\n    splitAt(startUs);\n\n    const updated = timelineDoc.value;\n    if (!updated) return;\n\n    // 2. Delete all items in the cut range (startUs to cutUs) on all tracks\n    for (const t of updated.tracks) {\n      const toDelete: string[] = [];\n      for (const it of t.items) {\n        if (it.kind !== 'clip') continue;\n        const itStart = it.timelineRange.startUs;\n        const center = itStart + it.timelineRange.durationUs / 2;\n\n        if (center >= startUs && center <= cutUs) {\n          toDelete.push(it.id);\n        }\n      }\n\n      if (toDelete.length > 0) {\n        applyTimeline(\n          { type: 'delete_items', trackId: t.id, itemIds: toDelete, ignoreLocks: true },\n          { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n        );\n      }\n    }\n\n    const afterDelete = timelineDoc.value;\n    if (!afterDelete) return;\n\n    const EPSILON = 10;\n    // 3. Shift all remaining clips that start at or after cutUs to the left by deltaUs\n    for (const t of afterDelete.tracks) {\n      const clips = t.items\n        .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n        .slice()\n        .sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n      for (const clip of clips) {\n        const clipStart = clip.timelineRange.startUs;\n        if (clipStart >= cutUs - EPSILON) {\n          applyTimeline(\n            {\n              type: 'move_item',\n              trackId: t.id,\n              itemId: clip.id,\n              startUs: Math.max(0, clipStart - deltaUs),\n              ignoreLocks: true,\n            },\n            { saveMode: 'none', historyMode: 'debounced', historyDebounceMs: 100 },\n          );\n        }\n      }\n    }\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  function getBoundaryTimesUs(trackFilter: ((trackId: string) => boolean) | null): number[] {\n    const doc = timelineDoc.value;\n    if (!doc) return [];\n\n    const boundaries: number[] = [];\n    for (const track of doc.tracks) {\n      if (trackFilter && !trackFilter(track.id)) continue;\n      for (const it of track.items) {\n        if (it.kind !== 'clip') continue;\n        const startUs = Math.max(0, Math.round(it.timelineRange.startUs));\n        const endUs = Math.max(\n          0,\n          Math.round(it.timelineRange.startUs + it.timelineRange.durationUs),\n        );\n        boundaries.push(startUs, endUs);\n      }\n    }\n\n    boundaries.sort((a, b) => a - b);\n    return Array.from(new Set(boundaries));\n  }\n\n  function jumpToPrevClipBoundary(options?: { currentTrackOnly?: boolean }) {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const currentTrackOnly = Boolean(options?.currentTrackOnly);\n    const trackId = currentTrackOnly ? getSelectedOrActiveTrackId() : null;\n    if (currentTrackOnly && !trackId) return;\n\n    const boundaries = getBoundaryTimesUs(trackId ? (id) => id === trackId : null);\n    if (boundaries.length === 0) return;\n\n    const atUs = currentTime.value;\n    let prev: number | null = null;\n    for (const b of boundaries) {\n      if (b >= atUs) break;\n      prev = b;\n    }\n\n    if (prev === null) {\n      currentTime.value = 0;\n      return;\n    }\n\n    currentTime.value = prev;\n  }\n\n  function jumpToNextClipBoundary(options?: { currentTrackOnly?: boolean }) {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const currentTrackOnly = Boolean(options?.currentTrackOnly);\n    const trackId = currentTrackOnly ? getSelectedOrActiveTrackId() : null;\n    if (currentTrackOnly && !trackId) return;\n\n    const boundaries = getBoundaryTimesUs(trackId ? (id) => id === trackId : null);\n    if (boundaries.length === 0) return;\n\n    const atUs = currentTime.value;\n    const next = boundaries.find((b) => b > atUs) ?? null;\n\n    if (next === null) {\n      const endFromState =\n        Number.isFinite(duration.value) && duration.value > 0\n          ? Math.max(0, Math.round(duration.value))\n          : 0;\n      const end =\n        endFromState > 0 ? endFromState : Math.max(0, Math.round(selectTimelineDurationUs(doc)));\n      currentTime.value = end;\n      return;\n    }\n\n    currentTime.value = next;\n  }\n\n  async function splitClipAtPlayhead() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    applyTimeline(\n      { type: 'split_item', trackId: target.trackId, itemId: target.itemId, atUs: cutUs },\n      { saveMode: 'none' },\n    );\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function splitAllClipsAtPlayhead() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const cutUs = computeCutUs(doc, currentTime.value);\n    const cmds: TimelineCommand[] = [];\n    for (const track of doc.tracks) {\n      for (const it of track.items) {\n        if (it.kind !== 'clip') continue;\n        cmds.push({ type: 'split_item', trackId: track.id, itemId: it.id, atUs: cutUs });\n      }\n    }\n    if (cmds.length === 0) return;\n\n    batchApplyTimeline(cmds, {\n      label: 'Split all clips',\n      saveMode: 'immediate',\n    });\n  }\n\n  async function toggleVisibilityTargetTrack() {\n    const trackId = getSelectedOrActiveTrackId();\n    if (!trackId) return;\n    const track = timelineDoc.value?.tracks.find((t) => t.id === trackId);\n    if (!track) return;\n\n    if (track.kind === 'video') {\n      const nextHidden = !track.videoHidden;\n      updateTrackProperties(trackId, {\n        videoHidden: nextHidden,\n        // Auto-mute if becoming hidden, but don't force unmute when becoming visible\n        audioMuted: nextHidden ? true : track.audioMuted,\n      });\n    }\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function toggleMuteTargetTrack() {\n    const trackId = getSelectedOrActiveTrackId();\n    if (!trackId) return;\n    toggleTrackAudioMuted(trackId);\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function toggleSoloTargetTrack() {\n    const trackId = getSelectedOrActiveTrackId();\n    if (!trackId) return;\n    toggleTrackAudioSolo(trackId);\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function toggleDisableTargetClip() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    updateClipProperties(target.trackId, target.itemId, { disabled: !item.disabled });\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function toggleMuteTargetClip() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n    const target = getHotkeyTargetClip();\n    if (!target) return;\n\n    const track = doc.tracks.find((t) => t.id === target.trackId) ?? null;\n    const item = track?.items.find((it) => it.kind === 'clip' && it.id === target.itemId) ?? null;\n    if (!track || !item || item.kind !== 'clip') return;\n\n    const prevGain =\n      typeof item.audioGain === 'number' && Number.isFinite(item.audioGain) ? item.audioGain : 1;\n    const nextGain = prevGain === 0 ? 1 : 0;\n    updateClipProperties(target.trackId, target.itemId, { audioGain: nextGain });\n    await requestTimelineSave({ immediate: true });\n  }\n\n  async function splitClipsAtPlayhead() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    const atUs = currentTime.value;\n\n    const selected = selectedItemIds.value;\n    const shouldUseSelection = selected.length > 0;\n    const targetIds = new Set<string>();\n\n    for (const t of doc.tracks) {\n      for (const it of t.items) {\n        if (it.kind !== 'clip') continue;\n        if (shouldUseSelection && !selected.includes(it.id)) continue;\n        targetIds.add(it.id);\n      }\n    }\n\n    if (targetIds.size === 0) return;\n\n    for (const t of (timelineDoc.value?.tracks ?? []) as any[]) {\n      for (const it of t.items ?? []) {\n        if (!it || it.kind !== 'clip') continue;\n        if (!targetIds.has(it.id)) continue;\n        applyTimeline(\n          {\n            type: 'split_item',\n            trackId: String(t.id),\n            itemId: String(it.id),\n            atUs,\n          },\n          { saveMode: 'none' },\n        );\n      }\n    }\n\n    await requestTimelineSave({ immediate: true });\n  }\n\n  function toggleSelection(itemId: string, options?: { multi?: boolean }) {\n    selectedTransition.value = null;\n    if (options?.multi) {\n      if (selectedItemIds.value.includes(itemId)) {\n        selectedItemIds.value = selectedItemIds.value.filter((id) => id !== itemId);\n      } else {\n        selectedItemIds.value.push(itemId);\n      }\n    } else {\n      selectedItemIds.value = [itemId];\n    }\n  }\n\n  function deleteSelectedItems(trackId: string) {\n    if (selectedItemIds.value.length === 0) return;\n    applyTimeline({\n      type: 'delete_items',\n      trackId,\n      itemIds: [...selectedItemIds.value],\n    });\n    selectedItemIds.value = [];\n  }\n\n  function deleteFirstSelectedItem() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    if (selectedTransition.value) {\n      updateClipTransition(\n        selectedTransition.value.trackId,\n        selectedTransition.value.itemId,\n        selectedTransition.value.edge === 'in' ? { transitionIn: null } : { transitionOut: null },\n      );\n      clearSelectedTransition();\n      return;\n    }\n\n    if (selectedItemIds.value.length === 0) {\n      if (selectedTrackId.value) {\n        deleteTrack(selectedTrackId.value, { allowNonEmpty: true });\n        selectTrack(null);\n      }\n      return;\n    }\n\n    const selectedSet = new Set(selectedItemIds.value);\n    for (const track of doc.tracks) {\n      for (const item of track.items) {\n        if (selectedSet.has(item.id)) {\n          deleteSelectedItems(track.id);\n          return;\n        }\n      }\n    }\n  }\n\n  function rippleDeleteFirstSelectedItem() {\n    const doc = timelineDoc.value;\n    if (!doc) return;\n\n    if (selectedItemIds.value.length === 0) return;\n\n    const selectedSet = new Set(selectedItemIds.value);\n    let targetTrack: import('~/timeline/types').TimelineTrack | null = null;\n    const targetItems: import('~/timeline/types').TimelineClipItem[] = [];\n\n    for (const track of doc.tracks) {\n      for (const item of track.items) {\n        if (selectedSet.has(item.id)) {\n          targetTrack = track;\n          break;\n        }\n      }\n      if (targetTrack) break;\n    }\n\n    if (!targetTrack) return;\n    for (const item of targetTrack.items) {\n      if (selectedSet.has(item.id) && item.kind === 'clip') {\n        targetItems.push(item);\n      }\n    }\n\n    if (targetItems.length === 0) return;\n\n    let startUs = Infinity;\n    let endUs = -Infinity;\n    for (const item of targetItems) {\n      startUs = Math.min(startUs, item.timelineRange.startUs);\n      endUs = Math.max(endUs, item.timelineRange.startUs + item.timelineRange.durationUs);\n    }\n\n    if (startUs < endUs) {\n      rippleDeleteRange({ trackIds: [targetTrack.id], startUs, endUs });\n      clearSelection();\n    }\n  }\n\n  function goToStart() {\n    currentTime.value = 0;\n  }\n\n  function goToEnd() {\n    const end = Number.isFinite(duration.value) ? Math.max(0, Math.round(duration.value)) : 0;\n    currentTime.value = end;\n  }\n\n  function setTimelineZoom(next: number) {\n    const parsed = Math.round(Number(next));\n    if (!Number.isFinite(parsed)) return;\n    timelineZoom.value = Math.min(100, Math.max(0, parsed));\n  }\n\n  function setAudioVolume(next: number) {\n    const parsed = Number(next);\n    if (!Number.isFinite(parsed)) return;\n    audioVolume.value = Math.min(2, Math.max(0, parsed));\n    if (audioVolume.value > 0 && audioMuted.value) {\n      audioMuted.value = false;\n    }\n  }\n\n  function setAudioMuted(next: boolean) {\n    audioMuted.value = Boolean(next);\n  }\n\n  function toggleAudioMuted() {\n    audioMuted.value = !audioMuted.value;\n  }\n\n  function setPlaybackGestureHandler(handler: ((nextPlaying: boolean) => void) | null) {\n    playbackGestureHandler.value = handler;\n  }\n\n  function togglePlayback() {\n    const nextPlaying = !isPlaying.value;\n    playbackGestureHandler.value?.(nextPlaying);\n    isPlaying.value = nextPlaying;\n  }\n\n  function stopPlayback() {\n    playbackGestureHandler.value?.(false);\n    isPlaying.value = false;\n    currentTime.value = 0;\n  }\n\n  function addTrack(kind: 'video' | 'audio', name: string) {\n    applyTimeline({ type: 'add_track', kind, name });\n  }\n\n  function resolveTargetVideoTrackIdForInsert(): string {\n    const doc = timelineDoc.value;\n    if (!doc) throw new Error('Timeline not loaded');\n\n    const selected =\n      typeof selectedTrackId.value === 'string'\n        ? (doc.tracks.find((t) => t.id === selectedTrackId.value) ?? null)\n        : null;\n\n    if (selected?.kind === 'video') return selected.id;\n\n    const topVideo = doc.tracks.find((t) => t.kind === 'video') ?? null;\n    if (!topVideo) throw new Error('No video tracks');\n    return topVideo.id;\n  }\n\n  function addVirtualClipAtPlayhead(input: {\n    clipType: Extract<\n      import('~/timeline/types').TimelineClipType,\n      'adjustment' | 'background' | 'text'\n    >;\n    name: string;\n    durationUs?: number;\n    backgroundColor?: string;\n    text?: string;\n    style?: import('~/timeline/types').TextClipStyle;\n  }) {\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    const trackId = resolveTargetVideoTrackIdForInsert();\n    applyTimeline({\n      type: 'add_virtual_clip_to_track',\n      trackId,\n      clipType: input.clipType,\n      name: input.name,\n      durationUs: input.durationUs,\n      backgroundColor: input.backgroundColor,\n      text: input.text,\n      style: input.style,\n      startUs: currentTime.value,\n    });\n  }\n\n  function addVirtualClipToTrack(input: {\n    trackId: string;\n    startUs: number;\n    clipType: Extract<\n      import('~/timeline/types').TimelineClipType,\n      'adjustment' | 'background' | 'text'\n    >;\n    name: string;\n    durationUs?: number;\n    backgroundColor?: string;\n    text?: string;\n    style?: import('~/timeline/types').TextClipStyle;\n  }) {\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    applyTimeline({\n      type: 'add_virtual_clip_to_track',\n      trackId: input.trackId,\n      clipType: input.clipType,\n      name: input.name,\n      durationUs: input.durationUs,\n      backgroundColor: input.backgroundColor,\n      text: input.text,\n      style: input.style,\n      startUs: input.startUs,\n    });\n  }\n\n  function addAdjustmentClipAtPlayhead(options?: { durationUs?: number; name?: string }) {\n    addVirtualClipAtPlayhead({\n      clipType: 'adjustment',\n      name: options?.name ?? 'Adjustment',\n      durationUs: options?.durationUs,\n    });\n  }\n\n  function addBackgroundClipAtPlayhead(options?: {\n    durationUs?: number;\n    name?: string;\n    backgroundColor?: string;\n  }) {\n    addVirtualClipAtPlayhead({\n      clipType: 'background',\n      name: options?.name ?? 'Background',\n      durationUs: options?.durationUs,\n      backgroundColor: options?.backgroundColor,\n    });\n  }\n\n  function addTextClipAtPlayhead(options?: {\n    durationUs?: number;\n    name?: string;\n    text?: string;\n    style?: import('~/timeline/types').TextClipStyle;\n  }) {\n    addVirtualClipAtPlayhead({\n      clipType: 'text',\n      name: options?.name ?? 'Text',\n      durationUs: options?.durationUs,\n      text: options?.text,\n      style: options?.style,\n    });\n  }\n\n  function renameTrack(trackId: string, name: string) {\n    applyTimeline({ type: 'rename_track', trackId, name });\n  }\n\n  function updateTrackProperties(\n    trackId: string,\n    properties: Partial<\n      Pick<\n        import('~/timeline/types').TimelineTrack,\n        'videoHidden' | 'audioMuted' | 'audioSolo' | 'effects' | 'audioGain' | 'audioBalance'\n      >\n    >,\n  ) {\n    applyTimeline(\n      {\n        type: 'update_track_properties',\n        trackId,\n        properties,\n      },\n      { historyMode: 'debounced' },\n    );\n  }\n\n  function toggleVideoHidden(trackId: string) {\n    const track = timelineDoc.value?.tracks.find((t) => t.id === trackId);\n    if (!track || track.kind !== 'video') return;\n    updateTrackProperties(trackId, { videoHidden: !track.videoHidden });\n  }\n\n  function toggleTrackAudioMuted(trackId: string) {\n    const track = timelineDoc.value?.tracks.find((t) => t.id === trackId);\n    if (!track) return;\n    updateTrackProperties(trackId, { audioMuted: !track.audioMuted });\n  }\n\n  function toggleTrackAudioSolo(trackId: string) {\n    const track = timelineDoc.value?.tracks.find((t) => t.id === trackId);\n    if (!track) return;\n    updateTrackProperties(trackId, { audioSolo: !track.audioSolo });\n  }\n\n  function renameItem(trackId: string, itemId: string, name: string) {\n    applyTimeline({\n      type: 'rename_item',\n      trackId,\n      itemId,\n      name,\n    });\n  }\n\n  function updateClipProperties(\n    trackId: string,\n    itemId: string,\n    properties: Partial<\n      Pick<\n        import('~/timeline/types').TimelineClipItem,\n        | 'disabled'\n        | 'locked'\n        | 'opacity'\n        | 'effects'\n        | 'freezeFrameSourceUs'\n        | 'speed'\n        | 'transform'\n        | 'audioGain'\n        | 'audioBalance'\n        | 'audioFadeInUs'\n        | 'audioFadeOutUs'\n      >\n    > & {\n      backgroundColor?: string;\n      text?: string;\n      style?: import('~/timeline/types').TextClipStyle;\n    },\n  ) {\n    applyTimeline(\n      {\n        type: 'update_clip_properties',\n        trackId,\n        itemId,\n        properties,\n      },\n      { historyMode: 'debounced' },\n    );\n  }\n\n  function updateClipTransition(\n    trackId: string,\n    itemId: string,\n    options: {\n      transitionIn?: import('~/timeline/types').ClipTransition | null;\n      transitionOut?: import('~/timeline/types').ClipTransition | null;\n    },\n  ) {\n    applyTimeline({\n      type: 'update_clip_transition',\n      trackId,\n      itemId,\n      ...options,\n    });\n  }\n\n  function deleteTrack(trackId: string, options?: { allowNonEmpty?: boolean }) {\n    applyTimeline({ type: 'delete_track', trackId, allowNonEmpty: options?.allowNonEmpty });\n    if (selectedTrackId.value === trackId) {\n      selectedTrackId.value = null;\n    }\n  }\n\n  function reorderTracks(trackIds: string[]) {\n    applyTimeline({ type: 'reorder_tracks', trackIds });\n  }\n\n  async function moveItemToTrack(input: {\n    fromTrackId: string;\n    toTrackId: string;\n    itemId: string;\n    startUs: number;\n  }) {\n    const doc = timelineDoc.value;\n    const fromTrack = doc?.tracks.find((t) => t.id === input.fromTrackId) ?? null;\n    const toTrack = doc?.tracks.find((t) => t.id === input.toTrackId) ?? null;\n    if (!fromTrack || !toTrack) throw new Error('Track not found');\n\n    const item = fromTrack.items.find((it) => it.id === input.itemId);\n    if (!item || item.kind !== 'clip') throw new Error('Item not found');\n\n    if (item.clipType !== 'media') {\n      throw new Error('Only media clips can be moved across tracks');\n    }\n\n    const path = item.source?.path;\n    if (!path) throw new Error('Invalid source');\n\n    let metadata = mediaMetadata.value[path] ?? null;\n    if (!metadata) {\n      metadata = await mediaStore.getOrFetchMetadataByPath(path);\n    }\n    if (!metadata) throw new Error('Failed to resolve media metadata');\n\n    const hasVideo = Boolean(metadata.video);\n    const hasAudio = Boolean(metadata.audio);\n    const isImageLike = !hasVideo && !hasAudio;\n\n    if (toTrack.kind === 'video' && !hasVideo && !isImageLike) {\n      throw new Error('Only video sources can be moved to video tracks');\n    }\n    if (toTrack.kind === 'audio' && isImageLike) {\n      throw new Error('Images cannot be moved to audio tracks');\n    }\n\n    applyTimeline({\n      type: 'move_item_to_track',\n      fromTrackId: input.fromTrackId,\n      toTrackId: input.toTrackId,\n      itemId: input.itemId,\n      startUs: input.startUs,\n    });\n  }\n\n  async function extractAudioToTrack(input: { videoTrackId: string; videoItemId: string }) {\n    const doc = timelineDoc.value;\n    if (!doc) throw new Error('Timeline not loaded');\n    const videoTrack = doc.tracks.find((t) => t.id === input.videoTrackId) ?? null;\n    if (!videoTrack || videoTrack.kind !== 'video') throw new Error('Invalid video track');\n    const videoItem = videoTrack.items.find((it) => it.id === input.videoItemId) ?? null;\n    if (!videoItem || videoItem.kind !== 'clip') throw new Error('Clip not found');\n\n    if (videoItem.clipType !== 'media') {\n      throw new Error('Only media clips can extract audio');\n    }\n\n    const audioTracks = doc.tracks.filter((t) => t.kind === 'audio');\n    if (audioTracks.length === 0) throw new Error('No audio tracks');\n\n    const selected = doc.tracks.find((t) => t.id === selectedTrackId.value) ?? null;\n    const targetAudioTrackId = selected?.kind === 'audio' ? selected.id : audioTracks[0]!.id;\n\n    const path = videoItem.source?.path;\n    if (!path) throw new Error('Invalid source');\n\n    let metadata = mediaMetadata.value[path] ?? null;\n    if (!metadata) {\n      metadata = await mediaStore.getOrFetchMetadataByPath(path);\n    }\n    if (!metadata) throw new Error('Failed to resolve media metadata');\n    if (!metadata.audio) throw new Error('Source has no audio');\n\n    applyTimeline({\n      type: 'extract_audio_to_track',\n      videoTrackId: videoTrack.id,\n      videoItemId: videoItem.id,\n      audioTrackId: targetAudioTrackId,\n    });\n  }\n\n  function returnAudioToVideo(input: { videoItemId: string }) {\n    applyTimeline({ type: 'return_audio_to_video', videoItemId: input.videoItemId });\n  }\n\n  function clearPersistTimelineTimeout() {\n    if (typeof window === 'undefined') return;\n    if (persistTimelineTimeout === null) return;\n    window.clearTimeout(persistTimelineTimeout);\n    persistTimelineTimeout = null;\n  }\n\n  function resetTimelineState() {\n    clearPersistTimelineTimeout();\n    loadTimelineRequestId += 1;\n    timelineDoc.value = null;\n    isTimelineDirty.value = false;\n    isSavingTimeline.value = false;\n    timelineSaveError.value = null;\n    isPlaying.value = false;\n    currentTime.value = 0;\n    duration.value = 0;\n    audioVolume.value = 1;\n    audioMuted.value = false;\n    timelineZoom.value = 50;\n    clearSelection();\n    selectTrack(null);\n    timelineRevision = 0;\n    savedTimelineRevision = 0;\n    historyStore.clear();\n    clearPendingDebouncedHistory();\n  }\n\n  function markTimelineAsCleanForCurrentRevision() {\n    savedTimelineRevision = timelineRevision;\n    isTimelineDirty.value = false;\n  }\n\n  function markTimelineAsDirty() {\n    timelineRevision += 1;\n    isTimelineDirty.value = true;\n  }\n\n  async function ensureTimelineFileHandle(options?: {\n    create?: boolean;\n  }): Promise<FileSystemFileHandle | null> {\n    if (!currentTimelinePath.value) return null;\n    return await projectStore.getProjectFileHandleByRelativePath({\n      relativePath: currentTimelinePath.value,\n      create: options?.create ?? false,\n    });\n  }\n\n  async function persistTimelineNow() {\n    if (!timelineDoc.value || !isTimelineDirty.value) return;\n\n    isSavingTimeline.value = true;\n    timelineSaveError.value = null;\n\n    // Inject the current playhead position before saving\n    const snapshot: TimelineDocument = {\n      ...timelineDoc.value,\n      metadata: {\n        ...(timelineDoc.value.metadata ?? {}),\n        gran: {\n          ...(timelineDoc.value.metadata?.gran ?? {}),\n          playheadUs: currentTime.value,\n        },\n      },\n    };\n    const revisionToSave = timelineRevision;\n\n    try {\n      const handle = await ensureTimelineFileHandle({ create: true });\n      if (!handle) return;\n\n      const writable = await (handle as any).createWritable();\n      await writable.write(serializeTimelineToOtio(snapshot));\n      await writable.close();\n\n      if (savedTimelineRevision < revisionToSave) {\n        savedTimelineRevision = revisionToSave;\n      }\n    } catch (e: any) {\n      timelineSaveError.value = e?.message ?? 'Failed to save timeline file';\n      console.warn('Failed to save timeline file', e);\n    } finally {\n      isSavingTimeline.value = false;\n      isTimelineDirty.value = savedTimelineRevision < timelineRevision;\n    }\n  }\n\n  async function enqueueTimelineSave() {\n    await timelineSaveQueue.add(async () => {\n      await persistTimelineNow();\n    });\n  }\n\n  async function requestTimelineSave(options?: { immediate?: boolean }) {\n    if (!timelineDoc.value) return;\n\n    if (options?.immediate) {\n      clearPersistTimelineTimeout();\n      await enqueueTimelineSave();\n      return;\n    }\n\n    if (typeof window === 'undefined') {\n      await enqueueTimelineSave();\n      return;\n    }\n\n    clearPersistTimelineTimeout();\n    persistTimelineTimeout = window.setTimeout(() => {\n      persistTimelineTimeout = null;\n      void enqueueTimelineSave();\n    }, 500);\n  }\n\n  async function loadTimeline() {\n    if (!currentProjectName.value || !currentTimelinePath.value) return;\n\n    const requestId = ++loadTimelineRequestId;\n    clearPersistTimelineTimeout();\n    clearSelection();\n    selectTrack(null);\n    isPlaying.value = false;\n    currentTime.value = 0;\n    historyStore.clear();\n    clearPendingDebouncedHistory();\n\n    const fallback = projectStore.createFallbackTimelineDoc();\n\n    try {\n      const handle = await ensureTimelineFileHandle({ create: false });\n      if (!handle) {\n        if (requestId !== loadTimelineRequestId) return;\n        timelineDoc.value = fallback;\n        return;\n      }\n\n      const file = await handle.getFile();\n      const text = await file.text();\n      const parsed = parseTimelineFromOtio(text, {\n        id: fallback.id,\n        name: fallback.name,\n        fps: fallback.timebase.fps,\n      });\n      if (requestId !== loadTimelineRequestId) return;\n      timelineDoc.value = parsed;\n\n      if (\n        typeof parsed.metadata?.gran?.playheadUs === 'number' &&\n        Number.isFinite(parsed.metadata.gran.playheadUs)\n      ) {\n        currentTime.value = parsed.metadata.gran.playheadUs;\n      }\n    } catch (e: any) {\n      console.warn('Failed to load timeline file, fallback to default', e);\n      if (requestId !== loadTimelineRequestId) return;\n      timelineDoc.value = fallback;\n    } finally {\n      if (requestId !== loadTimelineRequestId) return;\n      duration.value = timelineDoc.value ? selectTimelineDurationUs(timelineDoc.value) : 0;\n      timelineRevision = 0;\n      markTimelineAsCleanForCurrentRevision();\n      timelineSaveError.value = null;\n    }\n  }\n\n  async function saveTimeline() {\n    await requestTimelineSave({ immediate: true });\n  }\n\n  function hydrateClipSourceDuration(\n    doc: TimelineDocument,\n    cmd: TimelineCommand,\n  ): TimelineDocument {\n    if (cmd.type !== 'trim_item' && cmd.type !== 'overlay_trim_item') return doc;\n\n    const track = doc.tracks.find((t) => t.id === cmd.trackId);\n    if (!track) return doc;\n\n    const item = track.items.find((it) => it.id === cmd.itemId);\n    if (!item) return doc;\n    if (item.kind !== 'clip') return doc;\n    if (item.clipType !== 'media') return doc;\n    if (!item.source?.path) return doc;\n\n    const meta = mediaMetadata.value[item.source.path];\n    if (!meta) return doc;\n\n    const hasVideo = Boolean(meta.video);\n    const hasAudio = Boolean(meta.audio);\n    const isImageLike = !hasVideo && !hasAudio;\n\n    const durationS = Number(meta.duration);\n    const durationUs =\n      Number.isFinite(durationS) && durationS > 0 ? Math.floor(durationS * 1_000_000) : 0;\n\n    const needsSourceDurationPatch = durationUs > 0 && item.sourceDurationUs !== durationUs;\n    const needsIsImagePatch = isImageLike && !item.isImage;\n\n    if (!needsSourceDurationPatch && !needsIsImagePatch) return doc;\n\n    const nextTracks = doc.tracks.map((t) =>\n      t.id !== track.id\n        ? t\n        : {\n            ...t,\n            items: t.items.map((it) => {\n              if (it.id === item.id && it.kind === 'clip' && it.clipType === 'media') {\n                const patch: any = {};\n                if (needsSourceDurationPatch) patch.sourceDurationUs = durationUs;\n                if (needsIsImagePatch) patch.isImage = true;\n                return { ...it, ...patch };\n              }\n              return it;\n            }),\n          },\n    );\n\n    return { ...doc, tracks: nextTracks };\n  }\n\n  function applyTimeline(\n    cmd: TimelineCommand,\n    options?: {\n      saveMode?: 'debounced' | 'immediate' | 'none';\n      skipHistory?: boolean;\n      historyMode?: 'immediate' | 'debounced';\n      historyDebounceMs?: number;\n    },\n  ) {\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    const prev = timelineDoc.value;\n    const hydrated = hydrateClipSourceDuration(timelineDoc.value, cmd);\n    const { next } = applyTimelineCommand(hydrated, cmd);\n    if (next === prev) return;\n\n    if (!options?.skipHistory) {\n      const historyMode = options?.historyMode ?? 'immediate';\n      if (historyMode === 'debounced') {\n        const debounceMs = Math.max(0, Math.round(options?.historyDebounceMs ?? 300));\n        const pending = pendingDebouncedHistory.value;\n\n        if (pending) {\n          window.clearTimeout(pending.timeoutId);\n          pendingDebouncedHistory.value = {\n            snapshot: pending.snapshot,\n            cmd,\n            timeoutId: window.setTimeout(() => {\n              const p = pendingDebouncedHistory.value;\n              if (!p) return;\n              historyStore.push(p.cmd, p.snapshot);\n              pendingDebouncedHistory.value = null;\n            }, debounceMs),\n          };\n        } else {\n          pendingDebouncedHistory.value = {\n            snapshot: prev,\n            cmd,\n            timeoutId: window.setTimeout(() => {\n              const p = pendingDebouncedHistory.value;\n              if (!p) return;\n              historyStore.push(p.cmd, p.snapshot);\n              pendingDebouncedHistory.value = null;\n            }, debounceMs),\n          };\n        }\n      } else {\n        const pending = pendingDebouncedHistory.value;\n        if (pending) {\n          window.clearTimeout(pending.timeoutId);\n          pendingDebouncedHistory.value = null;\n        }\n        historyStore.push(cmd, prev);\n      }\n    }\n\n    timelineDoc.value = next;\n    duration.value = selectTimelineDurationUs(next);\n    markTimelineAsDirty();\n\n    const saveMode = options?.saveMode ?? 'debounced';\n    if (saveMode === 'immediate') {\n      void requestTimelineSave({ immediate: true });\n    } else if (saveMode === 'debounced') {\n      void requestTimelineSave();\n    }\n  }\n\n  function batchApplyTimeline(\n    cmds: TimelineCommand[],\n    options?: {\n      saveMode?: 'debounced' | 'immediate' | 'none';\n      skipHistory?: boolean;\n      label?: string;\n    },\n  ) {\n    if (cmds.length === 0) return;\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    const prev = timelineDoc.value;\n    let current = prev;\n    for (const cmd of cmds) {\n      const hydrated = hydrateClipSourceDuration(current, cmd);\n      const { next } = applyTimelineCommand(hydrated, cmd);\n      current = next;\n    }\n\n    if (current === prev) return;\n\n    if (!options?.skipHistory) {\n      historyStore.push(cmds[0]!, prev, options?.label);\n    }\n\n    timelineDoc.value = current;\n    duration.value = selectTimelineDurationUs(current);\n    markTimelineAsDirty();\n\n    const saveMode = options?.saveMode ?? 'debounced';\n    if (saveMode === 'immediate') {\n      void requestTimelineSave({ immediate: true });\n    } else if (saveMode === 'debounced') {\n      void requestTimelineSave();\n    }\n  }\n\n  function undoTimeline() {\n    if (!timelineDoc.value || !historyStore.canUndo) return;\n    const restored = historyStore.undo(timelineDoc.value);\n    if (!restored) return;\n    timelineDoc.value = restored;\n    duration.value = selectTimelineDurationUs(restored);\n    markTimelineAsDirty();\n    void requestTimelineSave();\n  }\n\n  function redoTimeline() {\n    if (!timelineDoc.value || !historyStore.canRedo) return;\n    const restored = historyStore.redo(timelineDoc.value);\n    if (!restored) return;\n    timelineDoc.value = restored;\n    duration.value = selectTimelineDurationUs(restored);\n    markTimelineAsDirty();\n    void requestTimelineSave();\n  }\n\n  async function addClipToTimelineFromPath(input: {\n    trackId: string;\n    name: string;\n    path: string;\n    startUs?: number;\n  }) {\n    const handle = await projectStore.getFileHandleByPath(input.path);\n    if (!handle) throw new Error('Failed to access file handle');\n\n    const resolvedTrackKind = timelineDoc.value?.tracks.find((t) => t.id === input.trackId)?.kind;\n    const trackKind =\n      resolvedTrackKind === 'audio' || resolvedTrackKind === 'video' ? resolvedTrackKind : null;\n    if (!trackKind) throw new Error('Track not found');\n\n    const metadata = await mediaStore.getOrFetchMetadata(handle, input.path);\n    if (!metadata) throw new Error('Failed to resolve media metadata');\n\n    const hasVideo = Boolean(metadata.video);\n    const hasAudio = Boolean(metadata.audio);\n    const isImageLike = !hasVideo && !hasAudio;\n\n    if (trackKind === 'video' && !hasVideo && !isImageLike) {\n      throw new Error('Only video sources can be added to video tracks');\n    }\n    if (trackKind === 'audio' && isImageLike) {\n      throw new Error('Images cannot be added to audio tracks');\n    }\n\n    let durationUs = 0;\n    let sourceDurationUs = 0;\n    if (isImageLike) {\n      durationUs = DEFAULT_IMAGE_DURATION_US;\n      sourceDurationUs = DEFAULT_IMAGE_SOURCE_DURATION_US;\n    } else {\n      const durationS = Number(metadata?.duration);\n      durationUs = Math.floor(durationS * 1_000_000);\n      sourceDurationUs = durationUs;\n    }\n    if (!Number.isFinite(durationUs) || durationUs <= 0) {\n      throw new Error('Failed to resolve media duration');\n    }\n\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    const targetTrack = timelineDoc.value.tracks.find((t) => t.id === input.trackId);\n    if (!targetTrack) throw new Error('Track not found');\n\n    const shouldAutoCreateProxy =\n      workspaceStore.userSettings.optimization.autoCreateProxies &&\n      hasVideo &&\n      input.path.startsWith(`${VIDEO_DIR_NAME}/`) &&\n      !proxyStore.existingProxies.has(input.path);\n\n    if (shouldAutoCreateProxy) {\n      void proxyStore.generateProxy(handle, input.path);\n    }\n\n    applyTimeline({\n      type: 'add_clip_to_track',\n      trackId: targetTrack.id,\n      name: input.name,\n      path: input.path,\n      clipType: 'media',\n      durationUs,\n      sourceDurationUs,\n      isImage: isImageLike,\n      startUs: input.startUs,\n    });\n  }\n\n  async function addTimelineClipToTimelineFromPath(input: {\n    trackId: string;\n    name: string;\n    path: string;\n    startUs?: number;\n  }) {\n    if (currentTimelinePath.value && input.path === currentTimelinePath.value) {\n      throw new Error('Cannot insert the currently opened timeline into itself');\n    }\n\n    const handle = await projectStore.getFileHandleByPath(input.path);\n    if (!handle) throw new Error('Failed to access file handle');\n\n    const resolvedTrackKind = timelineDoc.value?.tracks.find((t) => t.id === input.trackId)?.kind;\n    const trackKind =\n      resolvedTrackKind === 'audio' || resolvedTrackKind === 'video' ? resolvedTrackKind : null;\n    if (!trackKind) throw new Error('Track not found');\n\n    let durationUs = 2_000_000;\n    try {\n      const file = await handle.getFile();\n      const text = await file.text();\n      const nested = parseTimelineFromOtio(text, { id: 'nested', name: input.name, fps: 25 });\n      const nestedDurationUs = selectTimelineDurationUs(nested);\n      if (Number.isFinite(nestedDurationUs) && nestedDurationUs > 0) {\n        durationUs = Math.max(1, Math.round(nestedDurationUs));\n      }\n    } catch {\n      // keep fallback duration\n    }\n\n    if (!timelineDoc.value) {\n      timelineDoc.value = projectStore.createFallbackTimelineDoc();\n    }\n\n    const targetTrack = timelineDoc.value.tracks.find((t) => t.id === input.trackId);\n    if (!targetTrack) throw new Error('Track not found');\n\n    applyTimeline({\n      type: 'add_clip_to_track',\n      trackId: targetTrack.id,\n      name: input.name,\n      path: input.path,\n      clipType: 'timeline',\n      durationUs,\n      sourceDurationUs: durationUs,\n      startUs: input.startUs,\n    });\n  }\n\n  async function loadTimelineMetadata() {\n    if (!timelineDoc.value) return;\n\n    const requestId = loadTimelineRequestId;\n    const timelinePathSnapshot = currentTimelinePath.value;\n\n    const items: { path: string }[] = [];\n    for (const track of timelineDoc.value.tracks) {\n      for (const item of track.items) {\n        if (item.kind === 'clip' && item.clipType === 'media' && item.source?.path) {\n          items.push({ path: item.source.path });\n        }\n      }\n    }\n\n    if (requestId !== loadTimelineRequestId) return;\n    if (timelinePathSnapshot !== currentTimelinePath.value) return;\n\n    await Promise.all(items.map((it) => mediaStore.getOrFetchMetadataByPath(it.path)));\n  }\n\n  return {\n    timelineDoc,\n    getMarkers,\n    isTimelineDirty,\n    isSavingTimeline,\n    timelineSaveError,\n    isPlaying,\n    currentTime,\n    duration,\n    audioVolume,\n    audioMuted,\n    timelineZoom,\n    selectedItemIds,\n    selectedTrackId,\n    hoveredTrackId,\n    selectedTransition,\n    loadTimeline,\n    saveTimeline,\n    requestTimelineSave,\n    applyTimeline,\n    addClipToTimelineFromPath,\n    addTimelineClipToTimelineFromPath,\n    loadTimelineMetadata,\n    clearSelection,\n    clearSelectedTransition,\n    toggleSelection,\n    selectTrack,\n    selectTransition,\n    deleteSelectedItems,\n    deleteFirstSelectedItem,\n    rippleDeleteFirstSelectedItem,\n    goToStart,\n    goToEnd,\n    setTimelineZoom,\n    setAudioVolume,\n    setAudioMuted,\n    toggleAudioMuted,\n    playbackSpeed,\n    setPlaybackSpeed,\n    setPlaybackGestureHandler,\n    togglePlayback,\n    stopPlayback,\n    addMarkerAtPlayhead,\n    updateMarker,\n    removeMarker,\n    addTrack,\n    addAdjustmentClipAtPlayhead,\n    addVirtualClipAtPlayhead,\n    addVirtualClipToTrack,\n    addBackgroundClipAtPlayhead,\n    addTextClipAtPlayhead,\n    renameTrack,\n    updateTrackProperties,\n    toggleVideoHidden,\n    toggleTrackAudioMuted,\n    toggleTrackAudioSolo,\n    renameItem,\n    updateClipProperties,\n    updateClipTransition,\n    setClipFreezeFrameFromPlayhead,\n    resetClipFreezeFrame,\n    splitClipsAtPlayhead,\n    trimToPlayheadLeftNoRipple,\n    trimToPlayheadRightNoRipple,\n    rippleTrimLeft,\n    rippleTrimRight,\n    advancedRippleTrimLeft,\n    advancedRippleTrimRight,\n    jumpToPrevClipBoundary,\n    jumpToNextClipBoundary,\n    splitClipAtPlayhead,\n    splitAllClipsAtPlayhead,\n    toggleDisableTargetClip,\n    toggleMuteTargetClip,\n    deleteTrack,\n    reorderTracks,\n    moveItemToTrack,\n    extractAudioToTrack,\n    returnAudioToVideo,\n    resetTimelineState,\n    undoTimeline,\n    redoTimeline,\n    toggleVisibilityTargetTrack,\n    toggleMuteTargetTrack,\n    toggleSoloTargetTrack,\n    batchApplyTimeline,\n    historyStore,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/timelineSettings.store.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ref' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"messageId":"unusedVar","endLine":2,"endColumn":13,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"ref"},"fix":{"range":[37,64],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia';\nimport { ref } from 'vue';\nimport { useLocalStorage } from '@vueuse/core';\nimport type { OverlapMode, FrameSnapMode, ClipSnapMode } from '~/utils/timeline-modes';\nimport { DEFAULT_SNAP_SETTINGS } from '~/utils/timeline-modes';\n\nexport const useTimelineSettingsStore = defineStore('timelineSettings', () => {\n  const overlapMode = useLocalStorage<OverlapMode>(\n    'gran-editor-overlap-mode',\n    DEFAULT_SNAP_SETTINGS.overlapMode,\n  );\n\n  const frameSnapMode = useLocalStorage<FrameSnapMode>(\n    'gran-editor-frame-snap-mode',\n    DEFAULT_SNAP_SETTINGS.frameSnapMode,\n  );\n\n  const clipSnapMode = useLocalStorage<ClipSnapMode>(\n    'gran-editor-clip-snap-mode',\n    DEFAULT_SNAP_SETTINGS.clipSnapMode,\n  );\n\n  const snapThresholdPx = useLocalStorage<number>(\n    'gran-editor-snap-threshold-px',\n    DEFAULT_SNAP_SETTINGS.snapThresholdPx,\n  );\n\n  function setOverlapMode(mode: OverlapMode) {\n    overlapMode.value = mode;\n  }\n\n  function setFrameSnapMode(mode: FrameSnapMode) {\n    frameSnapMode.value = mode;\n  }\n\n  function setClipSnapMode(mode: ClipSnapMode) {\n    clipSnapMode.value = mode;\n  }\n\n  function setSnapThresholdPx(value: number) {\n    snapThresholdPx.value = Math.max(1, Math.round(value));\n  }\n\n  return {\n    overlapMode,\n    frameSnapMode,\n    clipSnapMode,\n    snapThresholdPx,\n    setOverlapMode,\n    setFrameSnapMode,\n    setClipSnapMode,\n    setSnapThresholdPx,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/ui.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":36,"messageId":"unexpectedAny","endLine":63,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1711,1714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1711,1714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-dynamic-delete","severity":1,"message":"Do not delete dynamically computed property keys.","line":180,"column":21,"messageId":"dynamicDelete","endLine":180,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineStore } from 'pinia';\nimport { ref, watch } from 'vue';\nimport PQueue from 'p-queue';\n\ninterface PersistedFileTreeState {\n  expandedPaths: string[];\n}\n\nfunction getFileTreeStorageKey(projectName: string): string {\n  return `gran-video-editor:file-tree:${projectName}`;\n}\n\nfunction hasLocalStorageKey(key: string): boolean {\n  if (typeof window === 'undefined') return false;\n  try {\n    return window.localStorage.getItem(key) !== null;\n  } catch {\n    return false;\n  }\n}\n\nfunction readLocalStorageJson<T>(key: string, fallback: T): T {\n  if (typeof window === 'undefined') return fallback;\n  try {\n    const raw = window.localStorage.getItem(key);\n    if (!raw) return fallback;\n    return JSON.parse(raw) as T;\n  } catch {\n    return fallback;\n  }\n}\n\nfunction writeLocalStorageJson(key: string, value: unknown) {\n  if (typeof window === 'undefined') return;\n  try {\n    window.localStorage.setItem(key, JSON.stringify(value));\n  } catch {\n    // ignore\n  }\n}\n\nexport interface FsEntrySelection {\n  kind: 'file' | 'directory';\n  name: string;\n  path?: string;\n  handle: FileSystemFileHandle | FileSystemDirectoryHandle;\n}\n\nexport const useUiStore = defineStore('ui', () => {\n  const selectedFsEntry = ref<FsEntrySelection | null>(null);\n  const showHiddenFiles = ref(readLocalStorageJson('gran-video-editor:show-hidden-files', false));\n\n  watch(showHiddenFiles, (val) =>\n    writeLocalStorageJson('gran-video-editor:show-hidden-files', val),\n  );\n\n  const isGlobalDragging = ref(false);\n  const isFileManagerDragging = ref(false);\n\n  const fileTreeExpandedPaths = ref<Record<string, true>>({});\n  const currentFileTreeProjectName = ref<string | null>(null);\n\n  const pendingFsEntryDelete = ref<any>(null);\n\n  const isSavingFileTree = ref(false);\n  let persistFileTreeTimeout: number | null = null;\n  let fileTreeRevision = 0;\n  let savedFileTreeRevision = 0;\n\n  const fileTreeSaveQueue = new PQueue({ concurrency: 1 });\n\n  function clearPersistFileTreeTimeout() {\n    if (typeof window === 'undefined') return;\n    if (persistFileTreeTimeout === null) return;\n    window.clearTimeout(persistFileTreeTimeout);\n    persistFileTreeTimeout = null;\n  }\n\n  function markFileTreeAsDirty() {\n    fileTreeRevision += 1;\n  }\n\n  function markFileTreeAsCleanForCurrentRevision() {\n    savedFileTreeRevision = fileTreeRevision;\n  }\n\n  function restoreFileTreeStateOnce(projectName: string) {\n    if (typeof window === 'undefined') return;\n    if (currentFileTreeProjectName.value === projectName) return;\n\n    currentFileTreeProjectName.value = projectName;\n\n    const parsed = readLocalStorageJson<PersistedFileTreeState>(\n      getFileTreeStorageKey(projectName),\n      {\n        expandedPaths: [],\n      },\n    );\n\n    const next: Record<string, true> = {};\n    for (const p of parsed.expandedPaths) {\n      if (typeof p === 'string' && p.trim().length > 0) next[p] = true;\n    }\n\n    fileTreeExpandedPaths.value = next;\n    fileTreeRevision = 0;\n    markFileTreeAsCleanForCurrentRevision();\n  }\n\n  function hasPersistedFileTreeState(projectName: string): boolean {\n    return hasLocalStorageKey(getFileTreeStorageKey(projectName));\n  }\n\n  async function persistFileTreeNow(projectName: string) {\n    if (savedFileTreeRevision >= fileTreeRevision) return;\n\n    isSavingFileTree.value = true;\n    const revisionToSave = fileTreeRevision;\n\n    try {\n      const expandedPaths = Object.keys(fileTreeExpandedPaths.value);\n      writeLocalStorageJson(getFileTreeStorageKey(projectName), { expandedPaths });\n\n      if (savedFileTreeRevision < revisionToSave) {\n        savedFileTreeRevision = revisionToSave;\n      }\n    } catch (e) {\n      console.warn('Failed to persist file tree state', e);\n    } finally {\n      isSavingFileTree.value = false;\n    }\n  }\n\n  async function enqueueFileTreeSave(projectName: string) {\n    await fileTreeSaveQueue.add(async () => {\n      await persistFileTreeNow(projectName);\n    });\n  }\n\n  async function requestFileTreeSave(projectName: string, options?: { immediate?: boolean }) {\n    if (options?.immediate) {\n      clearPersistFileTreeTimeout();\n      await enqueueFileTreeSave(projectName);\n      return;\n    }\n\n    if (typeof window === 'undefined') {\n      await enqueueFileTreeSave(projectName);\n      return;\n    }\n\n    clearPersistFileTreeTimeout();\n    persistFileTreeTimeout = window.setTimeout(() => {\n      persistFileTreeTimeout = null;\n      void enqueueFileTreeSave(projectName);\n    }, 500);\n  }\n\n  function isFileTreePathExpanded(path: string): boolean {\n    return Boolean(fileTreeExpandedPaths.value[path]);\n  }\n\n  function setFileTreePathExpanded(projectName: string, path: string, expanded: boolean) {\n    if (!path) return;\n\n    if (expanded) {\n      if (fileTreeExpandedPaths.value[path]) return;\n      fileTreeExpandedPaths.value = { ...fileTreeExpandedPaths.value, [path]: true };\n      markFileTreeAsDirty();\n      void requestFileTreeSave(projectName);\n      return;\n    }\n\n    if (!fileTreeExpandedPaths.value[path]) return;\n    const next = { ...fileTreeExpandedPaths.value };\n\n    const prefix = `${path}/`;\n    for (const key of Object.keys(next)) {\n      if (key === path || key.startsWith(prefix)) {\n        delete next[key];\n      }\n    }\n    fileTreeExpandedPaths.value = next;\n    markFileTreeAsDirty();\n    void requestFileTreeSave(projectName);\n  }\n\n  watch(\n    selectedFsEntry,\n    () => {\n      // keep\n    },\n    { deep: true },\n  );\n\n  return {\n    selectedFsEntry,\n    isGlobalDragging,\n    isFileManagerDragging,\n    fileTreeExpandedPaths,\n    pendingFsEntryDelete,\n    showHiddenFiles,\n    restoreFileTreeStateOnce,\n    hasPersistedFileTreeState,\n    isFileTreePathExpanded,\n    setFileTreePathExpanded,\n  };\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/stores/workspace.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands/audioHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TimelineTrack' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":51,"messageId":"unusedVar","endLine":1,"endColumn":64,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"TimelineTrack"},"fix":{"range":[48,63],"text":""},"desc":"Remove unused variable \"TimelineTrack\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TimelineDocument, TimelineClipItem, TimelineTrack } from '../types';\nimport type {\n  ExtractAudioToTrackCommand,\n  ReturnAudioToVideoCommand,\n  TimelineCommandResult,\n} from '../commands';\nimport { getTrackById, nextItemId, findClipById } from './utils';\n\nexport function extractAudioToTrack(\n  doc: TimelineDocument,\n  cmd: ExtractAudioToTrackCommand,\n): TimelineCommandResult {\n  const videoTrack = getTrackById(doc, cmd.videoTrackId);\n  if (videoTrack.kind !== 'video') throw new Error('Invalid video track');\n  const audioTrack = getTrackById(doc, cmd.audioTrackId);\n  if (audioTrack.kind !== 'audio') throw new Error('Invalid audio track');\n\n  const item = videoTrack.items.find((x) => x.id === cmd.videoItemId);\n  if (!item || item.kind !== 'clip') throw new Error('Video clip not found');\n\n  if (item.clipType !== 'media' && item.clipType !== 'timeline') {\n    throw new Error('Invalid clip type');\n  }\n\n  if (!item.source) {\n    throw new Error('Video clip source is missing');\n  }\n\n  const existingLinked = doc.tracks.some((t) =>\n    t.kind !== 'audio'\n      ? false\n      : t.items.some(\n          (it) =>\n            it.kind === 'clip' && it.linkedVideoClipId === item.id && Boolean(it.lockToLinkedVideo),\n        ),\n  );\n  if (existingLinked) return { next: doc };\n\n  const audioClip: TimelineClipItem = {\n    kind: 'clip',\n    id: nextItemId(audioTrack.id, 'clip'),\n    trackId: audioTrack.id,\n    clipType: item.clipType,\n    name: item.name,\n    source: { ...item.source },\n    sourceDurationUs: item.sourceDurationUs,\n    timelineRange: { ...item.timelineRange },\n    sourceRange: { ...item.sourceRange },\n    linkedVideoClipId: item.id,\n    lockToLinkedVideo: true,\n  };\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.id === videoTrack.id) {\n      return {\n        ...t,\n        items: t.items.map((it) =>\n          it.id === item.id && it.kind === 'clip' ? { ...it, audioFromVideoDisabled: true } : it,\n        ),\n      };\n    }\n    if (t.id === audioTrack.id) {\n      return { ...t, items: [...t.items, audioClip] };\n    }\n    return t;\n  });\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function returnAudioToVideo(\n  doc: TimelineDocument,\n  cmd: ReturnAudioToVideoCommand,\n): TimelineCommandResult {\n  const videoLoc = findClipById(doc, cmd.videoItemId);\n  if (!videoLoc) throw new Error('Video clip not found');\n  if (videoLoc.track.kind !== 'video') throw new Error('Video clip must be on a video track');\n\n  const linkedAudio = doc.tracks\n    .filter((t) => t.kind === 'audio')\n    .flatMap((t) => t.items)\n    .find(\n      (it) =>\n        it.kind === 'clip' &&\n        it.linkedVideoClipId === cmd.videoItemId &&\n        Boolean(it.lockToLinkedVideo),\n    );\n  if (!linkedAudio || linkedAudio.kind !== 'clip') return { next: doc };\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.kind === 'audio') {\n      const nextItems = t.items.filter((it) => it.id !== linkedAudio.id);\n      return nextItems.length === t.items.length ? t : { ...t, items: nextItems };\n    }\n    if (t.kind === 'video') {\n      return {\n        ...t,\n        items: t.items.map((it) =>\n          it.kind === 'clip' && it.id === cmd.videoItemId\n            ? { ...it, audioFromVideoDisabled: false }\n            : it,\n        ),\n      };\n    }\n    return t;\n  });\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands/itemHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":556,"column":27,"messageId":"unexpectedAny","endLine":556,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19829,19832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19829,19832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":613,"column":31,"messageId":"unexpectedAny","endLine":613,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21668,21671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21668,21671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":703,"column":40,"messageId":"unexpectedAny","endLine":703,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25513,25516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25513,25516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":728,"column":28,"messageId":"unexpectedAny","endLine":728,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26251,26254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26251,26254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":730,"column":33,"messageId":"unexpectedAny","endLine":730,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26307,26310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26307,26310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":732,"column":21,"messageId":"unexpectedAny","endLine":732,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26393,26396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26393,26396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":738,"column":28,"messageId":"unexpectedAny","endLine":738,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26515,26518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26515,26518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":740,"column":33,"messageId":"unexpectedAny","endLine":740,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26572,26575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26572,26575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":742,"column":30,"messageId":"unexpectedAny","endLine":742,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26658,26661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26658,26661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":744,"column":31,"messageId":"unexpectedAny","endLine":744,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26715,26718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26715,26718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":798,"column":40,"messageId":"unexpectedAny","endLine":798,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28965,28968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28965,28968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":854,"column":32,"messageId":"unexpectedAny","endLine":854,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31004,31007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31004,31007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":856,"column":25,"messageId":"unexpectedAny","endLine":856,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31057,31060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31057,31060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":863,"column":50,"messageId":"unexpectedAny","endLine":863,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31193,31196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31193,31196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":872,"column":31,"messageId":"unexpectedAny","endLine":872,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31396,31399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31396,31399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":876,"column":28,"messageId":"unexpectedAny","endLine":876,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31618,31621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31618,31621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":878,"column":21,"messageId":"unexpectedAny","endLine":878,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31667,31670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31667,31670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":883,"column":31,"messageId":"unexpectedAny","endLine":883,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31768,31771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31768,31771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":887,"column":28,"messageId":"unexpectedAny","endLine":887,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32002,32005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32002,32005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":889,"column":21,"messageId":"unexpectedAny","endLine":889,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32054,32057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32054,32057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":897,"column":55,"messageId":"unexpectedAny","endLine":897,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32391,32394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32391,32394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":899,"column":49,"messageId":"unexpectedAny","endLine":899,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32526,32529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32526,32529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":901,"column":28,"messageId":"unexpectedAny","endLine":901,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32611,32614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32611,32614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":903,"column":21,"messageId":"unexpectedAny","endLine":903,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32664,32667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32664,32667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":908,"column":55,"messageId":"unexpectedAny","endLine":908,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32877,32880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32877,32880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":910,"column":49,"messageId":"unexpectedAny","endLine":910,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33011,33014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33011,33014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":912,"column":28,"messageId":"unexpectedAny","endLine":912,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33097,33100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33097,33100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":914,"column":21,"messageId":"unexpectedAny","endLine":914,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33151,33154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33151,33154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":923,"column":57,"messageId":"unexpectedAny","endLine":923,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33439,33442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33439,33442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":923,"column":67,"messageId":"unexpectedAny","endLine":923,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33449,33452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33449,33452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":975,"column":35,"messageId":"unexpectedAny","endLine":975,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35509,35512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35509,35512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":991,"column":39,"messageId":"unexpectedAny","endLine":991,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35894,35897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35894,35897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":992,"column":42,"messageId":"unexpectedAny","endLine":992,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35951,35954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35951,35954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":993,"column":43,"messageId":"unexpectedAny","endLine":993,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36012,36015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36012,36015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":994,"column":44,"messageId":"unexpectedAny","endLine":994,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[36075,36078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[36075,36078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1335,"column":10,"messageId":"unexpectedAny","endLine":1335,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47794,47797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47794,47797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1336,"column":49,"messageId":"unexpectedAny","endLine":1336,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47847,47850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47847,47850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1336,"column":62,"messageId":"unexpectedAny","endLine":1336,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47860,47863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47860,47863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1403,"column":63,"messageId":"unexpectedAny","endLine":1403,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50039,50042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50039,50042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1408,"column":22,"messageId":"unexpectedAny","endLine":1408,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50186,50189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50186,50189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1456,"column":59,"messageId":"unexpectedAny","endLine":1456,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[51862,51865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[51862,51865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1456,"column":72,"messageId":"unexpectedAny","endLine":1456,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[51875,51878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[51875,51878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1457,"column":50,"messageId":"unexpectedAny","endLine":1457,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[51931,51934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[51931,51934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1457,"column":63,"messageId":"unexpectedAny","endLine":1457,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[51944,51947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[51944,51947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1490,"column":56,"messageId":"unexpectedAny","endLine":1490,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53093,53096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53093,53096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1491,"column":26,"messageId":"unexpectedAny","endLine":1491,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53140,53143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53140,53143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1498,"column":58,"messageId":"unexpectedAny","endLine":1498,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53522,53525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53522,53525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1499,"column":26,"messageId":"unexpectedAny","endLine":1499,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[53568,53571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[53568,53571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1517,"column":57,"messageId":"unexpectedAny","endLine":1517,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54231,54234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54231,54234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1517,"column":67,"messageId":"unexpectedAny","endLine":1517,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54241,54244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54241,54244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1528,"column":59,"messageId":"unexpectedAny","endLine":1528,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54873,54876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54873,54876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1528,"column":72,"messageId":"unexpectedAny","endLine":1528,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54886,54889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54886,54889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1553,"column":14,"messageId":"unexpectedAny","endLine":1553,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[55839,55842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[55839,55842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1558,"column":14,"messageId":"unexpectedAny","endLine":1558,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[55982,55985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[55982,55985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1564,"column":12,"messageId":"unexpectedAny","endLine":1564,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[56112,56115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[56112,56115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1588,"column":10,"messageId":"unexpectedAny","endLine":1588,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[56695,56698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[56695,56698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1597,"column":10,"messageId":"unexpectedAny","endLine":1597,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[56945,56948],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[56945,56948],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currEndUs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":1603,"column":11,"messageId":"unusedVar","endLine":1603,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":58,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TimelineDocument, TimelineTrackItem, TimelineClipItem } from '../types';\nimport type {\n  AddClipToTrackCommand,\n  AddVirtualClipToTrackCommand,\n  RemoveItemCommand,\n  DeleteItemsCommand,\n  MoveItemCommand,\n  TrimItemCommand,\n  SplitItemCommand,\n  MoveItemToTrackCommand,\n  OverlayPlaceItemCommand,\n  OverlayTrimItemCommand,\n  RenameItemCommand,\n  UpdateClipPropertiesCommand,\n  UpdateClipTransitionCommand,\n  TimelineCommandResult,\n} from '../commands';\nimport {\n  getTrackById,\n  getDocFps,\n  quantizeTimeUsToFrames,\n  usToFrame,\n  frameToUs,\n  computeTrackEndUs,\n  assertNoOverlap,\n  nextItemId,\n  normalizeGaps,\n  findClipById,\n  updateLinkedLockedAudio,\n  quantizeDeltaUsToFrames,\n  clampInt,\n  quantizeRangeToFrames,\n} from './utils';\nimport { normalizeBalance, normalizeGain } from '~/utils/audio/envelope';\n\nfunction assertClipNotLocked(item: TimelineTrackItem, action: string) {\n  if (item.kind !== 'clip') return;\n  if (!item.locked) return;\n  throw new Error(`Locked clip: ${action}`);\n}\n\nexport function addClipToTrack(\n  doc: TimelineDocument,\n  cmd: AddClipToTrackCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const fps = getDocFps(doc);\n  const durationUs = quantizeTimeUsToFrames(Number(cmd.durationUs ?? 0), fps, 'round');\n  const sourceDurationUs = Math.max(\n    0,\n    Math.round(Number(cmd.sourceDurationUs ?? cmd.durationUs ?? 0)),\n  );\n  const startCandidate =\n    cmd.startUs === undefined ? computeTrackEndUs(track) : Math.max(0, Number(cmd.startUs));\n  const startUs = quantizeTimeUsToFrames(startCandidate, fps, 'round');\n\n  assertNoOverlap(track, '', startUs, durationUs);\n\n  const clipType = cmd.clipType === 'timeline' ? 'timeline' : 'media';\n\n  const clip: TimelineClipItem = {\n    kind: 'clip',\n    clipType,\n    id: nextItemId(track.id, 'clip'),\n    trackId: track.id,\n    name: cmd.name,\n    source: { path: cmd.path },\n    sourceDurationUs,\n    isImage: cmd.isImage,\n    timelineRange: { startUs, durationUs },\n    sourceRange: { startUs: 0, durationUs },\n  };\n\n  const nextItemsRaw: TimelineTrackItem[] = [...track.items, clip];\n  nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const nextItems = normalizeGaps(doc, track.id, nextItemsRaw);\n\n  const nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n\n  return {\n    next: {\n      ...doc,\n      tracks: nextTracks,\n    },\n  };\n}\n\nexport function addVirtualClipToTrack(\n  doc: TimelineDocument,\n  cmd: AddVirtualClipToTrackCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const fps = getDocFps(doc);\n\n  if (track.kind !== 'video') {\n    throw new Error('Virtual clips can only be added to video tracks');\n  }\n\n  const durationUs = quantizeTimeUsToFrames(Number(cmd.durationUs ?? 5_000_000), fps, 'round');\n  const startCandidate =\n    cmd.startUs === undefined ? computeTrackEndUs(track) : Math.max(0, Number(cmd.startUs));\n  const startUs = quantizeTimeUsToFrames(startCandidate, fps, 'round');\n\n  assertNoOverlap(track, '', startUs, durationUs);\n\n  const base: Omit<Extract<TimelineClipItem, { kind: 'clip' }>, 'clipType'> & {\n    clipType: AddVirtualClipToTrackCommand['clipType'];\n  } = {\n    kind: 'clip',\n    clipType: cmd.clipType,\n    id: nextItemId(track.id, 'clip'),\n    trackId: track.id,\n    name: cmd.name,\n    timelineRange: { startUs, durationUs },\n    sourceRange: { startUs: 0, durationUs },\n  };\n\n  const clip: TimelineClipItem =\n    cmd.clipType === 'background'\n      ? {\n          ...base,\n          clipType: 'background',\n          backgroundColor: cmd.backgroundColor ?? '#1a56db',\n        }\n      : cmd.clipType === 'text'\n        ? {\n            ...base,\n            clipType: 'text',\n            text: typeof cmd.text === 'string' ? cmd.text : 'Text',\n            style: cmd.style,\n          }\n        : {\n            ...base,\n            clipType: 'adjustment',\n          };\n\n  const nextItemsRaw: TimelineTrackItem[] = [...track.items, clip];\n  nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const nextItems = normalizeGaps(doc, track.id, nextItemsRaw);\n  const nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n\n  return {\n    next: {\n      ...doc,\n      tracks: nextTracks,\n    },\n  };\n}\n\nexport function renameItem(doc: TimelineDocument, cmd: RenameItemCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || item.kind !== 'clip') throw new Error('Item not found or not a clip');\n  if (item.name === cmd.name) return { next: doc };\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.id === track.id) {\n      return {\n        ...t,\n        items: t.items.map((it) =>\n          it.id === cmd.itemId && it.kind === 'clip' ? { ...it, name: cmd.name } : it,\n        ),\n      };\n    }\n    return t;\n  });\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\n/**\n * Pseudo-overlay trim: trims an item and then cuts/trims any clips that overlap\n * with the trimmed item's resulting range.\n */\nexport function overlayTrimItem(\n  doc: TimelineDocument,\n  cmd: OverlayTrimItemCommand,\n): TimelineCommandResult {\n  const fps = getDocFps(doc);\n\n  const track = getTrackById(doc, cmd.trackId);\n  const movedPrev = track.items.find((x) => x.id === cmd.itemId);\n  if (!movedPrev || movedPrev.kind !== 'clip') return { next: doc };\n  const moved = movedPrev as TimelineClipItem;\n\n  assertClipNotLocked(moved, 'trim');\n\n  if (moved.clipType === 'media' && moved.linkedVideoClipId && moved.lockToLinkedVideo) {\n    throw new Error('Locked audio clip');\n  }\n\n  const deltaUs = quantizeDeltaUsToFrames(Number(cmd.deltaUs), fps, 'round');\n  const speed = typeof moved.speed === 'number' && Number.isFinite(moved.speed) ? moved.speed : 1;\n  const sourceDeltaUs = quantizeDeltaUsToFrames(Math.round(deltaUs * speed), fps, 'round');\n\n  const prevTimelineStartUs = Math.max(0, Math.round(moved.timelineRange.startUs));\n  const prevTimelineDurationUs = Math.max(0, Math.round(moved.timelineRange.durationUs));\n\n  const prevSourceStartUs = Math.max(0, Math.round(moved.sourceRange.startUs));\n  const prevSourceDurationUs = Math.max(0, Math.round(moved.sourceRange.durationUs));\n  const prevSourceEndUs = prevSourceStartUs + prevSourceDurationUs;\n\n  const maxSourceDurationUs =\n    moved.clipType === 'media' && !moved.isImage\n      ? Math.max(0, Math.round(moved.sourceDurationUs))\n      : Number.POSITIVE_INFINITY;\n\n  const minSourceStartUs = 0;\n  const maxSourceEndUs = maxSourceDurationUs;\n\n  let nextTimelineStartUs = prevTimelineStartUs;\n  let nextTimelineDurationUs = prevTimelineDurationUs;\n  let nextSourceStartUs = prevSourceStartUs;\n  let nextSourceEndUs = prevSourceEndUs;\n\n  if (cmd.edge === 'start') {\n    const unclampedSourceStartUs = prevSourceStartUs + sourceDeltaUs;\n    nextSourceStartUs = clampInt(unclampedSourceStartUs, minSourceStartUs, prevSourceEndUs);\n    const appliedDeltaUs = nextSourceStartUs - prevSourceStartUs;\n\n    const appliedTimelineDeltaUs = speed > 0 ? Math.round(appliedDeltaUs / speed) : 0;\n    nextTimelineStartUs = Math.max(0, prevTimelineStartUs + appliedTimelineDeltaUs);\n    nextTimelineDurationUs = Math.max(0, prevTimelineDurationUs - appliedTimelineDeltaUs);\n    nextSourceEndUs = prevSourceEndUs;\n  } else {\n    const unclampedSourceEndUs = prevSourceEndUs + sourceDeltaUs;\n    nextSourceEndUs = clampInt(unclampedSourceEndUs, prevSourceStartUs, maxSourceEndUs);\n    const appliedDeltaUs = nextSourceEndUs - prevSourceEndUs;\n\n    const appliedTimelineDeltaUs = speed > 0 ? Math.round(appliedDeltaUs / speed) : 0;\n    nextTimelineDurationUs = Math.max(0, prevTimelineDurationUs + appliedTimelineDeltaUs);\n    nextTimelineStartUs = prevTimelineStartUs;\n    nextSourceStartUs = prevSourceStartUs;\n  }\n\n  const nextSourceDurationUs = Math.max(0, nextSourceEndUs - nextSourceStartUs);\n  const qTimeline = quantizeRangeToFrames(\n    { startUs: nextTimelineStartUs, durationUs: nextTimelineDurationUs },\n    fps,\n  );\n  nextTimelineStartUs = qTimeline.startUs;\n  nextTimelineDurationUs = qTimeline.durationUs;\n\n  const movedNext: TimelineClipItem = {\n    ...moved,\n    timelineRange: { startUs: nextTimelineStartUs, durationUs: nextTimelineDurationUs },\n    sourceRange: { startUs: nextSourceStartUs, durationUs: nextSourceDurationUs },\n  };\n\n  const startUs = movedNext.timelineRange.startUs;\n  const durationUs = Math.max(0, movedNext.timelineRange.durationUs);\n  const endUs = startUs + durationUs;\n\n  const nextItems: TimelineTrackItem[] = [];\n  for (const it of track.items) {\n    if (it.id === moved.id) {\n      nextItems.push(movedNext);\n      continue;\n    }\n    if (it.kind !== 'clip') {\n      nextItems.push(it);\n      continue;\n    }\n\n    if (it.locked) {\n      nextItems.push(it);\n      continue;\n    }\n\n    const itStart = it.timelineRange.startUs;\n    const itEnd = itStart + it.timelineRange.durationUs;\n\n    if (itEnd <= startUs || itStart >= endUs) {\n      nextItems.push(it);\n      continue;\n    }\n\n    // Fully covered: delete\n    if (itStart >= startUs && itEnd <= endUs) {\n      continue;\n    }\n\n    // Overlaps only on the left side: trim end of existing clip\n    if (itStart < startUs && itEnd > startUs && itEnd <= endUs) {\n      const newDuration = quantizeTimeUsToFrames(startUs - itStart, fps, 'floor');\n      if (newDuration > 0) {\n        nextItems.push({\n          ...it,\n          timelineRange: { startUs: itStart, durationUs: newDuration },\n          sourceRange: { ...it.sourceRange, durationUs: newDuration },\n        });\n      }\n      continue;\n    }\n\n    // Overlaps only on the right side: trim start of existing clip\n    if (itStart >= startUs && itStart < endUs && itEnd > endUs) {\n      const trimDelta = endUs - itStart;\n      const newStart = quantizeTimeUsToFrames(endUs, fps, 'ceil');\n      const newDuration = quantizeTimeUsToFrames(itEnd - endUs, fps, 'floor');\n      if (newDuration > 0) {\n        const newSourceStartUs = Math.min(\n          it.sourceRange.startUs + trimDelta,\n          it.sourceRange.startUs + it.sourceRange.durationUs,\n        );\n        nextItems.push({\n          ...it,\n          timelineRange: { startUs: newStart, durationUs: newDuration },\n          sourceRange: {\n            startUs: newSourceStartUs,\n            durationUs: Math.max(0, it.sourceRange.durationUs - trimDelta),\n          },\n        });\n      }\n      continue;\n    }\n\n    // Existing clip fully contains the trimmed item range: split into two\n    if (itStart < startUs && itEnd > endUs) {\n      const leftDuration = quantizeTimeUsToFrames(startUs - itStart, fps, 'floor');\n      if (leftDuration > 0) {\n        nextItems.push({\n          ...it,\n          timelineRange: { startUs: itStart, durationUs: leftDuration },\n          sourceRange: { ...it.sourceRange, durationUs: leftDuration },\n        });\n      }\n\n      const rightTrimDelta = endUs - itStart;\n      const rightStart = quantizeTimeUsToFrames(endUs, fps, 'ceil');\n      const rightDuration = quantizeTimeUsToFrames(itEnd - endUs, fps, 'floor');\n      if (rightDuration > 0) {\n        const rightSourceStartUs = Math.min(\n          it.sourceRange.startUs + rightTrimDelta,\n          it.sourceRange.startUs + it.sourceRange.durationUs,\n        );\n        nextItems.push({\n          ...it,\n          id: nextItemId(track.id, 'clip'),\n          timelineRange: { startUs: rightStart, durationUs: rightDuration },\n          sourceRange: {\n            startUs: rightSourceStartUs,\n            durationUs: Math.max(0, it.sourceRange.durationUs - rightTrimDelta),\n          },\n        });\n      }\n      continue;\n    }\n\n    nextItems.push(it);\n  }\n\n  nextItems.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const docWithMoved: TimelineDocument = {\n    ...doc,\n    tracks: doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t)),\n  };\n  const normalized = normalizeGaps(docWithMoved, track.id, nextItems);\n\n  let nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: normalized } : t));\n\n  if (track.kind === 'video' && movedNext.clipType === 'media') {\n    const updatedMoved = findClipById({ ...doc, tracks: nextTracks }, movedNext.id);\n    if (updatedMoved && updatedMoved.track.kind === 'video') {\n      nextTracks = updateLinkedLockedAudio(\n        { ...doc, tracks: nextTracks },\n        updatedMoved.item.id,\n        (audio) => ({\n          ...audio,\n          timelineRange: {\n            ...audio.timelineRange,\n            startUs: updatedMoved.item.timelineRange.startUs,\n            durationUs: updatedMoved.item.timelineRange.durationUs,\n          },\n          sourceRange: {\n            ...audio.sourceRange,\n            startUs: updatedMoved.item.sourceRange.startUs,\n            durationUs: updatedMoved.item.sourceRange.durationUs,\n          },\n        }),\n      );\n    }\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function splitItem(doc: TimelineDocument, cmd: SplitItemCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || item.kind !== 'clip') return { next: doc };\n\n  if (!cmd.ignoreLocks) {\n    assertClipNotLocked(item, 'split');\n  }\n\n  if (item.clipType === 'media' && item.linkedVideoClipId && item.lockToLinkedVideo) {\n    throw new Error('Locked audio clip');\n  }\n\n  const fps = getDocFps(doc);\n  const qTimeline = quantizeRangeToFrames(item.timelineRange, fps);\n  const startUs = qTimeline.startUs;\n  const endUs = startUs + qTimeline.durationUs;\n\n  const startFrame = usToFrame(startUs, fps, 'round');\n  const endFrame = usToFrame(endUs, fps, 'round');\n  const cutFrame = usToFrame(quantizeTimeUsToFrames(Number(cmd.atUs), fps, 'round'), fps, 'round');\n\n  if (!(cutFrame > startFrame && cutFrame < endFrame)) {\n    return { next: doc };\n  }\n\n  const atUs = frameToUs(cutFrame, fps);\n\n  const leftDurationUs = Math.max(0, atUs - startUs);\n  const rightDurationUs = Math.max(0, endUs - atUs);\n  if (leftDurationUs <= 0 || rightDurationUs <= 0) return { next: doc };\n\n  const speed = typeof item.speed === 'number' && Number.isFinite(item.speed) ? item.speed : 1;\n  const localCutUs = Math.max(0, Math.round((atUs - startUs) * speed));\n  const leftSourceDurationUs = Math.max(0, localCutUs);\n  const rightSourceStartUs = Math.max(0, Math.round(item.sourceRange.startUs) + localCutUs);\n  const rightSourceDurationUs = Math.max(0, Math.round(item.sourceRange.durationUs) - localCutUs);\n\n  const rightItemId = nextItemId(track.id, 'clip');\n\n  const leftPatched: TimelineClipItem = {\n    ...(item as TimelineClipItem),\n    timelineRange: { startUs, durationUs: leftDurationUs },\n    sourceRange: { startUs: item.sourceRange.startUs, durationUs: leftSourceDurationUs },\n    transitionOut: undefined,\n    effects: item.effects ? structuredClone(item.effects) : undefined,\n  };\n\n  // TODO(keyframes): shift keyframes relative time in rightItem's effects by localCutUs\n  const rightItem: TimelineClipItem = {\n    ...(item as TimelineClipItem),\n    id: rightItemId,\n    trackId: track.id,\n    timelineRange: { startUs: atUs, durationUs: rightDurationUs },\n    sourceRange: { startUs: rightSourceStartUs, durationUs: rightSourceDurationUs },\n    transitionIn: undefined,\n    effects: item.effects ? structuredClone(item.effects) : undefined,\n  };\n\n  const nextItemsRaw: TimelineTrackItem[] = [];\n  for (const it of track.items) {\n    if (it.id !== item.id) {\n      nextItemsRaw.push(it);\n      continue;\n    }\n    nextItemsRaw.push(leftPatched);\n    nextItemsRaw.push(rightItem);\n  }\n  nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const nextItems = normalizeGaps(doc, track.id, nextItemsRaw);\n\n  let nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n\n  if (track.kind === 'video' && item.clipType === 'media') {\n    // Split locked linked audio that follows this video item.\n    nextTracks = nextTracks.map((t) => {\n      if (t.kind !== 'audio') return t;\n\n      let changed = false;\n      const patched: TimelineTrackItem[] = [];\n      for (const it of t.items) {\n        if (\n          it.kind === 'clip' &&\n          it.clipType === 'media' &&\n          it.linkedVideoClipId === item.id &&\n          it.lockToLinkedVideo\n        ) {\n          changed = true;\n          const qAudioTimeline = quantizeRangeToFrames(it.timelineRange, fps);\n          const audioStartUs = qAudioTimeline.startUs;\n          const audioEndUs = audioStartUs + qAudioTimeline.durationUs;\n          const audioStartFrame = usToFrame(audioStartUs, fps, 'round');\n          const audioEndFrame = usToFrame(audioEndUs, fps, 'round');\n          if (!(cutFrame > audioStartFrame && cutFrame < audioEndFrame)) {\n            patched.push(it);\n            continue;\n          }\n\n          const leftAudioDurationUs = Math.max(0, atUs - audioStartUs);\n          const rightAudioDurationUs = Math.max(0, audioEndUs - atUs);\n          const audioSpeed =\n            typeof it.speed === 'number' && Number.isFinite(it.speed) ? (it.speed as number) : 1;\n          const audioLocalCutUs = Math.max(0, Math.round((atUs - audioStartUs) * audioSpeed));\n\n          const leftAudio: TimelineClipItem = {\n            ...it,\n            timelineRange: { startUs: audioStartUs, durationUs: leftAudioDurationUs },\n            sourceRange: {\n              startUs: it.sourceRange.startUs,\n              durationUs: Math.max(0, audioLocalCutUs),\n            },\n            transitionOut: undefined,\n            effects: it.effects ? structuredClone(it.effects) : undefined,\n          };\n\n          // TODO(keyframes): shift keyframes relative time in rightAudio's effects by audioLocalCutUs\n          const rightAudio: TimelineClipItem = {\n            ...it,\n            id: nextItemId(t.id, 'clip'),\n            linkedVideoClipId: rightItemId,\n            timelineRange: { startUs: atUs, durationUs: rightAudioDurationUs },\n            sourceRange: {\n              startUs: Math.max(0, Math.round(it.sourceRange.startUs) + audioLocalCutUs),\n              durationUs: Math.max(0, Math.round(it.sourceRange.durationUs) - audioLocalCutUs),\n            },\n            transitionIn: undefined,\n            effects: it.effects ? structuredClone(it.effects) : undefined,\n          };\n\n          patched.push(leftAudio);\n          patched.push(rightAudio);\n        } else {\n          patched.push(it);\n        }\n      }\n\n      if (!changed) return t;\n      patched.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n      return { ...t, items: normalizeGaps(doc, t.id, patched) };\n    });\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function updateClipProperties(\n  doc: TimelineDocument,\n  cmd: UpdateClipPropertiesCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || item.kind !== 'clip') return { next: doc };\n\n  const nextProps: Record<string, unknown> = { ...cmd.properties };\n  const fps = getDocFps(doc);\n\n  function clampNumber(value: unknown, min: number, max: number): number {\n    const n = typeof value === 'number' && Number.isFinite(value) ? value : 0;\n    return Math.max(min, Math.min(max, n));\n  }\n\n  function clampAudioFadeUs(value: unknown, maxUs: number): number | undefined {\n    if (value === undefined) return undefined;\n    const n = typeof value === 'number' && Number.isFinite(value) ? Math.round(value) : 0;\n    return clampNumber(n, 0, Math.max(0, Math.round(maxUs)));\n  }\n\n  function sanitizeTransform(raw: unknown): import('~/timeline/types').ClipTransform | undefined {\n    if (!raw || typeof raw !== 'object') return undefined;\n    const anyRaw = raw as any;\n\n    const scaleRaw = anyRaw.scale;\n    const scale =\n      scaleRaw && typeof scaleRaw === 'object'\n        ? {\n            x: clampNumber(scaleRaw.x, -1000, 1000),\n            y: clampNumber(scaleRaw.y, -1000, 1000),\n            linked: scaleRaw.linked !== undefined ? Boolean(scaleRaw.linked) : undefined,\n          }\n        : undefined;\n\n    const rotationDegRaw = anyRaw.rotationDeg;\n    const rotationDeg =\n      typeof rotationDegRaw === 'number' && Number.isFinite(rotationDegRaw)\n        ? Math.max(-36000, Math.min(36000, rotationDegRaw))\n        : undefined;\n\n    const positionRaw = anyRaw.position;\n    const position =\n      positionRaw && typeof positionRaw === 'object'\n        ? {\n            x: clampNumber(positionRaw.x, -1_000_000, 1_000_000),\n            y: clampNumber(positionRaw.y, -1_000_000, 1_000_000),\n          }\n        : undefined;\n\n    const anchorRaw = anyRaw.anchor;\n    const preset = anchorRaw && typeof anchorRaw === 'object' ? String(anchorRaw.preset ?? '') : '';\n    const safePreset =\n      preset === 'center' ||\n      preset === 'topLeft' ||\n      preset === 'topRight' ||\n      preset === 'bottomLeft' ||\n      preset === 'bottomRight' ||\n      preset === 'custom'\n        ? (preset as import('~/timeline/types').ClipAnchorPreset)\n        : undefined;\n    const anchor =\n      safePreset !== undefined\n        ? {\n            preset: safePreset,\n            x: safePreset === 'custom' ? clampNumber(anchorRaw.x, -10, 10) : undefined,\n            y: safePreset === 'custom' ? clampNumber(anchorRaw.y, -10, 10) : undefined,\n          }\n        : undefined;\n\n    if (!scale && rotationDeg === undefined && !position && !anchor) return undefined;\n    return {\n      scale,\n      rotationDeg,\n      position,\n      anchor,\n    };\n  }\n\n  if ('speed' in nextProps) {\n    const raw = (nextProps as any).speed;\n    const v = typeof raw === 'number' && Number.isFinite(raw) ? raw : undefined;\n    const speed = v === undefined ? undefined : Math.max(0.1, Math.min(10, v));\n    if (speed === undefined) {\n      delete nextProps.speed;\n    } else {\n      nextProps.speed = speed;\n      const nextDurationUsRaw = Math.round(item.sourceRange.durationUs / speed);\n      const nextDurationUs = Math.max(0, quantizeTimeUsToFrames(nextDurationUsRaw, fps, 'round'));\n      const startUs = item.timelineRange.startUs;\n      const prevDurationUs = Math.max(0, item.timelineRange.durationUs);\n\n      const shouldTryRipple = nextDurationUs > prevDurationUs;\n      if (shouldTryRipple) {\n        try {\n          assertNoOverlap(track, item.id, startUs, nextDurationUs);\n          nextProps.timelineRange = { ...item.timelineRange, durationUs: nextDurationUs };\n        } catch {\n          const clips = track.items\n            .filter((it): it is import('~/timeline/types').TimelineClipItem => it.kind === 'clip')\n            .map((c) => ({ ...c, timelineRange: { ...c.timelineRange } }));\n          clips.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n          const movedVideoClipIds: string[] = [];\n          const nextClips = clips.map((c) => {\n            if (c.id !== item.id) return c;\n            return {\n              ...c,\n              speed,\n              timelineRange: { ...c.timelineRange, durationUs: nextDurationUs },\n            };\n          });\n\n          for (let i = 0; i < nextClips.length; i++) {\n            const curr = nextClips[i];\n            if (!curr) continue;\n            const prev = i > 0 ? nextClips[i - 1] : null;\n            if (!prev) continue;\n\n            const prevEndUs = prev.timelineRange.startUs + prev.timelineRange.durationUs;\n            const currStartUs = curr.timelineRange.startUs;\n            if (currStartUs < prevEndUs) {\n              const qStartUs = quantizeTimeUsToFrames(prevEndUs, fps, 'round');\n              if (qStartUs !== currStartUs) {\n                nextClips[i] = {\n                  ...curr,\n                  timelineRange: { ...curr.timelineRange, startUs: qStartUs },\n                };\n                if (track.kind === 'video') {\n                  movedVideoClipIds.push(curr.id);\n                }\n              }\n            }\n          }\n\n          let nextTracksLocal = doc.tracks.map((t) =>\n            t.id === track.id ? { ...t, items: normalizeGaps(doc, t.id, nextClips) } : t,\n          );\n\n          for (const movedId of movedVideoClipIds) {\n            const moved = nextClips.find((c) => c.id === movedId);\n            if (!moved) continue;\n            nextTracksLocal = updateLinkedLockedAudio(\n              { ...doc, tracks: nextTracksLocal },\n              movedId,\n              (audio) => ({\n                ...audio,\n                timelineRange: { ...audio.timelineRange, startUs: moved.timelineRange.startUs },\n              }),\n            );\n          }\n\n          const updatedClip = nextClips.find((c) => c.id === item.id);\n          if (updatedClip && track.kind === 'video' && updatedClip.clipType === 'media') {\n            nextTracksLocal = updateLinkedLockedAudio(\n              { ...doc, tracks: nextTracksLocal },\n              updatedClip.id,\n              (a) => ({\n                ...a,\n                timelineRange: {\n                  ...a.timelineRange,\n                  startUs: updatedClip.timelineRange.startUs,\n                  durationUs: updatedClip.timelineRange.durationUs,\n                },\n                sourceRange: {\n                  ...a.sourceRange,\n                  startUs: updatedClip.sourceRange.startUs,\n                  durationUs: updatedClip.sourceRange.durationUs,\n                },\n                sourceDurationUs: updatedClip.sourceDurationUs,\n                speed: (updatedClip as any).speed,\n              }),\n            );\n          }\n\n          return { next: { ...doc, tracks: nextTracksLocal } };\n        }\n      } else {\n        assertNoOverlap(track, item.id, startUs, nextDurationUs);\n        nextProps.timelineRange = { ...item.timelineRange, durationUs: nextDurationUs };\n      }\n    }\n  }\n  if ('backgroundColor' in nextProps) {\n    if (item.clipType !== 'background') {\n      delete nextProps.backgroundColor;\n    } else {\n      const raw = nextProps.backgroundColor;\n      const value = typeof raw === 'string' ? raw.trim() : '';\n      nextProps.backgroundColor = value.length > 0 ? value : '#000000';\n    }\n  }\n\n  if ('text' in nextProps) {\n    if (item.clipType !== 'text') {\n      delete (nextProps as any).text;\n    } else {\n      const raw = (nextProps as any).text;\n      const safe = typeof raw === 'string' ? raw : '';\n      (nextProps as any).text = safe;\n    }\n  }\n\n  if ('style' in nextProps) {\n    if (item.clipType !== 'text') {\n      delete (nextProps as any).style;\n    } else {\n      const raw = (nextProps as any).style;\n      if (!raw || typeof raw !== 'object') {\n        delete (nextProps as any).style;\n      } else {\n        const anyRaw = raw as any;\n        const fontFamily = typeof anyRaw.fontFamily === 'string' ? anyRaw.fontFamily : undefined;\n        const fontSizeRaw = anyRaw.fontSize;\n        const fontSize =\n          typeof fontSizeRaw === 'number' && Number.isFinite(fontSizeRaw)\n            ? Math.max(1, Math.min(1000, Math.round(fontSizeRaw)))\n            : undefined;\n        const fontWeight =\n          typeof anyRaw.fontWeight === 'string' || typeof anyRaw.fontWeight === 'number'\n            ? anyRaw.fontWeight\n            : undefined;\n        const color = typeof anyRaw.color === 'string' ? anyRaw.color : undefined;\n        const alignRaw = anyRaw.align;\n        const align =\n          alignRaw === 'left' || alignRaw === 'center' || alignRaw === 'right'\n            ? alignRaw\n            : undefined;\n\n        const verticalAlignRaw = anyRaw.verticalAlign;\n        const verticalAlign =\n          verticalAlignRaw === 'top' ||\n          verticalAlignRaw === 'middle' ||\n          verticalAlignRaw === 'bottom'\n            ? verticalAlignRaw\n            : undefined;\n\n        const lineHeightRaw = anyRaw.lineHeight;\n        const lineHeight =\n          typeof lineHeightRaw === 'number' && Number.isFinite(lineHeightRaw)\n            ? Math.max(0.1, Math.min(10, lineHeightRaw))\n            : undefined;\n\n        const letterSpacingRaw = anyRaw.letterSpacing;\n        const letterSpacing =\n          typeof letterSpacingRaw === 'number' && Number.isFinite(letterSpacingRaw)\n            ? Math.max(-1000, Math.min(1000, letterSpacingRaw))\n            : undefined;\n\n        const backgroundColor =\n          typeof anyRaw.backgroundColor === 'string' ? anyRaw.backgroundColor.trim() : undefined;\n\n        const paddingRaw = anyRaw.padding;\n        const padding = (() => {\n          const clampPadding = (v: unknown) =>\n            typeof v === 'number' && Number.isFinite(v)\n              ? Math.max(0, Math.min(10_000, v))\n              : undefined;\n\n          if (typeof paddingRaw === 'number') {\n            const v = clampPadding(paddingRaw);\n            return v === undefined ? undefined : { top: v, right: v, bottom: v, left: v };\n          }\n          if (!paddingRaw || typeof paddingRaw !== 'object') return undefined;\n\n          const anyPad = paddingRaw as any;\n          const x = clampPadding(anyPad.x);\n          const y = clampPadding(anyPad.y);\n          const top = clampPadding(anyPad.top);\n          const right = clampPadding(anyPad.right);\n          const bottom = clampPadding(anyPad.bottom);\n          const left = clampPadding(anyPad.left);\n\n          const fromXY =\n            x !== undefined || y !== undefined\n              ? {\n                  top: y ?? 0,\n                  right: x ?? 0,\n                  bottom: y ?? 0,\n                  left: x ?? 0,\n                }\n              : undefined;\n          const fromEdges =\n            top !== undefined || right !== undefined || bottom !== undefined || left !== undefined\n              ? {\n                  top: top ?? 0,\n                  right: right ?? 0,\n                  bottom: bottom ?? 0,\n                  left: left ?? 0,\n                }\n              : undefined;\n\n          const resolved = fromEdges ?? fromXY;\n          if (!resolved) return undefined;\n          if (\n            resolved.top === 0 &&\n            resolved.right === 0 &&\n            resolved.bottom === 0 &&\n            resolved.left === 0\n          ) {\n            return undefined;\n          }\n          return resolved;\n        })();\n\n        const safeStyle = {\n          ...(fontFamily !== undefined ? { fontFamily } : {}),\n          ...(fontSize !== undefined ? { fontSize } : {}),\n          ...(fontWeight !== undefined ? { fontWeight } : {}),\n          ...(color !== undefined ? { color } : {}),\n          ...(align !== undefined ? { align } : {}),\n          ...(verticalAlign !== undefined ? { verticalAlign } : {}),\n          ...(lineHeight !== undefined ? { lineHeight } : {}),\n          ...(letterSpacing !== undefined ? { letterSpacing } : {}),\n          ...(backgroundColor !== undefined && backgroundColor.length > 0\n            ? { backgroundColor }\n            : {}),\n          ...(padding !== undefined ? { padding } : {}),\n        };\n\n        if (Object.keys(safeStyle).length === 0) {\n          delete (nextProps as any).style;\n        } else {\n          (nextProps as any).style = safeStyle;\n        }\n      }\n    }\n  }\n\n  if ('transform' in nextProps) {\n    const safe = sanitizeTransform((nextProps as any).transform);\n    if (safe === undefined) {\n      delete nextProps.transform;\n    } else {\n      nextProps.transform = safe;\n    }\n  }\n\n  if ('audioGain' in nextProps) {\n    const raw = (nextProps as any).audioGain;\n    const v = typeof raw === 'number' && Number.isFinite(raw) ? raw : undefined;\n    const gain = v === undefined ? undefined : normalizeGain(v, 1);\n    if (gain === undefined) {\n      delete (nextProps as any).audioGain;\n    } else {\n      (nextProps as any).audioGain = gain;\n    }\n  }\n\n  if ('audioBalance' in nextProps) {\n    const raw = (nextProps as any).audioBalance;\n    const v = typeof raw === 'number' && Number.isFinite(raw) ? raw : undefined;\n    const balance = v === undefined ? undefined : normalizeBalance(v, 0);\n    if (balance === undefined) {\n      delete (nextProps as any).audioBalance;\n    } else {\n      (nextProps as any).audioBalance = balance;\n    }\n  }\n\n  // Fade values are stored in timeline microseconds.\n  // Clamp to the current clip duration to avoid invalid envelopes.\n  if ('audioFadeInUs' in nextProps) {\n    const clipDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n    const oppFadeUs = Math.max(0, Math.round((item as any).audioFadeOutUs ?? 0));\n    const maxUs = Math.max(0, clipDurationUs - oppFadeUs);\n    const safe = clampAudioFadeUs((nextProps as any).audioFadeInUs, maxUs);\n    if (safe === undefined) {\n      delete (nextProps as any).audioFadeInUs;\n    } else {\n      (nextProps as any).audioFadeInUs = safe;\n    }\n  }\n  if ('audioFadeOutUs' in nextProps) {\n    const clipDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n    const oppFadeUs = Math.max(0, Math.round((item as any).audioFadeInUs ?? 0));\n    const maxUs = Math.max(0, clipDurationUs - oppFadeUs);\n    const safe = clampAudioFadeUs((nextProps as any).audioFadeOutUs, maxUs);\n    if (safe === undefined) {\n      delete (nextProps as any).audioFadeOutUs;\n    } else {\n      (nextProps as any).audioFadeOutUs = safe;\n    }\n  }\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.id === track.id) {\n      const updatedItems = t.items.map((it) =>\n        it.id === cmd.itemId && it.kind === 'clip'\n          ? (() => {\n              const updated = { ...it, ...(nextProps as any) } as any;\n              const durationUs = Math.max(0, Math.round(updated.timelineRange?.durationUs ?? 0));\n              if (typeof updated.audioGain === 'number') {\n                updated.audioGain = clampNumber(updated.audioGain, 0, 10);\n              }\n              if (typeof updated.audioBalance === 'number') {\n                updated.audioBalance = clampNumber(updated.audioBalance, -1, 1);\n              }\n              if (typeof updated.audioFadeInUs === 'number') {\n                updated.audioFadeInUs = clampNumber(\n                  updated.audioFadeInUs,\n                  0,\n                  Math.max(0, durationUs - (Number(updated.audioFadeOutUs) || 0)),\n                );\n              }\n              if (typeof updated.audioFadeOutUs === 'number') {\n                updated.audioFadeOutUs = clampNumber(\n                  updated.audioFadeOutUs,\n                  0,\n                  Math.max(0, durationUs - (Number(updated.audioFadeInUs) || 0)),\n                );\n              }\n              return updated;\n            })()\n          : it,\n      );\n      const normalized = normalizeGaps(doc, t.id, updatedItems);\n      return { ...t, items: normalized };\n    }\n    return t;\n  });\n\n  let finalTracks = nextTracks;\n  const updatedDoc = { ...doc, tracks: nextTracks };\n  const updated = findClipById(updatedDoc, cmd.itemId);\n  if (updated && updated.track.kind === 'video' && updated.item.clipType === 'media') {\n    if ('timelineRange' in nextProps || 'speed' in nextProps) {\n      finalTracks = updateLinkedLockedAudio(\n        { ...doc, tracks: finalTracks },\n        updated.item.id,\n        (a) => ({\n          ...a,\n          timelineRange: {\n            ...a.timelineRange,\n            startUs: updated.item.timelineRange.startUs,\n            durationUs: updated.item.timelineRange.durationUs,\n          },\n          sourceRange: {\n            ...a.sourceRange,\n            startUs: updated.item.sourceRange.startUs,\n            durationUs: updated.item.sourceRange.durationUs,\n          },\n          speed: (updated.item as any).speed,\n        }),\n      );\n    }\n\n    if (\n      'audioGain' in nextProps ||\n      'audioBalance' in nextProps ||\n      'audioFadeInUs' in nextProps ||\n      'audioFadeOutUs' in nextProps\n    ) {\n      finalTracks = updateLinkedLockedAudio(\n        { ...doc, tracks: finalTracks },\n        updated.item.id,\n        (a) => ({\n          ...a,\n          audioGain: (updated.item as any).audioGain,\n          audioBalance: (updated.item as any).audioBalance,\n          audioFadeInUs: (updated.item as any).audioFadeInUs,\n          audioFadeOutUs: (updated.item as any).audioFadeOutUs,\n        }),\n      );\n    }\n  }\n\n  return { next: { ...doc, tracks: finalTracks } };\n}\n\nexport function removeItems(\n  doc: TimelineDocument,\n  cmd: RemoveItemCommand | DeleteItemsCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const idsToRemove = cmd.type === 'delete_items' ? cmd.itemIds : [cmd.itemId];\n\n  let nextItems = [...track.items];\n  let itemsRemoved = false;\n\n  for (const itemId of idsToRemove) {\n    const idx = nextItems.findIndex((x) => x.id === itemId);\n    if (idx === -1) continue;\n\n    const item = nextItems[idx];\n    if (!item) continue;\n\n    if (item.kind === 'clip' && item.locked && !cmd.ignoreLocks) {\n      continue;\n    }\n    itemsRemoved = true;\n\n    if (item.kind === 'clip') {\n      nextItems.splice(idx, 1);\n    } else if (item.kind === 'gap') {\n      const gapDuration = item.timelineRange.durationUs;\n      const gapEndUs = item.timelineRange.startUs + gapDuration;\n      nextItems.splice(idx, 1);\n      nextItems = nextItems.map((it) => {\n        if (it.timelineRange.startUs >= gapEndUs) {\n          return {\n            ...it,\n            timelineRange: {\n              ...it.timelineRange,\n              startUs: it.timelineRange.startUs - gapDuration,\n            },\n          };\n        }\n        return it;\n      });\n    }\n  }\n\n  if (!itemsRemoved) return { next: doc };\n\n  nextItems.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  nextItems = normalizeGaps(doc, track.id, nextItems);\n\n  const nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function moveItem(doc: TimelineDocument, cmd: MoveItemCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || !item.timelineRange) return { next: doc };\n\n  if (!cmd.ignoreLocks) {\n    assertClipNotLocked(item, 'move');\n  }\n\n  if (\n    item.kind === 'clip' &&\n    item.clipType === 'media' &&\n    item.linkedVideoClipId &&\n    item.lockToLinkedVideo\n  ) {\n    const linked = findClipById(doc, item.linkedVideoClipId);\n    if (!linked) return { next: doc };\n    if (linked.track.kind !== 'video') return { next: doc };\n\n    const startUs = quantizeTimeUsToFrames(cmd.startUs, getDocFps(doc), 'round');\n    const durationUs = Math.max(0, linked.item.timelineRange.durationUs);\n\n    assertNoOverlap(linked.track, linked.item.id, startUs, durationUs);\n\n    let nextTracks = doc.tracks.map((t) => {\n      if (t.id !== linked.track.id) return t;\n      const nextItems: TimelineTrackItem[] = t.items.map((x) =>\n        x.id === linked.item.id\n          ? {\n              ...x,\n              timelineRange: { ...x.timelineRange, startUs },\n            }\n          : x,\n      );\n      nextItems.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n      return { ...t, items: normalizeGaps(doc, t.id, nextItems) };\n    });\n\n    nextTracks = updateLinkedLockedAudio(\n      { ...doc, tracks: nextTracks },\n      linked.item.id,\n      (audio) => ({\n        ...audio,\n        timelineRange: { ...audio.timelineRange, startUs },\n      }),\n    );\n\n    return { next: { ...doc, tracks: nextTracks } };\n  }\n\n  const startUs = quantizeTimeUsToFrames(cmd.startUs, getDocFps(doc), 'round');\n  const durationUs = Math.max(0, item.timelineRange.durationUs);\n\n  assertNoOverlap(track, item.id, startUs, durationUs);\n\n  const nextItemsRaw: TimelineTrackItem[] = track.items.map((x) =>\n    x.id === item.id\n      ? {\n          ...x,\n          timelineRange: { ...x.timelineRange, startUs },\n        }\n      : x,\n  );\n\n  nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const nextItems = normalizeGaps(doc, track.id, nextItemsRaw);\n\n  let nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n\n  if (item.kind === 'clip' && track.kind === 'video') {\n    nextTracks = updateLinkedLockedAudio({ ...doc, tracks: nextTracks }, item.id, (audio) => ({\n      ...audio,\n      timelineRange: { ...audio.timelineRange, startUs },\n    }));\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function moveItemToTrack(\n  doc: TimelineDocument,\n  cmd: MoveItemToTrackCommand,\n): TimelineCommandResult {\n  const fromTrack = getTrackById(doc, cmd.fromTrackId);\n  const toTrack = getTrackById(doc, cmd.toTrackId);\n\n  if (fromTrack.id === toTrack.id) {\n    return moveItem(doc, {\n      type: 'move_item',\n      trackId: fromTrack.id,\n      itemId: cmd.itemId,\n      startUs: cmd.startUs,\n    });\n  }\n\n  const itemIdx = fromTrack.items.findIndex((x) => x.id === cmd.itemId);\n  if (itemIdx === -1) return { next: doc };\n  const item = fromTrack.items[itemIdx];\n  if (!item) return { next: doc };\n  if (!item.timelineRange) return { next: doc };\n\n  assertClipNotLocked(item, 'move');\n  const isLockedLinkedAudio =\n    item.kind === 'clip' &&\n    item.clipType === 'media' &&\n    Boolean(item.linkedVideoClipId) &&\n    Boolean(item.lockToLinkedVideo);\n\n  const startUs = quantizeTimeUsToFrames(cmd.startUs, getDocFps(doc), 'round');\n  const durationUs = Math.max(0, item.timelineRange.durationUs);\n\n  assertNoOverlap(toTrack, item.id, startUs, durationUs);\n\n  const nextFromItemsRaw = [...fromTrack.items];\n  nextFromItemsRaw.splice(itemIdx, 1);\n  const movedItem: TimelineTrackItem = {\n    ...item,\n    trackId: toTrack.id,\n    timelineRange: { ...item.timelineRange, startUs },\n  };\n  const nextToItemsRaw = [...toTrack.items, movedItem];\n  nextToItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n  const nextFromItems = normalizeGaps(doc, fromTrack.id, nextFromItemsRaw);\n  const nextToItems = normalizeGaps(doc, toTrack.id, nextToItemsRaw);\n\n  let nextTracks = doc.tracks.map((t) => {\n    if (t.id === fromTrack.id) return { ...t, items: nextFromItems };\n    if (t.id === toTrack.id) return { ...t, items: nextToItems };\n    return t;\n  });\n\n  if (\n    isLockedLinkedAudio &&\n    item.kind === 'clip' &&\n    item.clipType === 'media' &&\n    item.linkedVideoClipId\n  ) {\n    const linked = findClipById({ ...doc, tracks: nextTracks }, item.linkedVideoClipId);\n    if (linked && linked.track.kind === 'video') {\n      const linkedDurationUs = Math.max(0, linked.item.timelineRange.durationUs);\n      assertNoOverlap(linked.track, linked.item.id, startUs, linkedDurationUs);\n\n      nextTracks = nextTracks.map((t) => {\n        if (t.id !== linked.track.id) return t;\n        const nextItems: TimelineTrackItem[] = t.items.map((x) =>\n          x.id === linked.item.id\n            ? {\n                ...x,\n                timelineRange: { ...x.timelineRange, startUs },\n              }\n            : x,\n        );\n        nextItems.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n        return { ...t, items: normalizeGaps(doc, t.id, nextItems) };\n      });\n\n      nextTracks = updateLinkedLockedAudio(\n        { ...doc, tracks: nextTracks },\n        linked.item.id,\n        (audio) => ({\n          ...audio,\n          timelineRange: { ...audio.timelineRange, startUs },\n        }),\n      );\n    }\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function trimItem(doc: TimelineDocument, cmd: TrimItemCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || !item.timelineRange) return { next: doc };\n  if (item.kind !== 'clip') return { next: doc };\n\n  assertClipNotLocked(item, 'trim');\n  if (item.clipType === 'media' && item.linkedVideoClipId && item.lockToLinkedVideo) {\n    throw new Error('Locked audio clip');\n  }\n\n  const fps = getDocFps(doc);\n  const deltaUs = quantizeDeltaUsToFrames(Number(cmd.deltaUs), fps, 'round');\n\n  const speed = typeof item.speed === 'number' && Number.isFinite(item.speed) ? item.speed : 1;\n  const sourceDeltaUs = quantizeDeltaUsToFrames(Math.round(deltaUs * speed), fps, 'round');\n\n  const prevTimelineStartUs = Math.max(0, Math.round(item.timelineRange.startUs));\n  const prevTimelineDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n\n  const prevSourceStartUs = Math.max(0, Math.round(item.sourceRange.startUs));\n  const prevSourceDurationUs = Math.max(0, Math.round(item.sourceRange.durationUs));\n\n  const prevSourceEndUs = prevSourceStartUs + prevSourceDurationUs;\n  const maxSourceDurationUs =\n    item.clipType === 'media' && !item.isImage\n      ? Math.max(0, Math.round(item.sourceDurationUs))\n      : Number.POSITIVE_INFINITY;\n\n  const minSourceStartUs = 0;\n  const maxSourceEndUs = maxSourceDurationUs;\n\n  let nextTimelineStartUs = prevTimelineStartUs;\n  let nextTimelineDurationUs = prevTimelineDurationUs;\n  let nextSourceStartUs = prevSourceStartUs;\n  let nextSourceEndUs = prevSourceEndUs;\n\n  if (cmd.edge === 'start') {\n    const unclampedSourceStartUs = prevSourceStartUs + sourceDeltaUs;\n    nextSourceStartUs = clampInt(unclampedSourceStartUs, minSourceStartUs, prevSourceEndUs);\n    const appliedDeltaUs = nextSourceStartUs - prevSourceStartUs;\n\n    const appliedTimelineDeltaUs = speed > 0 ? Math.round(appliedDeltaUs / speed) : 0;\n    nextTimelineStartUs = Math.max(0, prevTimelineStartUs + appliedTimelineDeltaUs);\n    nextTimelineDurationUs = Math.max(0, prevTimelineDurationUs - appliedTimelineDeltaUs);\n    nextSourceEndUs = prevSourceEndUs;\n  } else {\n    const unclampedSourceEndUs = prevSourceEndUs + sourceDeltaUs;\n    nextSourceEndUs = clampInt(unclampedSourceEndUs, prevSourceStartUs, maxSourceEndUs);\n    const appliedDeltaUs = nextSourceEndUs - prevSourceEndUs;\n\n    const appliedTimelineDeltaUs = speed > 0 ? Math.round(appliedDeltaUs / speed) : 0;\n    nextTimelineDurationUs = Math.max(0, prevTimelineDurationUs + appliedTimelineDeltaUs);\n    nextTimelineStartUs = prevTimelineStartUs;\n    nextSourceStartUs = prevSourceStartUs;\n  }\n\n  const nextSourceDurationUs = Math.max(0, nextSourceEndUs - nextSourceStartUs);\n\n  const qTimeline = quantizeRangeToFrames(\n    { startUs: nextTimelineStartUs, durationUs: nextTimelineDurationUs },\n    fps,\n  );\n\n  nextTimelineStartUs = qTimeline.startUs;\n  nextTimelineDurationUs = qTimeline.durationUs;\n\n  assertNoOverlap(track, item.id, nextTimelineStartUs, nextTimelineDurationUs);\n\n  const nextItemsRaw: TimelineTrackItem[] = track.items.map((x) =>\n    x.id === item.id\n      ? {\n          ...x,\n          timelineRange: { startUs: nextTimelineStartUs, durationUs: nextTimelineDurationUs },\n          sourceRange: { startUs: nextSourceStartUs, durationUs: nextSourceDurationUs },\n        }\n      : x,\n  );\n\n  nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n  const nextItems = normalizeGaps(doc, track.id, nextItemsRaw);\n\n  let nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, items: nextItems } : t));\n\n  if (track.kind === 'video' && item.clipType === 'media') {\n    nextTracks = updateLinkedLockedAudio({ ...doc, tracks: nextTracks }, item.id, (audio) => ({\n      ...audio,\n      timelineRange: { startUs: nextTimelineStartUs, durationUs: nextTimelineDurationUs },\n      sourceRange: { startUs: nextSourceStartUs, durationUs: nextSourceDurationUs },\n      sourceDurationUs: item.sourceDurationUs,\n    }));\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function updateClipTransition(\n  doc: TimelineDocument,\n  cmd: UpdateClipTransitionCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  const item = track.items.find((x) => x.id === cmd.itemId);\n  if (!item || item.kind !== 'clip') return { next: doc };\n\n  const itemId = item.id;\n\n  const fps = getDocFps(doc);\n\n  function coerceTransition(\n    raw: any,\n  ): { type: string; durationUs: number; mode?: any; curve?: any } | null {\n    if (!raw) return null;\n    const type = typeof raw.type === 'string' ? raw.type : '';\n    const durationUs = Number(raw.durationUs);\n    if (!type) return null;\n    if (!Number.isFinite(durationUs) || durationUs <= 0) return { type, durationUs: 0 };\n    return {\n      type,\n      durationUs: Math.max(0, Math.round(durationUs)),\n      mode: raw.mode,\n      curve: raw.curve,\n    };\n  }\n\n  function findAdjacentClips() {\n    const clips = track.items\n      .filter((it): it is TimelineClipItem => it.kind === 'clip')\n      .map((c) => ({\n        ...c,\n        timelineRange: { ...c.timelineRange },\n        sourceRange: { ...c.sourceRange },\n      }));\n    clips.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n    const idx = clips.findIndex((c) => c.id === itemId);\n    if (idx === -1) return null;\n    const curr = clips[idx];\n    if (!curr) return null;\n    return {\n      ordered: clips,\n      index: idx,\n      prev: idx > 0 ? (clips[idx - 1] ?? null) : null,\n      curr,\n      next: idx < clips.length - 1 ? (clips[idx + 1] ?? null) : null,\n    };\n  }\n\n  function computeAllowedOverlapUs(params: {\n    left: TimelineClipItem;\n    right: TimelineClipItem;\n    requestedUs: number;\n  }): number {\n    const requestedUs = Math.max(0, Math.round(params.requestedUs));\n    if (requestedUs <= 0) return 0;\n\n    const left = params.left;\n    const right = params.right;\n\n    const existingOverlapUs = getCutOverlapUs(left, right);\n\n    const leftSourceEndUs = left.sourceRange.startUs + left.sourceRange.durationUs;\n    const leftMaxEndUs =\n      left.clipType === 'media' && !left.isImage\n        ? Math.max(0, Math.round(left.sourceDurationUs))\n        : Number.POSITIVE_INFINITY;\n    const leftTailHandleUs = Number.isFinite(leftMaxEndUs)\n      ? Math.max(0, leftMaxEndUs - leftSourceEndUs)\n      : requestedUs;\n\n    const leftTotalAvailableOverlapUs = Number.isFinite(leftMaxEndUs)\n      ? Math.max(0, existingOverlapUs + leftTailHandleUs)\n      : requestedUs;\n\n    const overlapUs = Math.min(\n      requestedUs,\n      leftTotalAvailableOverlapUs,\n      Math.max(\n        0,\n        Math.round(left.timelineRange.durationUs) - ((left as any).transitionIn?.durationUs ?? 0),\n      ),\n      Math.max(\n        0,\n        Math.round(right.timelineRange.durationUs) -\n          ((right as any).transitionOut?.durationUs ?? 0),\n      ),\n    );\n    return quantizeDeltaUsToFrames(overlapUs, fps, 'floor');\n  }\n\n  function getCutOverlapUs(left: TimelineClipItem, right: TimelineClipItem): number {\n    const leftEnd = left.timelineRange.startUs + left.timelineRange.durationUs;\n    const rightStart = right.timelineRange.startUs;\n    return Math.max(0, Math.round(leftEnd - rightStart));\n  }\n\n  function applyCutOverlap(params: {\n    left: TimelineClipItem;\n    right: TimelineClipItem;\n    desiredOverlapUs: number;\n  }): { left: TimelineClipItem; right: TimelineClipItem } {\n    const desiredOverlapUs = Math.max(0, Math.round(params.desiredOverlapUs));\n    const currentOverlapUs = getCutOverlapUs(params.left, params.right);\n    const deltaUs = desiredOverlapUs - currentOverlapUs;\n    if (deltaUs === 0) return { left: params.left, right: params.right };\n\n    const left = params.left;\n\n    const nextLeftDurationUs = Math.max(0, Math.round(left.timelineRange.durationUs) + deltaUs);\n    const nextLeftSourceDurationUs = Math.max(0, Math.round(left.sourceRange.durationUs) + deltaUs);\n\n    const leftNext: TimelineClipItem = {\n      ...left,\n      timelineRange: {\n        ...left.timelineRange,\n        durationUs: nextLeftDurationUs,\n      },\n      sourceRange: {\n        ...left.sourceRange,\n        durationUs: nextLeftSourceDurationUs,\n      },\n    };\n\n    return { left: leftNext, right: params.right };\n  }\n\n  const patch: Record<string, unknown> = {};\n\n  const clipDurationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n\n  function clampTransitionUs(input: {\n    edge: 'in' | 'out';\n    requested: { type: string; durationUs: number; mode?: any; curve?: any };\n  }): { type: string; durationUs: number; mode?: any; curve?: any } {\n    const maxUs = Math.max(0, clipDurationUs);\n    return {\n      ...input.requested,\n      durationUs: Math.min(Math.max(0, Math.round(input.requested.durationUs)), maxUs),\n    };\n  }\n\n  let requestedIn = 'transitionIn' in cmd ? coerceTransition(cmd.transitionIn) : undefined;\n  if (requestedIn) {\n    requestedIn = clampTransitionUs({\n      edge: 'in',\n      requested: requestedIn,\n    });\n  }\n\n  let requestedOut = 'transitionOut' in cmd ? coerceTransition(cmd.transitionOut) : undefined;\n  if (requestedOut) {\n    requestedOut = clampTransitionUs({\n      edge: 'out',\n      requested: requestedOut,\n    });\n  }\n\n  if ('transitionIn' in cmd && 'transitionOut' in cmd && requestedIn && requestedOut) {\n    const maxOutUs = Math.max(0, clipDurationUs - requestedIn.durationUs);\n    if (requestedOut.durationUs > maxOutUs) {\n      requestedOut = { ...requestedOut, durationUs: maxOutUs };\n    }\n  }\n\n  // If we are setting one edge and the opposite edge exists, ensure they fit exactly.\n  // When the requested edge grows and would hit the opposite transition, we reduce the opposite.\n  if ('transitionIn' in cmd && requestedIn && (item as any).transitionOut) {\n    const out = (item as any).transitionOut;\n    const maxOppUs = Math.max(0, clipDurationUs - requestedIn.durationUs);\n    const nextOppUs = Math.min(Math.max(0, Math.round(out.durationUs ?? 0)), maxOppUs);\n    if (nextOppUs !== out.durationUs) {\n      patch.transitionOut = nextOppUs <= 0 ? undefined : { ...out, durationUs: nextOppUs };\n    }\n  }\n  if ('transitionOut' in cmd && requestedOut && (item as any).transitionIn) {\n    const inn = (item as any).transitionIn;\n    const maxOppUs = Math.max(0, clipDurationUs - requestedOut.durationUs);\n    const nextOppUs = Math.min(Math.max(0, Math.round(inn.durationUs ?? 0)), maxOppUs);\n    if (nextOppUs !== inn.durationUs) {\n      patch.transitionIn = nextOppUs <= 0 ? undefined : { ...inn, durationUs: nextOppUs };\n    }\n  }\n\n  if ('transitionIn' in cmd) {\n    patch.transitionIn = requestedIn ?? undefined;\n  }\n  if ('transitionOut' in cmd) {\n    patch.transitionOut = requestedOut ?? undefined;\n  }\n\n  const adjacent = findAdjacentClips();\n\n  const patchedItemsById = new Map<string, TimelineTrackItem>();\n  patchedItemsById.set(item.id, { ...item, ...(patch as any) } as any);\n\n  // Auto-overlap when applying a transition on a cut between adjacent clips.\n  // Strategy:\n  // - If setting transitionOut on current and there is an adjacent next clip starting at current end,\n  //   try to overlap them by requested duration (bounded by source handles), and mirror transitionIn on next.\n  // - If setting transitionIn on current and there is an adjacent prev clip ending at current start,\n  //   do the same with prev/current and mirror transitionOut on prev.\n  function patchCut(params: {\n    left: TimelineClipItem;\n    right: TimelineClipItem;\n    requested: { type: string; durationUs: number; mode?: any; curve?: any } | null;\n    clear: boolean;\n  }) {\n    const leftEndUs = params.left.timelineRange.startUs + params.left.timelineRange.durationUs;\n    const rightStartUs = params.right.timelineRange.startUs;\n    const gapUs = Math.max(0, Math.round(rightStartUs - leftEndUs));\n    const existingOverlapUs = getCutOverlapUs(params.left, params.right);\n\n    // Do not auto-stretch across a positive gap. We only support overlap on a cut (adjacent)\n    // or when overlap already exists.\n    const isNearCut = gapUs <= 1_000;\n    if (!isNearCut && existingOverlapUs === 0) {\n      return;\n    }\n\n    if (params.clear || !params.requested || params.requested.durationUs <= 0) {\n      if (existingOverlapUs > 0) {\n        const { left } = applyCutOverlap({\n          left: params.left,\n          right: params.right,\n          desiredOverlapUs: 0,\n        });\n        patchedItemsById.set(left.id, {\n          ...left,\n          transitionOut: undefined,\n        } as any);\n      } else {\n        patchedItemsById.set(params.left.id, {\n          ...params.left,\n          transitionOut: undefined,\n        } as any);\n      }\n\n      patchedItemsById.set(params.right.id, {\n        ...params.right,\n        transitionIn: undefined,\n      } as any);\n      return;\n    }\n\n    const allowedOverlapUs = computeAllowedOverlapUs({\n      left: params.left,\n      right: params.right,\n      requestedUs: params.requested.durationUs,\n    });\n\n    const { left, right } = applyCutOverlap({\n      left: params.left,\n      right: params.right,\n      desiredOverlapUs: allowedOverlapUs,\n    });\n\n    patchedItemsById.set(left.id, {\n      ...left,\n      transitionOut: {\n        type: params.requested.type,\n        durationUs: allowedOverlapUs,\n        mode: params.requested.mode,\n        curve: params.requested.curve,\n      },\n    } as any);\n    patchedItemsById.set(right.id, {\n      ...right,\n      transitionIn: {\n        type: params.requested.type,\n        durationUs: allowedOverlapUs,\n        mode: params.requested.mode,\n        curve: params.requested.curve,\n      },\n    } as any);\n  }\n\n  if (adjacent) {\n    const curr = adjacent.curr;\n    const currStartUs = curr.timelineRange.startUs;\n    const currEndUs = currStartUs + curr.timelineRange.durationUs;\n\n    const prev = adjacent.prev;\n    const next = adjacent.next;\n\n    if ('transitionOut' in cmd && next) {\n      patchCut({\n        left: curr,\n        right: next,\n        requested: requestedOut ?? null,\n        clear: cmd.transitionOut === null,\n      });\n    }\n\n    if ('transitionIn' in cmd && prev) {\n      patchCut({\n        left: prev,\n        right: curr,\n        requested: requestedIn ?? null,\n        clear: cmd.transitionIn === null,\n      });\n    }\n  }\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.id !== track.id) return t;\n    const nextItemsRaw = t.items.map((it) => patchedItemsById.get(it.id) ?? it);\n    nextItemsRaw.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n    const nextItems = normalizeGaps(doc, t.id, nextItemsRaw);\n    return { ...t, items: nextItems };\n  });\n\n  let finalTracks = nextTracks;\n  // If we changed a video media clip timing, keep linked locked audio in sync.\n  // We update for any patched item id that represents a video media clip.\n  const updatedDoc = { ...doc, tracks: nextTracks };\n  for (const updated of patchedItemsById.values()) {\n    if (!updated || updated.kind !== 'clip') continue;\n    if (updated.clipType !== 'media') continue;\n    const resolved = findClipById(updatedDoc, updated.id);\n    if (!resolved || resolved.track.kind !== 'video') continue;\n\n    finalTracks = updateLinkedLockedAudio({ ...doc, tracks: finalTracks }, updated.id, (audio) => ({\n      ...audio,\n      timelineRange: {\n        ...audio.timelineRange,\n        startUs: updated.timelineRange.startUs,\n        durationUs: updated.timelineRange.durationUs,\n      },\n      sourceRange: {\n        ...audio.sourceRange,\n        startUs: updated.sourceRange.startUs,\n        durationUs: updated.sourceRange.durationUs,\n      },\n      sourceDurationUs: updated.sourceDurationUs,\n    }));\n  }\n\n  return { next: { ...doc, tracks: finalTracks } };\n}\n\n/**\n * Pseudo-overlay placement: places an item on the track at startUs,\n * trimming or deleting any clips that overlap with the placed item's range.\n * Clips fully covered are removed; partially covered clips are trimmed.\n */\nexport function overlayPlaceItem(\n  doc: TimelineDocument,\n  cmd: OverlayPlaceItemCommand,\n): TimelineCommandResult {\n  const fromTrack = getTrackById(doc, cmd.fromTrackId);\n  const toTrack = getTrackById(doc, cmd.toTrackId);\n\n  const itemIdx = fromTrack.items.findIndex((x) => x.id === cmd.itemId);\n  if (itemIdx === -1) return { next: doc };\n  const item = fromTrack.items[itemIdx];\n  if (!item || !item.timelineRange) return { next: doc };\n\n  assertClipNotLocked(item, 'move');\n\n  const fps = getDocFps(doc);\n  const startUs = quantizeTimeUsToFrames(cmd.startUs, fps, 'round');\n  const durationUs = Math.max(0, item.timelineRange.durationUs);\n  const endUs = startUs + durationUs;\n\n  const nextFromItemsRaw = fromTrack.items.filter((x) => x.id !== cmd.itemId);\n  const isSameTrack = fromTrack.id === toTrack.id;\n  const destItems: TimelineTrackItem[] = isSameTrack ? [...nextFromItemsRaw] : [...toTrack.items];\n\n  const nextDestItems: TimelineTrackItem[] = [];\n  for (const it of destItems) {\n    if (it.kind !== 'clip') {\n      nextDestItems.push(it);\n      continue;\n    }\n\n    if (it.locked) {\n      const itStartLocked = it.timelineRange.startUs;\n      const itEndLocked = itStartLocked + it.timelineRange.durationUs;\n      const overlapsLocked = itEndLocked > startUs && itStartLocked < endUs;\n      if (overlapsLocked) {\n        throw new Error('Locked clip');\n      }\n      nextDestItems.push(it);\n      continue;\n    }\n\n    const itStart = it.timelineRange.startUs;\n    const itEnd = itStart + it.timelineRange.durationUs;\n\n    if (itEnd <= startUs || itStart >= endUs) {\n      nextDestItems.push(it);\n      continue;\n    }\n\n    // Fully covered: delete\n    if (itStart >= startUs && itEnd <= endUs) {\n      continue;\n    }\n\n    // Overlaps only on the left side: trim end of existing clip\n    if (itStart < startUs && itEnd > startUs && itEnd <= endUs) {\n      const newDuration = quantizeTimeUsToFrames(startUs - itStart, fps, 'floor');\n      if (newDuration > 0) {\n        nextDestItems.push({\n          ...it,\n          timelineRange: { startUs: itStart, durationUs: newDuration },\n          sourceRange: { ...it.sourceRange, durationUs: newDuration },\n        });\n      }\n      continue;\n    }\n\n    // Overlaps only on the right side: trim start of existing clip\n    if (itStart >= startUs && itStart < endUs && itEnd > endUs) {\n      const trimDelta = endUs - itStart;\n      const newStart = quantizeTimeUsToFrames(endUs, fps, 'ceil');\n      const newDuration = quantizeTimeUsToFrames(itEnd - endUs, fps, 'floor');\n      if (newDuration > 0) {\n        const newSourceStartUs = Math.min(\n          it.sourceRange.startUs + trimDelta,\n          it.sourceRange.startUs + it.sourceRange.durationUs,\n        );\n        nextDestItems.push({\n          ...it,\n          timelineRange: { startUs: newStart, durationUs: newDuration },\n          sourceRange: {\n            startUs: newSourceStartUs,\n            durationUs: Math.max(0, it.sourceRange.durationUs - trimDelta),\n          },\n        });\n      }\n      continue;\n    }\n\n    // Existing clip fully contains the new item: split into two\n    if (itStart < startUs && itEnd > endUs) {\n      const leftDuration = quantizeTimeUsToFrames(startUs - itStart, fps, 'floor');\n      if (leftDuration > 0) {\n        nextDestItems.push({\n          ...it,\n          timelineRange: { startUs: itStart, durationUs: leftDuration },\n          sourceRange: { ...it.sourceRange, durationUs: leftDuration },\n        });\n      }\n      const rightTrimDelta = endUs - itStart;\n      const rightStart = quantizeTimeUsToFrames(endUs, fps, 'ceil');\n      const rightDuration = quantizeTimeUsToFrames(itEnd - endUs, fps, 'floor');\n      if (rightDuration > 0) {\n        const rightSourceStartUs = Math.min(\n          it.sourceRange.startUs + rightTrimDelta,\n          it.sourceRange.startUs + it.sourceRange.durationUs,\n        );\n        nextDestItems.push({\n          ...it,\n          id: nextItemId(toTrack.id, 'clip'),\n          timelineRange: { startUs: rightStart, durationUs: rightDuration },\n          sourceRange: {\n            startUs: rightSourceStartUs,\n            durationUs: Math.max(0, it.sourceRange.durationUs - rightTrimDelta),\n          },\n        });\n      }\n      continue;\n    }\n\n    nextDestItems.push(it);\n  }\n\n  const movedItem: TimelineTrackItem = {\n    ...item,\n    trackId: toTrack.id,\n    timelineRange: { ...item.timelineRange, startUs },\n  };\n  nextDestItems.push(movedItem);\n  nextDestItems.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n  const normalizedDest = normalizeGaps(doc, toTrack.id, nextDestItems);\n\n  let nextTracks: typeof doc.tracks;\n  if (isSameTrack) {\n    nextTracks = doc.tracks.map((t) => (t.id === toTrack.id ? { ...t, items: normalizedDest } : t));\n  } else {\n    const normalizedFrom = normalizeGaps(doc, fromTrack.id, nextFromItemsRaw);\n    nextTracks = doc.tracks.map((t) => {\n      if (t.id === fromTrack.id) return { ...t, items: normalizedFrom };\n      if (t.id === toTrack.id) return { ...t, items: normalizedDest };\n      return t;\n    });\n  }\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands/markerHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":23,"messageId":"unexpectedAny","endLine":10,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[279,282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[279,282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TimelineDocument, TimelineMarker } from '../types';\nimport type {\n  AddMarkerCommand,\n  RemoveMarkerCommand,\n  TimelineCommandResult,\n  UpdateMarkerCommand,\n} from '../commands';\n\nfunction getMarkers(doc: TimelineDocument): TimelineMarker[] {\n  const raw = (doc as any)?.metadata?.gran?.markers;\n  return Array.isArray(raw) ? (raw as TimelineMarker[]) : [];\n}\n\nfunction withMarkers(doc: TimelineDocument, markers: TimelineMarker[]): TimelineDocument {\n  return {\n    ...doc,\n    metadata: {\n      ...(doc.metadata ?? {}),\n      gran: {\n        ...(doc.metadata?.gran ?? {}),\n        docId: doc.id,\n        timebase: doc.timebase,\n        markers,\n      },\n    },\n  };\n}\n\nexport function addMarker(doc: TimelineDocument, cmd: AddMarkerCommand): TimelineCommandResult {\n  const markers = getMarkers(doc);\n  if (markers.some((m) => m.id === cmd.id)) {\n    throw new Error('Marker already exists');\n  }\n\n  const marker: TimelineMarker = {\n    id: cmd.id,\n    timeUs: Math.max(0, Math.round(cmd.timeUs)),\n    text: typeof cmd.text === 'string' ? cmd.text : '',\n  };\n\n  const next = [...markers, marker].sort((a, b) => a.timeUs - b.timeUs);\n  return { next: withMarkers(doc, next) };\n}\n\nexport function updateMarker(\n  doc: TimelineDocument,\n  cmd: UpdateMarkerCommand,\n): TimelineCommandResult {\n  const markers = getMarkers(doc);\n  const idx = markers.findIndex((m) => m.id === cmd.id);\n  if (idx === -1) {\n    throw new Error('Marker not found');\n  }\n\n  const prev = markers[idx]!;\n\n  const nextMarker: TimelineMarker = {\n    ...prev,\n    timeUs: cmd.timeUs !== undefined ? Math.max(0, Math.round(Number(cmd.timeUs))) : prev.timeUs,\n    text: cmd.text !== undefined ? String(cmd.text) : prev.text,\n  };\n\n  const nextMarkers = [...markers];\n  nextMarkers[idx] = nextMarker;\n  nextMarkers.sort((a, b) => a.timeUs - b.timeUs);\n\n  return { next: withMarkers(doc, nextMarkers) };\n}\n\nexport function removeMarker(\n  doc: TimelineDocument,\n  cmd: RemoveMarkerCommand,\n): TimelineCommandResult {\n  const markers = getMarkers(doc);\n  if (!markers.some((m) => m.id === cmd.id)) {\n    return { next: doc };\n  }\n  const nextMarkers = markers.filter((m) => m.id !== cmd.id);\n  return { next: withMarkers(doc, nextMarkers) };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands/trackHandlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":38,"messageId":"unexpectedAny","endLine":88,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2675,2678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2675,2678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":38,"messageId":"unexpectedAny","endLine":94,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2936,2939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2936,2939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TimelineDocument, TimelineTrack } from '../types';\nimport type {\n  AddTrackCommand,\n  RenameTrackCommand,\n  DeleteTrackCommand,\n  ReorderTracksCommand,\n  UpdateTrackPropertiesCommand,\n  TimelineCommandResult,\n} from '../commands';\nimport { getTrackById, nextTrackId, normalizeTrackOrder } from './utils';\nimport { normalizeBalance, normalizeGain } from '~/utils/audio/envelope';\n\nexport function addTrack(doc: TimelineDocument, cmd: AddTrackCommand): TimelineCommandResult {\n  const idPrefix = cmd.kind === 'audio' ? 'a' : 'v';\n  const id =\n    typeof cmd.trackId === 'string' && cmd.trackId.trim().length > 0\n      ? cmd.trackId.trim()\n      : nextTrackId(doc, idPrefix);\n\n  if (doc.tracks.some((t) => t.id === id)) {\n    throw new Error('Track already exists');\n  }\n\n  const track: TimelineTrack = {\n    id,\n    kind: cmd.kind,\n    name: cmd.name,\n    items: [],\n  };\n\n  const existingVideo = doc.tracks.filter((t) => t.kind === 'video');\n  const existingAudio = doc.tracks.filter((t) => t.kind === 'audio');\n\n  let nextTracks: TimelineTrack[];\n  if (cmd.kind === 'video') {\n    nextTracks = [track, ...existingVideo, ...existingAudio];\n  } else {\n    nextTracks = [...existingVideo, ...existingAudio, track];\n  }\n\n  return {\n    next: {\n      ...doc,\n      tracks: nextTracks,\n    },\n  };\n}\n\nexport function renameTrack(doc: TimelineDocument, cmd: RenameTrackCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  if (track.name === cmd.name) return { next: doc };\n  const nextTracks = doc.tracks.map((t) => (t.id === track.id ? { ...t, name: cmd.name } : t));\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function deleteTrack(doc: TimelineDocument, cmd: DeleteTrackCommand): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n  if (track.items.length > 0 && !cmd.allowNonEmpty) {\n    throw new Error('Track is not empty');\n  }\n  const nextTracks = doc.tracks.filter((t) => t.id !== track.id);\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function reorderTracks(\n  doc: TimelineDocument,\n  cmd: ReorderTracksCommand,\n): TimelineCommandResult {\n  const nextTracks = normalizeTrackOrder(doc, cmd.trackIds);\n  return { next: { ...doc, tracks: nextTracks } };\n}\n\nexport function updateTrackProperties(\n  doc: TimelineDocument,\n  cmd: UpdateTrackPropertiesCommand,\n): TimelineCommandResult {\n  const track = getTrackById(doc, cmd.trackId);\n\n  const nextTracks = doc.tracks.map((t) => {\n    if (t.id !== track.id) return t;\n\n    const next: TimelineTrack = {\n      ...t,\n      ...cmd.properties,\n    };\n\n    if ('audioGain' in cmd.properties) {\n      const raw = (cmd.properties as any).audioGain;\n      const v = typeof raw === 'number' && Number.isFinite(raw) ? raw : undefined;\n      next.audioGain = v === undefined ? undefined : normalizeGain(v, 1);\n    }\n\n    if ('audioBalance' in cmd.properties) {\n      const raw = (cmd.properties as any).audioBalance;\n      const v = typeof raw === 'number' && Number.isFinite(raw) ? raw : undefined;\n      next.audioBalance = v === undefined ? undefined : normalizeBalance(v, 0);\n    }\n\n    if (next.kind !== 'video') {\n      next.videoHidden = undefined;\n    }\n\n    return next;\n  });\n\n  return { next: { ...doc, tracks: nextTracks } };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/commands/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":30,"messageId":"unexpectedAny","endLine":23,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[586,589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[586,589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'leftStartUs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":142,"column":15,"messageId":"unusedVar","endLine":142,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":44,"messageId":"unexpectedAny","endLine":147,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5268,5271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5268,5271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":45,"messageId":"unexpectedAny","endLine":148,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5345,5348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5345,5348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\n  TimelineClipItem,\n  TimelineDocument,\n  TimelineGapItem,\n  TimelineTrack,\n  TimelineTrackItem,\n} from '../types';\n\nexport const FALLBACK_FPS = 30;\nexport const MIN_FPS = 1;\nexport const MAX_FPS = 240;\n\nexport function sanitizeFps(value: unknown): number {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return FALLBACK_FPS;\n  const rounded = Math.round(parsed);\n  if (rounded < MIN_FPS) return MIN_FPS;\n  if (rounded > MAX_FPS) return MAX_FPS;\n  return rounded;\n}\n\nexport function getDocFps(doc: TimelineDocument): number {\n  return sanitizeFps((doc as any)?.timebase?.fps);\n}\n\nexport type QuantizeMode = 'round' | 'floor' | 'ceil';\n\nexport function usToFrame(timeUs: number, fps: number, mode: QuantizeMode): number {\n  const safeTimeUs = Number.isFinite(timeUs) ? Math.max(0, Math.round(timeUs)) : 0;\n  const safeFps = sanitizeFps(fps);\n  const framesFloat = (safeTimeUs * safeFps) / 1e6;\n  if (mode === 'floor') return Math.max(0, Math.floor(framesFloat));\n  if (mode === 'ceil') return Math.max(0, Math.ceil(framesFloat));\n  return Math.max(0, Math.round(framesFloat));\n}\n\nexport function deltaUsToFrames(deltaUs: number, fps: number, mode: QuantizeMode): number {\n  const safeDeltaUs = Number.isFinite(deltaUs) ? Math.round(deltaUs) : 0;\n  const safeFps = sanitizeFps(fps);\n  const framesFloat = (safeDeltaUs * safeFps) / 1e6;\n  if (mode === 'floor') return Math.floor(framesFloat);\n  if (mode === 'ceil') return Math.ceil(framesFloat);\n  return Math.round(framesFloat);\n}\n\nexport function frameToUs(frameIndex: number, fps: number): number {\n  const safeFrameIndex = Number.isFinite(frameIndex) ? Math.max(0, Math.round(frameIndex)) : 0;\n  const safeFps = sanitizeFps(fps);\n  return Math.max(0, Math.round((safeFrameIndex * 1e6) / safeFps));\n}\n\nexport function quantizeTimeUsToFrames(timeUs: number, fps: number, mode: QuantizeMode): number {\n  return frameToUs(usToFrame(timeUs, fps, mode), fps);\n}\n\nexport function quantizeDeltaUsToFrames(deltaUs: number, fps: number, mode: QuantizeMode): number {\n  const frames = deltaUsToFrames(deltaUs, fps, mode);\n  return Math.round((frames * 1e6) / sanitizeFps(fps));\n}\n\nexport function quantizeRangeToFrames(\n  range: { startUs: number; durationUs: number },\n  fps: number,\n): { startUs: number; durationUs: number } {\n  const startFrame = usToFrame(range.startUs, fps, 'round');\n  const startUs = frameToUs(startFrame, fps);\n\n  const rawEndUs = Math.max(0, Math.round(range.startUs) + Math.round(range.durationUs));\n  const endFrame = usToFrame(rawEndUs, fps, 'round');\n  const endUs = frameToUs(Math.max(startFrame, endFrame), fps);\n\n  return { startUs, durationUs: Math.max(0, endUs - startUs) };\n}\n\nexport function findClipById(\n  doc: TimelineDocument,\n  itemId: string,\n): { track: TimelineTrack; item: TimelineClipItem } | null {\n  for (const t of doc.tracks) {\n    const it = t.items.find((x) => x.id === itemId);\n    if (it && it.kind === 'clip') {\n      return { track: t, item: it };\n    }\n  }\n  return null;\n}\n\nexport function updateLinkedLockedAudio(\n  doc: TimelineDocument,\n  videoItemId: string,\n  patch: (audio: TimelineClipItem) => TimelineClipItem,\n): TimelineTrack[] {\n  return doc.tracks.map((t) => {\n    if (t.kind !== 'audio') return t;\n    let changed = false;\n    const nextItems = t.items.map((it) => {\n      if (it.kind !== 'clip') return it;\n      if (it.linkedVideoClipId !== videoItemId) return it;\n      if (!it.lockToLinkedVideo) return it;\n      changed = true;\n      return patch(it);\n    });\n    return changed ? { ...t, items: nextItems } : t;\n  });\n}\n\nexport function rangesOverlap(aStart: number, aEnd: number, bStart: number, bEnd: number): boolean {\n  return aStart < bEnd && bStart < aEnd;\n}\n\nexport function assertNoOverlap(\n  track: TimelineTrack,\n  movedItemId: string,\n  startUs: number,\n  durationUs: number,\n) {\n  const endUs = startUs + durationUs;\n  const movedItem =\n    track.items.find((x): x is TimelineClipItem => x.id === movedItemId && x.kind === 'clip') ??\n    null;\n\n  for (const it of track.items) {\n    if (it.id === movedItemId) continue;\n    if (it.kind !== 'clip') continue;\n    const itStart = it.timelineRange.startUs;\n    const itEnd = itStart + it.timelineRange.durationUs;\n    if (rangesOverlap(startUs, endUs, itStart, itEnd)) {\n      // Allow overlap when it is a transition crossfade area.\n      // The overlap must be exactly at the end of the left clip and the start of the right clip\n      // and must be fully covered by transitionOut/transitionIn durations.\n      const overlapStart = Math.max(startUs, itStart);\n      const overlapEnd = Math.min(endUs, itEnd);\n      const overlapUs = Math.max(0, overlapEnd - overlapStart);\n      if (overlapUs > 0 && movedItem) {\n        const movedStartUs = startUs;\n        const movedEndUs = endUs;\n\n        const itIsRight = movedStartUs <= itStart;\n        const left = itIsRight ? movedItem : it;\n        const right = itIsRight ? it : movedItem;\n\n        const leftStartUs = itIsRight ? movedStartUs : itStart;\n        const leftEndUs = itIsRight ? movedEndUs : itEnd;\n        const rightStartUs = itIsRight ? itStart : movedStartUs;\n\n        const isCutOverlap = overlapStart === rightStartUs && overlapEnd === leftEndUs;\n        const leftOutDur = Number((left as any).transitionOut?.durationUs);\n        const rightInDur = Number((right as any).transitionIn?.durationUs);\n\n        if (\n          isCutOverlap &&\n          Number.isFinite(leftOutDur) &&\n          Number.isFinite(rightInDur) &&\n          leftOutDur >= overlapUs &&\n          rightInDur >= overlapUs\n        ) {\n          continue;\n        }\n      }\n      throw new Error('Item overlaps with another item');\n    }\n  }\n}\n\nexport function mergeAdjacentGaps(items: TimelineTrackItem[]): TimelineTrackItem[] {\n  if (items.length < 2) return items;\n  const result: TimelineTrackItem[] = [];\n  let current: TimelineTrackItem | undefined = items[0];\n\n  for (let i = 1; i < items.length; i++) {\n    const next = items[i];\n    if (current && next && current.kind === 'gap' && next.kind === 'gap') {\n      current = {\n        ...current,\n        timelineRange: {\n          ...current.timelineRange,\n          durationUs:\n            next.timelineRange.startUs +\n            next.timelineRange.durationUs -\n            current.timelineRange.startUs,\n        },\n      };\n    } else {\n      if (current) result.push(current);\n      current = next;\n    }\n  }\n  if (current) result.push(current);\n  return result;\n}\n\nexport function normalizeGaps(\n  doc: TimelineDocument,\n  trackId: string,\n  items: TimelineTrackItem[],\n): TimelineTrackItem[] {\n  const fps = getDocFps(doc);\n  const clips = items\n    .filter((it): it is TimelineClipItem => it.kind === 'clip')\n    .map((it) => ({ ...it, timelineRange: { ...it.timelineRange } }));\n\n  clips.sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n  const result: TimelineTrackItem[] = [];\n  let cursorUs = 0;\n\n  for (const clip of clips) {\n    const qTimeline = quantizeRangeToFrames(clip.timelineRange, fps);\n    const startUs = qTimeline.startUs;\n    const durationUs = qTimeline.durationUs;\n    const endUs = startUs + durationUs;\n\n    if (startUs > cursorUs) {\n      const gapStartUs = cursorUs;\n      const gapDurationUs = startUs - cursorUs;\n      const gap: TimelineGapItem = {\n        kind: 'gap',\n        id: `gap_${trackId}_${gapStartUs}`,\n        trackId,\n        timelineRange: { startUs: gapStartUs, durationUs: gapDurationUs },\n      };\n      result.push(gap);\n    }\n\n    result.push({\n      ...clip,\n      timelineRange: { startUs, durationUs },\n    });\n    cursorUs = Math.max(cursorUs, endUs);\n  }\n\n  return mergeAdjacentGaps(result);\n}\n\nexport function getTrackById(doc: TimelineDocument, trackId: string): TimelineTrack {\n  const t = doc.tracks.find((x) => x.id === trackId);\n  if (!t) throw new Error('Track not found');\n  return t;\n}\n\nexport function nextTrackId(doc: TimelineDocument, prefix: 'v' | 'a'): string {\n  const ids = new Set(doc.tracks.map((t) => t.id));\n  let n = 1;\n  while (n < 10_000) {\n    const id = `${prefix}${n}`;\n    if (!ids.has(id)) return id;\n    n += 1;\n  }\n  return `${prefix}${Date.now().toString(36)}`;\n}\n\nexport function normalizeTrackOrder(doc: TimelineDocument, trackIds: string[]): TimelineTrack[] {\n  const byId = new Map(doc.tracks.map((t) => [t.id, t] as const));\n  const unique: string[] = [];\n  const seen = new Set<string>();\n  for (const id of trackIds) {\n    if (!byId.has(id)) continue;\n    if (seen.has(id)) continue;\n    seen.add(id);\n    unique.push(id);\n  }\n\n  for (const t of doc.tracks) {\n    if (!seen.has(t.id)) {\n      unique.push(t.id);\n    }\n  }\n\n  const ordered = unique.map((id) => byId.get(id)!).filter(Boolean);\n  const video = ordered.filter((t) => t.kind === 'video');\n  const audio = ordered.filter((t) => t.kind === 'audio');\n  return [...video, ...audio];\n}\n\nexport function nextItemId(trackId: string, prefix: string): string {\n  const cryptoObj = globalThis.crypto;\n  if (cryptoObj && typeof cryptoObj.randomUUID === 'function') {\n    return `${prefix}_${trackId}_${cryptoObj.randomUUID()}`;\n  }\n  return `${prefix}_${trackId}_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 5)}`;\n}\n\nexport function computeTrackEndUs(track: TimelineTrack): number {\n  let end = 0;\n  for (const it of track.items) {\n    end = Math.max(end, it.timelineRange.startUs + it.timelineRange.durationUs);\n  }\n  return end;\n}\n\nexport function clampInt(value: number, min: number, max: number): number {\n  if (!Number.isFinite(value)) return min;\n  if (max < min) return min;\n  return Math.min(max, Math.max(min, Math.round(value)));\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/id.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/otioSerializer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":33,"messageId":"unexpectedAny","endLine":77,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1466,1469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1466,1469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":28,"messageId":"unexpectedAny","endLine":93,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1976,1979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1976,1979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":38,"messageId":"unexpectedAny","endLine":104,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2270,2273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2270,2273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":38,"messageId":"unexpectedAny","endLine":108,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2375,2378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2375,2378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":24,"messageId":"unexpectedAny","endLine":115,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2567,2570],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2567,2570],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":26,"messageId":"unexpectedAny","endLine":120,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2726,2729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2726,2729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":45,"messageId":"unexpectedAny","endLine":125,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2904,2907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2904,2907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":32,"messageId":"unexpectedAny","endLine":136,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3255,3258],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3255,3258],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":38,"messageId":"unexpectedAny","endLine":136,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3261,3264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3261,3264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":24,"messageId":"unexpectedAny","endLine":138,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3340,3343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3340,3343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":31,"messageId":"unexpectedAny","endLine":148,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3646,3649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3646,3649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":28,"messageId":"unexpectedAny","endLine":151,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3783,3786],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3783,3786],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":39,"messageId":"unexpectedAny","endLine":155,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3904,3907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3904,3907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":39,"messageId":"unexpectedAny","endLine":156,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3964,3967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3964,3967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":26,"messageId":"unexpectedAny","endLine":158,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4029,4032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4029,4032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":75,"messageId":"unexpectedAny","endLine":158,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4078,4081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4078,4081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":34,"messageId":"unexpectedAny","endLine":162,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4167,4170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4167,4170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":31,"messageId":"unexpectedAny","endLine":168,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4389,4392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4389,4392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":42,"messageId":"unexpectedAny","endLine":172,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4525,4528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4525,4528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":42,"messageId":"unexpectedAny","endLine":173,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4598,4601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4598,4601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":29,"messageId":"unexpectedAny","endLine":177,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4688,4691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4688,4691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":71,"messageId":"unexpectedAny","endLine":179,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4788,4791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4788,4791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":66,"messageId":"unexpectedAny","endLine":193,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5230,5233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5230,5233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":66,"messageId":"unexpectedAny","endLine":194,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5325,5328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5325,5328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":13,"messageId":"unexpectedAny","endLine":246,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6517,6520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6517,6520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":70,"messageId":"unexpectedAny","endLine":343,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10050,10053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10050,10053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":32,"messageId":"unexpectedAny","endLine":485,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14218,14221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14218,14221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":71,"messageId":"unexpectedAny","endLine":485,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14257,14260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14257,14260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":486,"column":36,"messageId":"unexpectedAny","endLine":486,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14314,14317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14314,14317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":487,"column":34,"messageId":"unexpectedAny","endLine":487,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14361,14364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14361,14364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":487,"column":75,"messageId":"unexpectedAny","endLine":487,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14402,14405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14402,14405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":570,"column":57,"messageId":"unexpectedAny","endLine":570,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17428,17431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17428,17431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":571,"column":55,"messageId":"unexpectedAny","endLine":571,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17516,17519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17516,17519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":572,"column":56,"messageId":"unexpectedAny","endLine":572,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17594,17597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17594,17597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":614,"column":40,"messageId":"unexpectedAny","endLine":614,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18636,18639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18636,18639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":615,"column":29,"messageId":"unexpectedAny","endLine":615,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18696,18699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18696,18699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":646,"column":40,"messageId":"unexpectedAny","endLine":646,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19387,19390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19387,19390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":649,"column":57,"messageId":"unexpectedAny","endLine":649,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19544,19547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19544,19547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":650,"column":25,"messageId":"unexpectedAny","endLine":650,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19584,19587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19584,19587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":673,"column":64,"messageId":"unexpectedAny","endLine":673,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20440,20443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20440,20443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":709,"column":35,"messageId":"unexpectedAny","endLine":709,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21853,21856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21853,21856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":41,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type {\n  TimelineClipItem,\n  TimelineDocument,\n  TimelineGapItem,\n  TimelineMarker,\n  TimelineRange,\n  TimelineTimebase,\n  TimelineTrack,\n  TimelineTrackItem,\n  TrackKind,\n} from './types';\n\ninterface OtioRationalTime {\n  OTIO_SCHEMA: 'RationalTime.1';\n  value: number;\n  rate: number;\n}\n\ninterface OtioTimeRange {\n  OTIO_SCHEMA: 'TimeRange.1';\n  start_time: OtioRationalTime;\n  duration: OtioRationalTime;\n}\n\ninterface OtioExternalReference {\n  OTIO_SCHEMA: 'ExternalReference.1';\n  target_url: string;\n}\n\ninterface OtioClip {\n  OTIO_SCHEMA: 'Clip.1';\n  name: string;\n  media_reference: OtioExternalReference;\n  source_range: OtioTimeRange;\n  enabled?: boolean;\n  metadata?: Record<string, unknown>;\n}\n\ninterface OtioGap {\n  OTIO_SCHEMA: 'Gap.1';\n  name: string;\n  source_range: OtioTimeRange;\n  metadata?: Record<string, unknown>;\n}\n\ninterface OtioTrack {\n  OTIO_SCHEMA: 'Track.1';\n  name: string;\n  kind: 'Video' | 'Audio';\n  children: Array<OtioClip | OtioGap>;\n  metadata?: Record<string, unknown>;\n}\n\ninterface OtioStack {\n  OTIO_SCHEMA: 'Stack.1';\n  name: string;\n  children: OtioTrack[];\n}\n\ninterface OtioTimeline {\n  OTIO_SCHEMA: 'Timeline.1';\n  name: string;\n  tracks: OtioStack;\n  metadata?: Record<string, unknown>;\n}\n\nconst TIME_RATE_US = 1_000_000;\n\nfunction toRationalTimeUs(us: number): OtioRationalTime {\n  return {\n    OTIO_SCHEMA: 'RationalTime.1',\n    value: Math.round(us),\n    rate: TIME_RATE_US,\n  };\n}\n\nfunction fromRationalTimeUs(rt: any): number {\n  const value = Number(rt?.value);\n  const rate = Number(rt?.rate);\n  if (!Number.isFinite(value) || !Number.isFinite(rate) || rate <= 0) return 0;\n  if (rate === TIME_RATE_US) return Math.round(value);\n  return Math.round((value / rate) * TIME_RATE_US);\n}\n\nfunction toTimeRange(range: TimelineRange): OtioTimeRange {\n  return {\n    OTIO_SCHEMA: 'TimeRange.1',\n    start_time: toRationalTimeUs(range.startUs),\n    duration: toRationalTimeUs(range.durationUs),\n  };\n}\n\nfunction fromTimeRange(tr: any): TimelineRange {\n  return {\n    startUs: fromRationalTimeUs(tr?.start_time),\n    durationUs: fromRationalTimeUs(tr?.duration),\n  };\n}\n\nfunction trackKindToOtioKind(kind: TrackKind): 'Video' | 'Audio' {\n  return kind === 'audio' ? 'Audio' : 'Video';\n}\n\nfunction trackKindFromOtioKind(kind: any): TrackKind {\n  return kind === 'Audio' ? 'audio' : 'video';\n}\n\nfunction assertTimelineTimebase(raw: any): TimelineTimebase {\n  const fps = Number(raw?.fps);\n  return {\n    fps: Number.isFinite(fps) && fps > 0 ? Math.round(Math.min(240, Math.max(1, fps))) : 25,\n  };\n}\n\nfunction coerceId(raw: any, fallback: string): string {\n  const v = typeof raw === 'string' && raw.trim().length > 0 ? raw.trim() : fallback;\n  return v;\n}\n\nfunction coerceName(raw: any, fallback: string): string {\n  const v = typeof raw === 'string' && raw.trim().length > 0 ? raw.trim() : fallback;\n  return v;\n}\n\nfunction parseItemSequenceDurationUs(child: any): number {\n  if (!child || typeof child !== 'object') return 0;\n  if (child.OTIO_SCHEMA === 'Gap.1') {\n    return Math.max(0, fromRationalTimeUs(child?.source_range?.duration));\n  }\n  if (child.OTIO_SCHEMA === 'Clip.1') {\n    return Math.max(0, fromRationalTimeUs(child?.source_range?.duration));\n  }\n  return 0;\n}\n\nfunction safeGranMetadata(raw: any): any {\n  if (!raw || typeof raw !== 'object') return {};\n  const gran = (raw as any).gran;\n  if (!gran || typeof gran !== 'object') return {};\n  return gran;\n}\n\nfunction clampNumber(value: unknown, min: number, max: number): number {\n  const n = typeof value === 'number' && Number.isFinite(value) ? value : 0;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction coerceTransform(raw: any): import('./types').ClipTransform | undefined {\n  if (!raw || typeof raw !== 'object') return undefined;\n\n  const scaleRaw = (raw as any).scale;\n  const scale =\n    scaleRaw && typeof scaleRaw === 'object'\n      ? {\n          x: clampNumber((scaleRaw as any).x, -1000, 1000),\n          y: clampNumber((scaleRaw as any).y, -1000, 1000),\n          linked:\n            (scaleRaw as any).linked !== undefined ? Boolean((scaleRaw as any).linked) : undefined,\n        }\n      : undefined;\n\n  const rotationDegRaw = (raw as any).rotationDeg;\n  const rotationDeg =\n    typeof rotationDegRaw === 'number' && Number.isFinite(rotationDegRaw)\n      ? Math.max(-36000, Math.min(36000, rotationDegRaw))\n      : undefined;\n\n  const positionRaw = (raw as any).position;\n  const position =\n    positionRaw && typeof positionRaw === 'object'\n      ? {\n          x: clampNumber((positionRaw as any).x, -1_000_000, 1_000_000),\n          y: clampNumber((positionRaw as any).y, -1_000_000, 1_000_000),\n        }\n      : undefined;\n\n  const anchorRaw = (raw as any).anchor;\n  const preset =\n    anchorRaw && typeof anchorRaw === 'object' ? String((anchorRaw as any).preset ?? '') : '';\n  const safePreset =\n    preset === 'center' ||\n    preset === 'topLeft' ||\n    preset === 'topRight' ||\n    preset === 'bottomLeft' ||\n    preset === 'bottomRight' ||\n    preset === 'custom'\n      ? (preset as import('./types').ClipAnchorPreset)\n      : undefined;\n  const anchor =\n    safePreset !== undefined\n      ? {\n          preset: safePreset,\n          x: safePreset === 'custom' ? clampNumber((anchorRaw as any).x, -10, 10) : undefined,\n          y: safePreset === 'custom' ? clampNumber((anchorRaw as any).y, -10, 10) : undefined,\n        }\n      : undefined;\n\n  if (!scale && rotationDeg === undefined && !position && !anchor) return undefined;\n  return {\n    scale,\n    rotationDeg,\n    position,\n    anchor,\n  };\n}\n\nfunction hashString(input: string): string {\n  let hash = 0;\n  for (let i = 0; i < input.length; i += 1) {\n    hash = (hash * 31 + input.charCodeAt(i)) >>> 0;\n  }\n  return hash.toString(36);\n}\n\nfunction buildFallbackItemId(input: {\n  prefix: 'clip' | 'gap';\n  trackId: string;\n  fingerprint: string;\n  occupiedIds: Set<string>;\n}): string {\n  const base = `${input.prefix}_${input.trackId}_${hashString(input.fingerprint)}`;\n  if (!input.occupiedIds.has(base)) {\n    input.occupiedIds.add(base);\n    return base;\n  }\n\n  let suffix = 2;\n  while (suffix < 10_000) {\n    const candidate = `${base}_${suffix}`;\n    if (!input.occupiedIds.has(candidate)) {\n      input.occupiedIds.add(candidate);\n      return candidate;\n    }\n    suffix += 1;\n  }\n\n  const emergency = `${base}_${Date.now()}`;\n  input.occupiedIds.add(emergency);\n  return emergency;\n}\n\nfunction resolveStableItemId(input: {\n  prefix: 'clip' | 'gap';\n  trackId: string;\n  fallbackFingerprint: string;\n  metadata: any;\n  occupiedIds: Set<string>;\n}): string {\n  const metadataId = coerceId(input.metadata?.id, '');\n  if (metadataId && !input.occupiedIds.has(metadataId)) {\n    input.occupiedIds.add(metadataId);\n    return metadataId;\n  }\n\n  return buildFallbackItemId({\n    prefix: input.prefix,\n    trackId: input.trackId,\n    fingerprint: input.fallbackFingerprint,\n    occupiedIds: input.occupiedIds,\n  });\n}\n\nfunction parseClipItem(input: {\n  trackId: string;\n  otio: OtioClip;\n  index: number;\n  occupiedIds: Set<string>;\n  fallbackStartUs: number;\n}): TimelineClipItem {\n  const { trackId, otio, index, occupiedIds, fallbackStartUs } = input;\n  const sourceRange = fromTimeRange(otio.source_range);\n  const name = coerceName(otio.name, `clip_${index + 1}`);\n  const path =\n    typeof otio.media_reference?.target_url === 'string' ? otio.media_reference.target_url : '';\n  const granMeta = safeGranMetadata(otio.metadata);\n  const clipTypeRaw = granMeta?.clipType;\n  const clipType =\n    clipTypeRaw === 'background' ||\n    clipTypeRaw === 'adjustment' ||\n    clipTypeRaw === 'media' ||\n    clipTypeRaw === 'timeline' ||\n    clipTypeRaw === 'text'\n      ? clipTypeRaw\n      : 'media';\n  const timelineStartUs = fallbackStartUs;\n  const sourceDurationUs = Math.max(0, Math.round(Number(granMeta?.sourceDurationUs ?? 0)));\n  const id = resolveStableItemId({\n    prefix: 'clip',\n    trackId,\n    fallbackFingerprint: JSON.stringify({\n      path,\n      sourceStartUs: sourceRange.startUs,\n      sourceDurationUs: sourceRange.durationUs,\n      timelineStartUs,\n      name,\n    }),\n    metadata: granMeta,\n    occupiedIds,\n  });\n\n  const base = {\n    kind: 'clip' as const,\n    clipType,\n    id,\n    trackId,\n    name,\n    disabled: otio.enabled === false ? true : undefined,\n    locked: granMeta?.locked !== undefined ? Boolean(granMeta.locked) : undefined,\n    sourceDurationUs: sourceDurationUs > 0 ? sourceDurationUs : sourceRange.durationUs,\n    timelineRange: { startUs: timelineStartUs, durationUs: sourceRange.durationUs },\n    sourceRange,\n    speed:\n      typeof granMeta?.speed === 'number' && Number.isFinite(granMeta.speed)\n        ? Math.max(0.1, Math.min(10, Number(granMeta.speed)))\n        : undefined,\n    audioGain:\n      typeof granMeta?.audioGain === 'number' && Number.isFinite(granMeta.audioGain)\n        ? Math.max(0, Math.min(10, Number(granMeta.audioGain)))\n        : undefined,\n    audioBalance:\n      typeof granMeta?.audioBalance === 'number' && Number.isFinite(granMeta.audioBalance)\n        ? Math.max(-1, Math.min(1, Number(granMeta.audioBalance)))\n        : undefined,\n    audioFadeInUs:\n      typeof granMeta?.audioFadeInUs === 'number' && Number.isFinite(granMeta.audioFadeInUs)\n        ? Math.max(0, Math.round(granMeta.audioFadeInUs))\n        : undefined,\n    audioFadeOutUs:\n      typeof granMeta?.audioFadeOutUs === 'number' && Number.isFinite(granMeta.audioFadeOutUs)\n        ? Math.max(0, Math.round(granMeta.audioFadeOutUs))\n        : undefined,\n    audioFromVideoDisabled: Boolean(granMeta?.audioFromVideoDisabled),\n    freezeFrameSourceUs:\n      clipType === 'media' &&\n      typeof granMeta?.freezeFrameSourceUs === 'number' &&\n      Number.isFinite(granMeta.freezeFrameSourceUs)\n        ? Math.max(0, Math.round(granMeta.freezeFrameSourceUs))\n        : undefined,\n    opacity:\n      typeof granMeta?.opacity === 'number' && Number.isFinite(granMeta.opacity)\n        ? Math.max(0, Math.min(1, granMeta.opacity))\n        : undefined,\n    effects: Array.isArray(granMeta?.effects) ? (granMeta.effects as any[]) : undefined,\n    transitionIn:\n      granMeta?.transitionIn &&\n      typeof granMeta.transitionIn.type === 'string' &&\n      typeof granMeta.transitionIn.durationUs === 'number'\n        ? {\n            type: granMeta.transitionIn.type,\n            durationUs: Math.max(0, Math.round(granMeta.transitionIn.durationUs)),\n          }\n        : undefined,\n    transitionOut:\n      granMeta?.transitionOut &&\n      typeof granMeta.transitionOut.type === 'string' &&\n      typeof granMeta.transitionOut.durationUs === 'number'\n        ? {\n            type: granMeta.transitionOut.type,\n            durationUs: Math.max(0, Math.round(granMeta.transitionOut.durationUs)),\n          }\n        : undefined,\n    linkedVideoClipId:\n      typeof granMeta?.linkedVideoClipId === 'string' &&\n      granMeta.linkedVideoClipId.trim().length > 0\n        ? granMeta.linkedVideoClipId\n        : undefined,\n    lockToLinkedVideo:\n      granMeta?.lockToLinkedVideo !== undefined ? Boolean(granMeta.lockToLinkedVideo) : undefined,\n    isImage: granMeta?.isImage !== undefined ? Boolean(granMeta.isImage) : undefined,\n    transform: coerceTransform(granMeta?.transform),\n  };\n\n  if (clipType === 'background') {\n    return {\n      ...base,\n      clipType: 'background',\n      source: { path: path || '' },\n      backgroundColor:\n        typeof granMeta?.backgroundColor === 'string' && granMeta.backgroundColor.trim().length > 0\n          ? granMeta.backgroundColor\n          : '#000000',\n    };\n  }\n\n  if (clipType === 'adjustment') {\n    return { ...base, clipType: 'adjustment', source: { path: path || '' } };\n  }\n\n  if (clipType === 'text') {\n    const text = typeof granMeta?.text === 'string' ? granMeta.text : 'Text';\n    const style =\n      granMeta?.style && typeof granMeta.style === 'object' ? granMeta.style : undefined;\n    return {\n      kind: 'clip',\n      clipType: 'text',\n      id,\n      trackId,\n      name,\n      sourceDurationUs: sourceDurationUs > 0 ? sourceDurationUs : sourceRange.durationUs,\n      timelineRange: { startUs: timelineStartUs, durationUs: sourceRange.durationUs },\n      sourceRange,\n      text,\n      style,\n      transform: coerceTransform(granMeta?.transform),\n    };\n  }\n\n  if (clipType === 'timeline') {\n    return {\n      ...base,\n      clipType: 'timeline',\n      source: { path },\n    };\n  }\n\n  return {\n    ...base,\n    clipType: 'media',\n    source: { path },\n  };\n}\n\nfunction parseGapItem(input: {\n  trackId: string;\n  otio: OtioGap;\n  index: number;\n  occupiedIds: Set<string>;\n  fallbackStartUs: number;\n}): TimelineGapItem {\n  const { trackId, otio, index, occupiedIds, fallbackStartUs } = input;\n  const range = fromTimeRange(otio.source_range);\n  const granMeta = safeGranMetadata(otio.metadata);\n  const timelineStartUs = fallbackStartUs;\n  const id = resolveStableItemId({\n    prefix: 'gap',\n    trackId,\n    fallbackFingerprint: JSON.stringify({\n      durationUs: range.durationUs,\n      timelineStartUs,\n      index,\n    }),\n    metadata: granMeta,\n    occupiedIds,\n  });\n\n  return {\n    kind: 'gap',\n    id,\n    trackId,\n    timelineRange: { startUs: timelineStartUs, durationUs: range.durationUs },\n  };\n}\n\nexport function createDefaultTimelineDocument(params: {\n  id: string;\n  name: string;\n  fps: number;\n}): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: params.id,\n    name: params.name,\n    timebase: { fps: params.fps },\n    tracks: [\n      { id: 'v1', kind: 'video', name: 'Video 1', videoHidden: false, items: [] },\n      { id: 'v2', kind: 'video', name: 'Video 2', videoHidden: false, items: [] },\n      { id: 'a1', kind: 'audio', name: 'Audio 1', audioMuted: false, audioSolo: false, items: [] },\n      { id: 'a2', kind: 'audio', name: 'Audio 2', audioMuted: false, audioSolo: false, items: [] },\n    ],\n    metadata: {\n      gran: {\n        docId: params.id,\n        timebase: { fps: params.fps },\n        markers: [],\n      },\n    },\n  };\n}\n\nfunction coerceMarkers(raw: unknown): TimelineMarker[] {\n  if (!Array.isArray(raw)) return [];\n  const result: TimelineMarker[] = [];\n  for (const item of raw) {\n    if (!item || typeof item !== 'object') continue;\n    const id = typeof (item as any).id === 'string' ? String((item as any).id).trim() : '';\n    const timeUs = Number((item as any).timeUs);\n    const text = typeof (item as any).text === 'string' ? String((item as any).text) : '';\n    if (!id) continue;\n    if (!Number.isFinite(timeUs)) continue;\n    result.push({ id, timeUs: Math.max(0, Math.round(timeUs)), text });\n  }\n  result.sort((a, b) => a.timeUs - b.timeUs);\n  return result;\n}\n\nexport function serializeTimelineToOtio(doc: TimelineDocument): string {\n  const tracks: OtioTrack[] = doc.tracks.map((t) => {\n    const sortedItems = [...t.items].sort(\n      (a, b) => a.timelineRange.startUs - b.timelineRange.startUs,\n    );\n    const children: Array<OtioClip | OtioGap> = [];\n    let cursorUs = 0;\n    for (const item of sortedItems) {\n      const startUs = Math.max(0, Math.round(item.timelineRange.startUs));\n      const durationUs = Math.max(0, Math.round(item.timelineRange.durationUs));\n\n      if (startUs > cursorUs) {\n        const gapDurationUs = startUs - cursorUs;\n        children.push({\n          OTIO_SCHEMA: 'Gap.1',\n          name: 'gap',\n          source_range: toTimeRange({ startUs: 0, durationUs: gapDurationUs }),\n          metadata: {\n            gran: {\n              id: `gap_${t.id}_${cursorUs}`,\n            },\n          },\n        });\n        cursorUs = startUs;\n      }\n\n      if (item.kind === 'gap') {\n        children.push({\n          OTIO_SCHEMA: 'Gap.1',\n          name: 'gap',\n          source_range: toTimeRange({ startUs: 0, durationUs }),\n          metadata: {\n            gran: {\n              id: item.id,\n            },\n          },\n        });\n        cursorUs += durationUs;\n        continue;\n      }\n\n      children.push({\n        OTIO_SCHEMA: 'Clip.1',\n        name: item.name,\n        enabled: item.disabled ? false : undefined,\n        media_reference: {\n          OTIO_SCHEMA: 'ExternalReference.1',\n          target_url:\n            item.clipType === 'media' || item.clipType === 'timeline' ? item.source.path : '',\n        },\n        source_range: toTimeRange(item.sourceRange),\n        metadata: {\n          gran: {\n            id: item.id,\n            clipType: item.clipType,\n            locked: item.locked ? true : undefined,\n            sourceDurationUs:\n              item.clipType === 'media' || item.clipType === 'timeline'\n                ? item.sourceDurationUs\n                : undefined,\n            speed: item.speed,\n            audioGain: item.audioGain,\n            audioFadeInUs: item.audioFadeInUs,\n            audioFadeOutUs: item.audioFadeOutUs,\n            audioFromVideoDisabled:\n              item.clipType === 'media' ? Boolean(item.audioFromVideoDisabled) : undefined,\n            freezeFrameSourceUs: item.clipType === 'media' ? item.freezeFrameSourceUs : undefined,\n            opacity: item.opacity,\n            effects: item.effects,\n            transitionIn: item.transitionIn,\n            transitionOut: item.transitionOut,\n            linkedVideoClipId: item.clipType === 'media' ? item.linkedVideoClipId : undefined,\n            lockToLinkedVideo: item.clipType === 'media' ? item.lockToLinkedVideo : undefined,\n            backgroundColor:\n              item.clipType === 'background' ? (item as any).backgroundColor : undefined,\n            text: item.clipType === 'text' ? (item as any).text : undefined,\n            style: item.clipType === 'text' ? (item as any).style : undefined,\n            isImage: item.isImage,\n            transform: item.transform,\n          },\n        },\n      });\n      cursorUs += durationUs;\n    }\n\n    return {\n      OTIO_SCHEMA: 'Track.1',\n      name: t.name,\n      kind: trackKindToOtioKind(t.kind),\n      children,\n      metadata: {\n        gran: {\n          id: t.id,\n          kind: t.kind,\n          name: t.name,\n          videoHidden: t.kind === 'video' ? Boolean(t.videoHidden) : undefined,\n          audioMuted: Boolean(t.audioMuted),\n          audioSolo: Boolean(t.audioSolo),\n          audioGain: t.audioGain,\n          audioBalance: t.audioBalance,\n          effects: Array.isArray(t.effects) ? t.effects : undefined,\n        },\n      },\n    };\n  });\n\n  const payload: OtioTimeline = {\n    OTIO_SCHEMA: 'Timeline.1',\n    name: doc.name,\n    tracks: {\n      OTIO_SCHEMA: 'Stack.1',\n      name: 'tracks',\n      children: tracks,\n    },\n    metadata: {\n      gran: {\n        docId: doc.id,\n        timebase: doc.timebase,\n        markers: coerceMarkers((doc as any)?.metadata?.gran?.markers),\n        playheadUs: (doc as any)?.metadata?.gran?.playheadUs,\n      },\n    },\n  };\n\n  return `${JSON.stringify(payload, null, 2)}\\n`;\n}\n\nexport function parseTimelineFromOtio(\n  text: string,\n  fallback: { id: string; name: string; fps: number },\n): TimelineDocument {\n  let parsed: OtioTimeline | null = null;\n  try {\n    parsed = JSON.parse(text);\n  } catch {\n    return createDefaultTimelineDocument({\n      id: fallback.id,\n      name: fallback.name,\n      fps: fallback.fps,\n    });\n  }\n\n  if (!parsed || parsed.OTIO_SCHEMA !== 'Timeline.1') {\n    return createDefaultTimelineDocument({\n      id: fallback.id,\n      name: fallback.name,\n      fps: fallback.fps,\n    });\n  }\n\n  const granMeta = (parsed.metadata as any)?.gran;\n  const timebase = assertTimelineTimebase(granMeta?.timebase ?? { fps: fallback.fps });\n\n  const stackChildren = Array.isArray((parsed.tracks as any)?.children)\n    ? (parsed.tracks as any).children\n    : [];\n\n  const tracks: TimelineTrack[] = stackChildren.map((otioTrack: OtioTrack, trackIndex: number) => {\n    const trackGranMeta = safeGranMetadata(otioTrack.metadata);\n\n    const id = coerceId(\n      trackGranMeta?.id,\n      `${otioTrack.kind === 'Audio' ? 'a' : 'v'}${trackIndex + 1}`,\n    );\n    const kind =\n      trackGranMeta?.kind === 'audio' || trackGranMeta?.kind === 'video'\n        ? trackGranMeta.kind\n        : trackKindFromOtioKind(otioTrack.kind);\n    const name = coerceName(\n      trackGranMeta?.name ?? otioTrack.name,\n      kind === 'audio' ? `Audio ${trackIndex + 1}` : `Video ${trackIndex + 1}`,\n    );\n\n    const children = Array.isArray(otioTrack.children) ? otioTrack.children : [];\n    const occupiedIds = new Set<string>();\n    let cursorUs = 0;\n\n    const rawItems: TimelineTrackItem[] = children.map((child: any, itemIndex: number) => {\n      const item =\n        child?.OTIO_SCHEMA === 'Gap.1'\n          ? parseGapItem({\n              trackId: id,\n              otio: child as OtioGap,\n              index: itemIndex,\n              occupiedIds,\n              fallbackStartUs: cursorUs,\n            })\n          : parseClipItem({\n              trackId: id,\n              otio: child as OtioClip,\n              index: itemIndex,\n              occupiedIds,\n              fallbackStartUs: cursorUs,\n            });\n\n      cursorUs += parseItemSequenceDurationUs(child);\n      return item;\n    });\n\n    const items = [...rawItems].sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n\n    const videoHidden = kind === 'video' ? Boolean(trackGranMeta?.videoHidden) : undefined;\n    const audioMuted = Boolean(trackGranMeta?.audioMuted);\n    const audioSolo = Boolean(trackGranMeta?.audioSolo);\n    const audioGain =\n      typeof trackGranMeta?.audioGain === 'number' && Number.isFinite(trackGranMeta.audioGain)\n        ? Math.max(0, Math.min(10, Number(trackGranMeta.audioGain)))\n        : undefined;\n    const audioBalance =\n      typeof trackGranMeta?.audioBalance === 'number' && Number.isFinite(trackGranMeta.audioBalance)\n        ? Math.max(-1, Math.min(1, Number(trackGranMeta.audioBalance)))\n        : undefined;\n    const effects = Array.isArray(trackGranMeta?.effects)\n      ? (trackGranMeta.effects as any[])\n      : undefined;\n\n    return {\n      id,\n      kind,\n      name,\n      videoHidden,\n      audioMuted,\n      audioSolo,\n      audioGain,\n      audioBalance,\n      effects,\n      items,\n    };\n  });\n\n  const docId = coerceId(granMeta?.docId, fallback.id);\n  const name = coerceName(parsed.name, fallback.name);\n  const markers = coerceMarkers(granMeta?.markers);\n  const playheadUs =\n    typeof granMeta?.playheadUs === 'number' && Number.isFinite(granMeta.playheadUs)\n      ? Math.max(0, Math.round(granMeta.playheadUs))\n      : undefined;\n\n  if (tracks.length === 0) {\n    const base = createDefaultTimelineDocument({ id: docId, name, fps: timebase.fps });\n    base.metadata = {\n      ...(base.metadata ?? {}),\n      gran: {\n        ...(base.metadata?.gran ?? {}),\n        docId,\n        timebase,\n        markers,\n        playheadUs,\n      },\n    };\n    return base;\n  }\n\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: docId,\n    name,\n    timebase,\n    tracks,\n    metadata: {\n      gran: {\n        docId,\n        timebase,\n        markers,\n        playheadUs,\n      },\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/selectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/timeline/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/transitions/core/registry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":61,"messageId":"unexpectedAny","endLine":20,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[788,791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[788,791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":81,"messageId":"unexpectedAny","endLine":26,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1001,1004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1001,1004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":65,"messageId":"unexpectedAny","endLine":30,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1116,1119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1116,1119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type TransitionType = string;\n\nexport interface TransitionManifest<T = Record<string, never>> {\n  type: TransitionType;\n  name: string;\n  icon: string;\n  defaultDurationUs: number;\n  defaultParams: T;\n  /** Returns opacity [0..1] of the outgoing clip at `progress` [0..1] */\n  computeOutOpacity: (progress: number, params: T, curve: 'linear' | 'bezier') => number;\n  /** Returns opacity [0..1] of the incoming clip at `progress` [0..1] */\n  computeInOpacity: (progress: number, params: T, curve: 'linear' | 'bezier') => number;\n}\n\n/** Cubic ease-in-out approximation for bezier transition curve */\nexport function easeInOutCubic(t: number): number {\n  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n}\n\nconst registry = new Map<TransitionType, TransitionManifest<any>>();\n\nexport function registerTransition<T>(manifest: TransitionManifest<T>): void {\n  registry.set(manifest.type, manifest);\n}\n\nexport function getTransitionManifest(type: TransitionType): TransitionManifest<any> | undefined {\n  return registry.get(type);\n}\n\nexport function getAllTransitionManifests(): TransitionManifest<any>[] {\n  return Array.from(registry.values());\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/transitions/dissolve/manifest.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5,"column":18,"messageId":"noEmptyInterface","endLine":5,"endColumn":32,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[187,214],"text":"type DissolveParams = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[187,214],"text":"type DissolveParams = unknown"},"desc":"Replace empty interface with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/transitions/fade-to-black/manifest.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5,"column":18,"messageId":"noEmptyInterface","endLine":5,"endColumn":35,"suggestions":[{"messageId":"replaceEmptyInterface","data":{"replacement":"object"},"fix":{"range":[187,217],"text":"type FadeToBlackParams = object"},"desc":"Replace empty interface with `object`."},{"messageId":"replaceEmptyInterface","data":{"replacement":"unknown"},"fix":{"range":[187,217],"text":"type FadeToBlackParams = unknown"},"desc":"Replace empty interface with `unknown`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/transitions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/types/fs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/types/splitpanes.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/audio/envelope.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/audio/track-bus.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":20,"messageId":"unexpectedAny","endLine":30,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1055,1058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1055,1058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":33,"messageId":"unexpectedAny","endLine":31,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1112,1115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1112,1115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":29,"messageId":"unexpectedAny","endLine":33,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1235,1238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1235,1238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1322,1325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1322,1325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":56,"messageId":"unexpectedAny","endLine":40,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1427,1430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1427,1430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":65,"messageId":"unexpectedAny","endLine":41,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1508,1511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1508,1511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":12,"messageId":"unexpectedAny","endLine":42,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1539,1542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1539,1542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":20,"messageId":"unexpectedAny","endLine":52,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1840,1843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1840,1843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":33,"messageId":"unexpectedAny","endLine":53,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1897,1900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1897,1900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":20,"messageId":"unexpectedAny","endLine":55,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2011,2014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2011,2014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":29,"messageId":"unexpectedAny","endLine":56,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2078,2081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2078,2081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":21,"messageId":"unexpectedAny","endLine":60,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2165,2168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2165,2168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":56,"messageId":"unexpectedAny","endLine":64,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2303,2306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2303,2306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":65,"messageId":"unexpectedAny","endLine":65,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2384,2387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2384,2387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":12,"messageId":"unexpectedAny","endLine":66,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2415,2418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2415,2418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TimelineTrack, TimelineTrackItem } from '~/timeline/types';\nimport { mergeBalance, mergeGain } from '~/utils/audio/envelope';\n\nexport interface BuildEffectiveAudioClipItemsParams {\n  audioTracks: TimelineTrack[];\n  videoTracks: TimelineTrack[];\n}\n\nexport function buildEffectiveAudioClipItems(\n  params: BuildEffectiveAudioClipItemsParams,\n): TimelineTrackItem[] {\n  const allAudioTracks = params.audioTracks;\n  const allVideoTracks = params.videoTracks;\n\n  const hasSolo = [...allAudioTracks, ...allVideoTracks].some((t) => Boolean(t.audioSolo));\n\n  const effectiveAudioTracks = hasSolo\n    ? allAudioTracks.filter((t) => Boolean(t.audioSolo))\n    : allAudioTracks.filter((t) => !t.audioMuted);\n\n  const effectiveVideoTracksForAudio = hasSolo\n    ? allVideoTracks.filter((t) => Boolean(t.audioSolo))\n    : allVideoTracks.filter((t) => !t.audioMuted);\n\n  const result: TimelineTrackItem[] = [];\n\n  for (const track of effectiveAudioTracks) {\n    for (const item of track.items) {\n      if (item.kind !== 'clip') continue;\n      if ((item as any).disabled) continue;\n      const clipType = (item as any).clipType ?? 'media';\n      if (clipType !== 'media' && clipType !== 'timeline') continue;\n      const path = (item as any).source?.path;\n      if (!path) continue;\n\n      result.push({\n        ...(item as any),\n        clipType,\n        source: { path },\n        audioGain: mergeGain(track.audioGain, (item as any).audioGain),\n        audioBalance: mergeBalance(track.audioBalance, (item as any).audioBalance),\n      } as any);\n    }\n  }\n\n  const videoTrackIdsForAudio = new Set(effectiveVideoTracksForAudio.map((t) => t.id));\n  for (const track of allVideoTracks) {\n    if (!videoTrackIdsForAudio.has(track.id)) continue;\n\n    for (const item of track.items) {\n      if (item.kind !== 'clip') continue;\n      if ((item as any).disabled) continue;\n      const clipType = (item as any).clipType ?? 'media';\n      if (clipType !== 'media' && clipType !== 'timeline') continue;\n      if ((item as any).audioFromVideoDisabled) continue;\n      const path = (item as any).source?.path;\n      if (!path) continue;\n\n      result.push({\n        ...(item as any),\n        clipType,\n        id: `${item.id}__audio`,\n        source: { path },\n        audioGain: mergeGain(track.audioGain, (item as any).audioGain),\n        audioBalance: mergeBalance(track.audioBalance, (item as any).audioBalance),\n      } as any);\n    }\n  }\n\n  return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/dev-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/hotkeys/defaultHotkeys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/hotkeys/effectiveHotkeys.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":64,"messageId":"unexpectedAny","endLine":11,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[417,420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[417,420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DEFAULT_HOTKEYS, type HotkeyCommandId, type HotkeyCombo } from './defaultHotkeys';\nimport { normalizeHotkeyCombo } from './hotkeyUtils';\n\nexport interface HotkeysState {\n  bindings: Partial<Record<HotkeyCommandId, HotkeyCombo[]>>;\n}\n\nexport function getEffectiveHotkeyBindings(\n  state: HotkeysState,\n): Record<HotkeyCommandId, HotkeyCombo[]> {\n  const result: Record<HotkeyCommandId, HotkeyCombo[]> = {} as any;\n\n  const normalizeList = (list: HotkeyCombo[]) => {\n    const normalized = list\n      .map((c) => normalizeHotkeyCombo(c))\n      .filter((c): c is HotkeyCombo => Boolean(c));\n    return Array.from(new Set(normalized));\n  };\n\n  for (const cmd of DEFAULT_HOTKEYS.commands) {\n    const override = state.bindings[cmd.id];\n    if (Array.isArray(override)) {\n      result[cmd.id] = normalizeList(override);\n      continue;\n    }\n\n    result[cmd.id] = normalizeList(DEFAULT_HOTKEYS.bindings[cmd.id] ?? []);\n  }\n\n  return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/hotkeys/hotkeyUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/indexedDB.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/monitor-time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/project-settings.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":39,"messageId":"unexpectedAny","endLine":154,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4396,4399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4396,4399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":48,"messageId":"unexpectedAny","endLine":285,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10213,10216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10213,10216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getResolutionPreset, type GranVideoEditorUserSettings } from './settings';\n\nexport interface GranVideoEditorProjectSettings {\n  project: {\n    width: number;\n    height: number;\n    fps: number;\n    resolutionFormat: string;\n    orientation: 'landscape' | 'portrait';\n    aspectRatio: string;\n    isCustomResolution: boolean;\n    audioChannels: 'stereo' | 'mono';\n    sampleRate: number;\n  };\n  exportDefaults: {\n    encoding: {\n      format: 'mp4' | 'webm' | 'mkv';\n      videoCodec: string;\n      bitrateMbps: number;\n      excludeAudio: boolean;\n      audioCodec: 'aac' | 'opus';\n      audioBitrateKbps: number;\n      bitrateMode: 'constant' | 'variable';\n      keyframeIntervalSec: number;\n      exportAlpha: boolean;\n      metadata: {\n        title: string;\n        author: string;\n        tags: string;\n      };\n    };\n  };\n  monitor: {\n    previewResolution: number;\n    useProxy: boolean;\n    panX: number;\n    panY: number;\n  };\n  timelines: {\n    openPaths: string[];\n    lastOpenedPath: string | null;\n  };\n  transitions: {\n    defaultDurationUs: number;\n  };\n}\n\nexport const DEFAULT_PROJECT_SETTINGS: GranVideoEditorProjectSettings = {\n  project: {\n    width: 1920,\n    height: 1080,\n    fps: 25,\n    resolutionFormat: '1080p',\n    orientation: 'landscape',\n    aspectRatio: '16:9',\n    isCustomResolution: false,\n    audioChannels: 'stereo',\n    sampleRate: 48000,\n  },\n  exportDefaults: {\n    encoding: {\n      format: 'mp4',\n      videoCodec: 'avc1.640032',\n      bitrateMbps: 5,\n      excludeAudio: false,\n      audioCodec: 'aac',\n      audioBitrateKbps: 128,\n      bitrateMode: 'variable',\n      keyframeIntervalSec: 2,\n      exportAlpha: false,\n      metadata: {\n        title: '',\n        author: '',\n        tags: '',\n      },\n    },\n  },\n  monitor: {\n    previewResolution: 480,\n    useProxy: true,\n    panX: 0,\n    panY: 0,\n  },\n  timelines: {\n    openPaths: [],\n    lastOpenedPath: null,\n  },\n  transitions: {\n    defaultDurationUs: 2_000_000,\n  },\n};\n\nfunction getProjectSettingsFromUserDefaults(\n  userSettings: Pick<GranVideoEditorUserSettings, 'projectDefaults' | 'exportDefaults'>,\n): Pick<GranVideoEditorProjectSettings, 'project' | 'exportDefaults'> {\n  return {\n    project: {\n      width: userSettings.projectDefaults.width,\n      height: userSettings.projectDefaults.height,\n      fps: userSettings.projectDefaults.fps,\n      resolutionFormat: userSettings.projectDefaults.resolutionFormat,\n      orientation: userSettings.projectDefaults.orientation,\n      aspectRatio: userSettings.projectDefaults.aspectRatio,\n      isCustomResolution: userSettings.projectDefaults.isCustomResolution,\n      audioChannels: userSettings.projectDefaults.audioChannels,\n      sampleRate: userSettings.projectDefaults.sampleRate,\n    },\n    exportDefaults: {\n      encoding: {\n        format: userSettings.exportDefaults.encoding.format,\n        videoCodec: userSettings.exportDefaults.encoding.videoCodec,\n        bitrateMbps: userSettings.exportDefaults.encoding.bitrateMbps,\n        excludeAudio: userSettings.exportDefaults.encoding.excludeAudio,\n        audioCodec: userSettings.exportDefaults.encoding.audioCodec,\n        audioBitrateKbps: userSettings.exportDefaults.encoding.audioBitrateKbps,\n        bitrateMode: userSettings.exportDefaults.encoding.bitrateMode,\n        keyframeIntervalSec: userSettings.exportDefaults.encoding.keyframeIntervalSec,\n        exportAlpha: userSettings.exportDefaults.encoding.exportAlpha,\n        metadata: {\n          title: '',\n          author: '',\n          tags: '',\n        },\n      },\n    },\n  };\n}\n\nexport function createDefaultProjectSettings(\n  userSettings: Pick<GranVideoEditorUserSettings, 'projectDefaults' | 'exportDefaults'>,\n): GranVideoEditorProjectSettings {\n  const base = getProjectSettingsFromUserDefaults(userSettings);\n  return {\n    ...base,\n    monitor: { ...DEFAULT_PROJECT_SETTINGS.monitor },\n    timelines: {\n      openPaths: [],\n      lastOpenedPath: null,\n    },\n    transitions: {\n      defaultDurationUs: DEFAULT_PROJECT_SETTINGS.transitions.defaultDurationUs,\n    },\n  };\n}\n\nexport function normalizeProjectSettings(\n  raw: unknown,\n  userSettings: Pick<GranVideoEditorUserSettings, 'projectDefaults' | 'exportDefaults'>,\n): GranVideoEditorProjectSettings {\n  if (!raw || typeof raw !== 'object') {\n    return createDefaultProjectSettings(userSettings);\n  }\n\n  const input = raw as Record<string, any>;\n\n  const legacyExportInput = input.exportDefaults ?? input.export ?? {};\n  const projectInput = input.project ?? (input.export ? input.export : {}) ?? {};\n  const encodingInput = legacyExportInput?.encoding ?? {};\n\n  const monitorInput = input.monitor ?? {};\n  const transitionsInput = input.transitions ?? {};\n\n  const defaultSettings = createDefaultProjectSettings(userSettings);\n\n  const width = Number(projectInput.width);\n  const height = Number(projectInput.height);\n  const fps = Number(projectInput.fps);\n\n  const bitrateMbps = Number(encodingInput.bitrateMbps);\n  const audioBitrateKbps = Number(encodingInput.audioBitrateKbps);\n  const format = encodingInput.format;\n\n  const audioChannels = projectInput.audioChannels === 'mono' ? 'mono' : 'stereo';\n  const sampleRateRaw = Number(projectInput.sampleRate);\n  const sampleRate =\n    Number.isFinite(sampleRateRaw) && sampleRateRaw > 0\n      ? Math.round(Math.min(192000, Math.max(8000, sampleRateRaw)))\n      : defaultSettings.project.sampleRate;\n\n  const previewResolution = Number(monitorInput.previewResolution);\n  const useProxy = monitorInput.useProxy;\n  const panX = Number(monitorInput.panX);\n  const panY = Number(monitorInput.panY);\n  const defaultTransitionDurationUs = Number(transitionsInput.defaultDurationUs);\n\n  const finalWidth =\n    Number.isFinite(width) && width > 0 ? Math.round(width) : defaultSettings.project.width;\n  const finalHeight =\n    Number.isFinite(height) && height > 0 ? Math.round(height) : defaultSettings.project.height;\n\n  const isWidthHeightCustom =\n    finalWidth !== defaultSettings.project.width || finalHeight !== defaultSettings.project.height;\n\n  const preset = isWidthHeightCustom\n    ? getResolutionPreset(finalWidth, finalHeight)\n    : {\n        resolutionFormat: projectInput.resolutionFormat || defaultSettings.project.resolutionFormat,\n        orientation: projectInput.orientation || defaultSettings.project.orientation,\n        aspectRatio: projectInput.aspectRatio || defaultSettings.project.aspectRatio,\n        isCustomResolution:\n          projectInput.isCustomResolution !== undefined\n            ? projectInput.isCustomResolution\n            : defaultSettings.project.isCustomResolution,\n      };\n\n  return {\n    project: {\n      width: finalWidth,\n      height: finalHeight,\n      fps:\n        Number.isFinite(fps) && fps > 0\n          ? Math.round(Math.min(240, Math.max(1, fps)))\n          : defaultSettings.project.fps,\n      resolutionFormat:\n        typeof projectInput.resolutionFormat === 'string' &&\n        projectInput.resolutionFormat &&\n        !isWidthHeightCustom\n          ? projectInput.resolutionFormat\n          : preset.resolutionFormat,\n      orientation:\n        (projectInput.orientation === 'portrait' || projectInput.orientation === 'landscape') &&\n        !isWidthHeightCustom\n          ? projectInput.orientation\n          : (preset.orientation as 'landscape' | 'portrait'),\n      aspectRatio:\n        typeof projectInput.aspectRatio === 'string' &&\n        projectInput.aspectRatio &&\n        !isWidthHeightCustom\n          ? projectInput.aspectRatio\n          : preset.aspectRatio,\n      isCustomResolution:\n        projectInput.isCustomResolution !== undefined && !isWidthHeightCustom\n          ? Boolean(projectInput.isCustomResolution)\n          : preset.isCustomResolution,\n      audioChannels,\n      sampleRate,\n    },\n    exportDefaults: {\n      encoding: {\n        format: format === 'webm' || format === 'mkv' ? format : 'mp4',\n        videoCodec:\n          typeof encodingInput.videoCodec === 'string' && encodingInput.videoCodec.trim().length > 0\n            ? encodingInput.videoCodec\n            : DEFAULT_PROJECT_SETTINGS.exportDefaults.encoding.videoCodec,\n        bitrateMbps:\n          Number.isFinite(bitrateMbps) && bitrateMbps > 0\n            ? Math.min(200, Math.max(0.2, bitrateMbps))\n            : DEFAULT_PROJECT_SETTINGS.exportDefaults.encoding.bitrateMbps,\n        excludeAudio: Boolean(encodingInput.excludeAudio),\n        audioCodec: encodingInput.audioCodec === 'opus' ? 'opus' : 'aac',\n        audioBitrateKbps:\n          Number.isFinite(audioBitrateKbps) && audioBitrateKbps > 0\n            ? Math.round(Math.min(1024, Math.max(32, audioBitrateKbps)))\n            : DEFAULT_PROJECT_SETTINGS.exportDefaults.encoding.audioBitrateKbps,\n        bitrateMode: encodingInput.bitrateMode === 'constant' ? 'constant' : 'variable',\n        keyframeIntervalSec: (() => {\n          const v = Number(encodingInput.keyframeIntervalSec);\n          if (!Number.isFinite(v) || v <= 0) {\n            return DEFAULT_PROJECT_SETTINGS.exportDefaults.encoding.keyframeIntervalSec;\n          }\n          return Math.round(Math.min(60, Math.max(1, v)));\n        })(),\n        exportAlpha: Boolean(encodingInput.exportAlpha),\n        metadata: {\n          title:\n            typeof encodingInput.metadata?.title === 'string' ? encodingInput.metadata.title : '',\n          author:\n            typeof encodingInput.metadata?.author === 'string' ? encodingInput.metadata.author : '',\n          tags: typeof encodingInput.metadata?.tags === 'string' ? encodingInput.metadata.tags : '',\n        },\n      },\n    },\n    monitor: {\n      previewResolution:\n        Number.isFinite(previewResolution) && previewResolution > 0\n          ? Math.round(Math.min(4320, Math.max(1, previewResolution)))\n          : DEFAULT_PROJECT_SETTINGS.monitor.previewResolution,\n      useProxy:\n        useProxy === undefined ? DEFAULT_PROJECT_SETTINGS.monitor.useProxy : Boolean(useProxy),\n      panX: Number.isFinite(panX) ? panX : DEFAULT_PROJECT_SETTINGS.monitor.panX,\n      panY: Number.isFinite(panY) ? panY : DEFAULT_PROJECT_SETTINGS.monitor.panY,\n    },\n    timelines: {\n      openPaths: Array.isArray(input.timelines?.openPaths)\n        ? input.timelines.openPaths.filter((p: any) => typeof p === 'string')\n        : [],\n      lastOpenedPath:\n        typeof input.timelines?.lastOpenedPath === 'string' ? input.timelines.lastOpenedPath : null,\n    },\n    transitions: {\n      defaultDurationUs:\n        Number.isFinite(defaultTransitionDurationUs) && defaultTransitionDurationUs > 0\n          ? Math.round(defaultTransitionDurationUs)\n          : defaultSettings.transitions.defaultDurationUs,\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/settings.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":39,"messageId":"unexpectedAny","endLine":217,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6359,6362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6359,6362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":39,"messageId":"unexpectedAny","endLine":252,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7617,7620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7617,7620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":28,"messageId":"unexpectedAny","endLine":346,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11730,11733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11730,11733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":38,"messageId":"unexpectedAny","endLine":353,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12017,12020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12017,12020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":40,"messageId":"unexpectedAny","endLine":364,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12450,12453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12450,12453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":37,"messageId":"unexpectedAny","endLine":374,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12744,12747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12744,12747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":39,"messageId":"unexpectedAny","endLine":379,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13052,13055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13052,13055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":477,"column":39,"messageId":"unexpectedAny","endLine":477,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16895,16898],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16895,16898],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { STORAGE_LIMITS } from './constants';\nimport { DEFAULT_HOTKEYS, type HotkeyCommandId, type HotkeyCombo } from './hotkeys/defaultHotkeys';\nimport { normalizeHotkeyCombo } from './hotkeys/hotkeyUtils';\n\nexport interface GranVideoEditorUserSettings {\n  locale: 'en-US' | 'ru-RU';\n  openLastProjectOnStart: boolean;\n  stopFrames: {\n    qualityPercent: number;\n  };\n  hotkeys: {\n    bindings: Partial<Record<HotkeyCommandId, HotkeyCombo[]>>;\n  };\n  optimization: {\n    proxyResolution: '360p' | '480p' | '720p' | '1080p';\n    proxyVideoBitrateMbps: number;\n    proxyAudioBitrateKbps: number;\n    proxyCopyOpusAudio: boolean;\n    autoCreateProxies: boolean;\n    proxyConcurrency: number;\n  };\n  projectDefaults: {\n    width: number;\n    height: number;\n    fps: number;\n    resolutionFormat: string;\n    orientation: 'landscape' | 'portrait';\n    aspectRatio: string;\n    isCustomResolution: boolean;\n    audioChannels: 'stereo' | 'mono';\n    sampleRate: number;\n  };\n  exportDefaults: {\n    encoding: {\n      format: 'mp4' | 'webm' | 'mkv';\n      videoCodec: string;\n      bitrateMbps: number;\n      excludeAudio: boolean;\n      audioCodec: 'aac' | 'opus';\n      audioBitrateKbps: number;\n      bitrateMode: 'constant' | 'variable';\n      keyframeIntervalSec: number;\n      exportAlpha: boolean;\n    };\n  };\n  mouse: {\n    timeline: {\n      wheel: 'scroll_vertical' | 'scroll_horizontal' | 'zoom_horizontal' | 'zoom_vertical' | 'none';\n      wheelShift:\n        | 'scroll_vertical'\n        | 'scroll_horizontal'\n        | 'zoom_horizontal'\n        | 'zoom_vertical'\n        | 'none';\n      wheelSecondary:\n        | 'scroll_vertical'\n        | 'scroll_horizontal'\n        | 'zoom_horizontal'\n        | 'zoom_vertical'\n        | 'none';\n      wheelSecondaryShift:\n        | 'scroll_vertical'\n        | 'scroll_horizontal'\n        | 'zoom_horizontal'\n        | 'zoom_vertical'\n        | 'none';\n      middleClick: 'pan' | 'none';\n    };\n    monitor: {\n      wheel: 'zoom' | 'scroll_vertical' | 'scroll_horizontal' | 'none';\n      wheelShift: 'zoom' | 'scroll_vertical' | 'scroll_horizontal' | 'none';\n      middleClick: 'pan' | 'none';\n    };\n  };\n}\n\nexport interface GranVideoEditorWorkspaceSettings {\n  proxyStorageLimitBytes: number;\n  cacheStorageLimitBytes: number;\n  thumbnailsStorageLimitBytes: number;\n}\n\nexport const DEFAULT_USER_SETTINGS: GranVideoEditorUserSettings = {\n  locale: 'en-US',\n  openLastProjectOnStart: true,\n  stopFrames: {\n    qualityPercent: 85,\n  },\n  hotkeys: {\n    bindings: {},\n  },\n  optimization: {\n    proxyResolution: '720p',\n    proxyVideoBitrateMbps: 2,\n    proxyAudioBitrateKbps: 128,\n    proxyCopyOpusAudio: true,\n    autoCreateProxies: true,\n    proxyConcurrency: 2,\n  },\n  projectDefaults: {\n    width: 1920,\n    height: 1080,\n    fps: 25,\n    resolutionFormat: '1080p',\n    orientation: 'landscape',\n    aspectRatio: '16:9',\n    isCustomResolution: false,\n    audioChannels: 'stereo',\n    sampleRate: 48000,\n  },\n  exportDefaults: {\n    encoding: {\n      format: 'mp4',\n      videoCodec: 'avc1.640032',\n      bitrateMbps: 5,\n      excludeAudio: false,\n      audioCodec: 'aac',\n      audioBitrateKbps: 128,\n      bitrateMode: 'variable',\n      keyframeIntervalSec: 2,\n      exportAlpha: false,\n    },\n  },\n  mouse: {\n    timeline: {\n      wheel: 'scroll_vertical',\n      wheelShift: 'scroll_horizontal',\n      wheelSecondary: 'scroll_horizontal',\n      wheelSecondaryShift: 'zoom_vertical',\n      middleClick: 'pan',\n    },\n    monitor: {\n      wheel: 'zoom',\n      wheelShift: 'scroll_horizontal',\n      middleClick: 'pan',\n    },\n  },\n};\n\nexport const DEFAULT_WORKSPACE_SETTINGS: GranVideoEditorWorkspaceSettings = {\n  proxyStorageLimitBytes: STORAGE_LIMITS.PROXY_BYTES,\n  cacheStorageLimitBytes: STORAGE_LIMITS.CACHE_BYTES,\n  thumbnailsStorageLimitBytes: STORAGE_LIMITS.THUMBNAILS_BYTES,\n};\n\nexport function getResolutionPreset(width: number, height: number) {\n  const isPortrait = height > width;\n  const w = isPortrait ? height : width;\n  const h = isPortrait ? width : height;\n\n  let format = '';\n  if (w === 1280 && h === 720) format = '720p';\n  else if (w === 1920 && h === 1080) format = '1080p';\n  else if (w === 2560 && h === 1440) format = '2.7k';\n  else if (w === 3840 && h === 2160) format = '4k';\n\n  let aspectRatio = '16:9';\n  if (Math.abs(w / h - 16 / 9) < 0.01) aspectRatio = '16:9';\n  else if (Math.abs(w / h - 4 / 3) < 0.01) aspectRatio = '4:3';\n  else if (Math.abs(w / h - 1) < 0.01) aspectRatio = '1:1';\n  else if (Math.abs(w / h - 21 / 9) < 0.01) aspectRatio = '21:9';\n\n  return {\n    isCustomResolution: !format,\n    resolutionFormat: format || '1080p',\n    orientation: isPortrait ? 'portrait' : 'landscape',\n    aspectRatio,\n  };\n}\n\nexport function createDefaultProjectDefaults(): GranVideoEditorUserSettings['projectDefaults'] {\n  const preset = getResolutionPreset(\n    DEFAULT_USER_SETTINGS.projectDefaults.width,\n    DEFAULT_USER_SETTINGS.projectDefaults.height,\n  );\n\n  return {\n    width: DEFAULT_USER_SETTINGS.projectDefaults.width,\n    height: DEFAULT_USER_SETTINGS.projectDefaults.height,\n    fps: DEFAULT_USER_SETTINGS.projectDefaults.fps,\n    resolutionFormat: preset.resolutionFormat,\n    orientation: preset.orientation as 'landscape' | 'portrait',\n    aspectRatio: preset.aspectRatio,\n    isCustomResolution: preset.isCustomResolution,\n    audioChannels: DEFAULT_USER_SETTINGS.projectDefaults.audioChannels,\n    sampleRate: DEFAULT_USER_SETTINGS.projectDefaults.sampleRate,\n  };\n}\n\nexport function createDefaultUserSettings(): GranVideoEditorUserSettings {\n  return {\n    locale: DEFAULT_USER_SETTINGS.locale,\n    openLastProjectOnStart: DEFAULT_USER_SETTINGS.openLastProjectOnStart,\n    stopFrames: {\n      qualityPercent: DEFAULT_USER_SETTINGS.stopFrames.qualityPercent,\n    },\n    hotkeys: {\n      bindings: {},\n    },\n    optimization: { ...DEFAULT_USER_SETTINGS.optimization },\n    projectDefaults: createDefaultProjectDefaults(),\n    exportDefaults: {\n      encoding: { ...DEFAULT_USER_SETTINGS.exportDefaults.encoding },\n    },\n    mouse: {\n      timeline: { ...DEFAULT_USER_SETTINGS.mouse.timeline },\n      monitor: { ...DEFAULT_USER_SETTINGS.mouse.monitor },\n    },\n  };\n}\n\nfunction normalizeHotkeys(raw: unknown): GranVideoEditorUserSettings['hotkeys'] {\n  if (!raw || typeof raw !== 'object') {\n    return { bindings: {} };\n  }\n\n  const input = raw as Record<string, any>;\n  const bindingsInput = input.bindings;\n  if (!bindingsInput || typeof bindingsInput !== 'object') {\n    return { bindings: {} };\n  }\n\n  const normalizedBindings: Partial<Record<HotkeyCommandId, HotkeyCombo[]>> = {};\n  const allowedCommands = new Set<HotkeyCommandId>(DEFAULT_HOTKEYS.commands.map((c) => c.id));\n\n  for (const [cmdIdRaw, combosRaw] of Object.entries(bindingsInput)) {\n    const cmdId = cmdIdRaw as HotkeyCommandId;\n    if (!allowedCommands.has(cmdId)) continue;\n\n    const combos = Array.isArray(combosRaw) ? combosRaw : [];\n    const normalizedCombos = combos\n      .filter((c): c is string => typeof c === 'string')\n      .map((c) => normalizeHotkeyCombo(c))\n      .filter((c): c is string => Boolean(c));\n\n    if (normalizedCombos.length > 0) {\n      normalizedBindings[cmdId] = Array.from(new Set(normalizedCombos));\n    } else if (Array.isArray(combosRaw)) {\n      // Preserve explicit empty arrays to allow disabling a command.\n      normalizedBindings[cmdId] = [];\n    }\n  }\n\n  return { bindings: normalizedBindings };\n}\n\nexport function normalizeUserSettings(raw: unknown): GranVideoEditorUserSettings {\n  if (!raw || typeof raw !== 'object') {\n    return createDefaultUserSettings();\n  }\n\n  const input = raw as Record<string, any>;\n\n  const localeRaw = input.locale ?? input.language ?? input.lang;\n  const normalizedLocale =\n    localeRaw === 'ru-RU' || localeRaw === 'ru'\n      ? 'ru-RU'\n      : localeRaw === 'en-US' || localeRaw === 'en'\n        ? 'en-US'\n        : DEFAULT_USER_SETTINGS.locale;\n\n  // Migration: if we have resolution/fps in exportDefaults/export, move them to projectDefaults\n  const legacyExportInput = input.exportDefaults ?? input.export ?? null;\n  const projectInput = input.projectDefaults ?? legacyExportInput ?? {};\n  const exportEncodingInput = input.exportDefaults?.encoding ?? legacyExportInput?.encoding ?? {};\n\n  const width = Number(projectInput?.width);\n  const height = Number(projectInput?.height);\n  const fps = Number(projectInput?.fps);\n  const bitrateMbps = Number(exportEncodingInput?.bitrateMbps);\n  const audioBitrateKbps = Number(exportEncodingInput?.audioBitrateKbps);\n  const format = exportEncodingInput?.format;\n  const keyframeIntervalSecRaw = Number(exportEncodingInput?.keyframeIntervalSec);\n\n  const normalizedWidth =\n    Number.isFinite(width) && width > 0\n      ? Math.round(width)\n      : DEFAULT_USER_SETTINGS.projectDefaults.width;\n  const normalizedHeight =\n    Number.isFinite(height) && height > 0\n      ? Math.round(height)\n      : DEFAULT_USER_SETTINGS.projectDefaults.height;\n\n  const preset = getResolutionPreset(normalizedWidth, normalizedHeight);\n  const isWidthHeightCustom =\n    normalizedWidth !== DEFAULT_USER_SETTINGS.projectDefaults.width ||\n    normalizedHeight !== DEFAULT_USER_SETTINGS.projectDefaults.height;\n\n  const resolutionFormat =\n    typeof projectInput?.resolutionFormat === 'string' &&\n    projectInput.resolutionFormat &&\n    !isWidthHeightCustom\n      ? projectInput.resolutionFormat\n      : preset.resolutionFormat;\n  const orientation =\n    (projectInput?.orientation === 'portrait' || projectInput?.orientation === 'landscape') &&\n    !isWidthHeightCustom\n      ? projectInput.orientation\n      : (preset.orientation as 'landscape' | 'portrait');\n  const aspectRatio =\n    typeof projectInput?.aspectRatio === 'string' &&\n    projectInput.aspectRatio &&\n    !isWidthHeightCustom\n      ? projectInput.aspectRatio\n      : preset.aspectRatio;\n  const isCustomResolution =\n    projectInput?.isCustomResolution !== undefined && !isWidthHeightCustom\n      ? Boolean(projectInput.isCustomResolution)\n      : preset.isCustomResolution;\n\n  const audioChannels = projectInput?.audioChannels === 'mono' ? 'mono' : 'stereo';\n  const sampleRateRaw = Number(projectInput?.sampleRate);\n  const sampleRate =\n    Number.isFinite(sampleRateRaw) && sampleRateRaw > 0\n      ? Math.round(Math.min(192000, Math.max(8000, sampleRateRaw)))\n      : DEFAULT_USER_SETTINGS.projectDefaults.sampleRate;\n\n  const openLastProjectOnStartRaw = input.openLastProjectOnStart;\n  const openBehavior = input.openBehavior;\n  const openLastProjectOnStart =\n    typeof openLastProjectOnStartRaw === 'boolean'\n      ? openLastProjectOnStartRaw\n      : openBehavior === 'show_project_picker'\n        ? false\n        : DEFAULT_USER_SETTINGS.openLastProjectOnStart;\n\n  const stopFramesInput = input.stopFrames ?? {};\n  const qualityPercentRaw =\n    stopFramesInput?.qualityPercent ?? input.stopFrameQualityPercent ?? input.stopFramesQuality;\n  const qualityPercentParsed = Number(qualityPercentRaw);\n  const stopFramesQualityPercent =\n    Number.isFinite(qualityPercentParsed) && qualityPercentParsed > 0\n      ? Math.round(Math.min(100, Math.max(1, qualityPercentParsed)))\n      : DEFAULT_USER_SETTINGS.stopFrames.qualityPercent;\n\n  const optimizationInput = input.optimization ?? {};\n  const proxyResolution = optimizationInput.proxyResolution;\n  const proxyVideoBitrateMbps = Number(optimizationInput.proxyVideoBitrateMbps);\n  const proxyAudioBitrateKbps = Number(optimizationInput.proxyAudioBitrateKbps);\n  const proxyCopyOpusAudio = optimizationInput.proxyCopyOpusAudio;\n  const autoCreateProxies = optimizationInput.autoCreateProxies;\n  const proxyConcurrency = Number(optimizationInput.proxyConcurrency);\n\n  const hotkeys = normalizeHotkeys(input.hotkeys);\n\n  const rawMouse = (raw as any).mouse;\n  const normalizedMouse: GranVideoEditorUserSettings['mouse'] = {\n    timeline: { ...DEFAULT_USER_SETTINGS.mouse.timeline },\n    monitor: { ...DEFAULT_USER_SETTINGS.mouse.monitor },\n  };\n\n  if (rawMouse && typeof rawMouse === 'object') {\n    const rawTimeline = (rawMouse as any).timeline;\n    if (rawTimeline && typeof rawTimeline === 'object') {\n      const validTimelineActions = [\n        'scroll_vertical',\n        'scroll_horizontal',\n        'zoom_horizontal',\n        'zoom_vertical',\n        'none',\n      ];\n      for (const k of ['wheel', 'wheelShift', 'wheelSecondary', 'wheelSecondaryShift']) {\n        if (validTimelineActions.includes(rawTimeline[k])) {\n          (normalizedMouse.timeline as any)[k] = rawTimeline[k];\n        }\n      }\n\n      const validMiddleClickActions = ['pan', 'none'];\n      if (validMiddleClickActions.includes(rawTimeline.middleClick)) {\n        normalizedMouse.timeline.middleClick = rawTimeline.middleClick;\n      }\n    }\n\n    const rawMonitor = (rawMouse as any).monitor;\n    if (rawMonitor && typeof rawMonitor === 'object') {\n      const validMonitorActions = ['zoom', 'scroll_vertical', 'scroll_horizontal', 'none'];\n      for (const k of ['wheel', 'wheelShift']) {\n        if (validMonitorActions.includes(rawMonitor[k])) {\n          (normalizedMouse.monitor as any)[k] = rawMonitor[k];\n        }\n      }\n\n      const validMiddleClickActions = ['pan', 'none'];\n      if (validMiddleClickActions.includes(rawMonitor.middleClick)) {\n        normalizedMouse.monitor.middleClick = rawMonitor.middleClick;\n      }\n    }\n  }\n\n  return {\n    locale: normalizedLocale,\n    openLastProjectOnStart,\n    stopFrames: {\n      qualityPercent: stopFramesQualityPercent,\n    },\n    hotkeys,\n    optimization: {\n      proxyResolution: ['360p', '480p', '720p', '1080p'].includes(proxyResolution)\n        ? proxyResolution\n        : DEFAULT_USER_SETTINGS.optimization.proxyResolution,\n      proxyVideoBitrateMbps:\n        Number.isFinite(proxyVideoBitrateMbps) && proxyVideoBitrateMbps > 0\n          ? Math.min(50, Math.max(0.1, proxyVideoBitrateMbps))\n          : DEFAULT_USER_SETTINGS.optimization.proxyVideoBitrateMbps,\n      proxyAudioBitrateKbps:\n        Number.isFinite(proxyAudioBitrateKbps) && proxyAudioBitrateKbps > 0\n          ? Math.min(512, Math.max(32, proxyAudioBitrateKbps))\n          : DEFAULT_USER_SETTINGS.optimization.proxyAudioBitrateKbps,\n      proxyCopyOpusAudio:\n        typeof proxyCopyOpusAudio === 'boolean'\n          ? proxyCopyOpusAudio\n          : DEFAULT_USER_SETTINGS.optimization.proxyCopyOpusAudio,\n      autoCreateProxies:\n        typeof autoCreateProxies === 'boolean'\n          ? autoCreateProxies\n          : DEFAULT_USER_SETTINGS.optimization.autoCreateProxies,\n      proxyConcurrency:\n        Number.isFinite(proxyConcurrency) && proxyConcurrency > 0\n          ? Math.min(16, Math.max(1, Math.round(proxyConcurrency)))\n          : DEFAULT_USER_SETTINGS.optimization.proxyConcurrency,\n    },\n    projectDefaults: {\n      width: normalizedWidth,\n      height: normalizedHeight,\n      fps:\n        Number.isFinite(fps) && fps > 0\n          ? Math.round(Math.min(240, Math.max(1, fps)))\n          : DEFAULT_USER_SETTINGS.projectDefaults.fps,\n      resolutionFormat,\n      orientation,\n      aspectRatio,\n      isCustomResolution,\n      audioChannels,\n      sampleRate,\n    },\n    exportDefaults: {\n      encoding: {\n        format: format === 'webm' || format === 'mkv' ? format : 'mp4',\n        videoCodec:\n          typeof exportEncodingInput?.videoCodec === 'string' &&\n          exportEncodingInput.videoCodec.trim().length > 0\n            ? exportEncodingInput.videoCodec\n            : DEFAULT_USER_SETTINGS.exportDefaults.encoding.videoCodec,\n        bitrateMbps:\n          Number.isFinite(bitrateMbps) && bitrateMbps > 0\n            ? Math.min(200, Math.max(0.2, bitrateMbps))\n            : DEFAULT_USER_SETTINGS.exportDefaults.encoding.bitrateMbps,\n        excludeAudio: Boolean(exportEncodingInput?.excludeAudio),\n        audioCodec: exportEncodingInput?.audioCodec === 'opus' ? 'opus' : 'aac',\n        audioBitrateKbps:\n          Number.isFinite(audioBitrateKbps) && audioBitrateKbps > 0\n            ? Math.round(Math.min(1024, Math.max(32, audioBitrateKbps)))\n            : DEFAULT_USER_SETTINGS.exportDefaults.encoding.audioBitrateKbps,\n        bitrateMode: exportEncodingInput?.bitrateMode === 'constant' ? 'constant' : 'variable',\n        keyframeIntervalSec:\n          Number.isFinite(keyframeIntervalSecRaw) && keyframeIntervalSecRaw > 0\n            ? Math.round(Math.min(60, Math.max(1, keyframeIntervalSecRaw)))\n            : DEFAULT_USER_SETTINGS.exportDefaults.encoding.keyframeIntervalSec,\n        exportAlpha: Boolean(exportEncodingInput?.exportAlpha),\n      },\n    },\n    mouse: normalizedMouse,\n  };\n}\n\nexport function createDefaultWorkspaceSettings(): GranVideoEditorWorkspaceSettings {\n  return {\n    ...DEFAULT_WORKSPACE_SETTINGS,\n  };\n}\n\nexport function normalizeWorkspaceSettings(raw: unknown): GranVideoEditorWorkspaceSettings {\n  if (!raw || typeof raw !== 'object') {\n    return createDefaultWorkspaceSettings();\n  }\n\n  const input = raw as Record<string, any>;\n\n  const proxyStorageLimitBytes = Number(input.proxyStorageLimitBytes);\n  const cacheStorageLimitBytes = Number(input.cacheStorageLimitBytes);\n  const thumbnailsStorageLimitBytes = Number(input.thumbnailsStorageLimitBytes);\n\n  const MAX_LIMIT_BYTES = 1024 * 1024 * 1024 * 1024;\n\n  return {\n    proxyStorageLimitBytes:\n      Number.isFinite(proxyStorageLimitBytes) && proxyStorageLimitBytes > 0\n        ? Math.round(Math.min(MAX_LIMIT_BYTES, proxyStorageLimitBytes))\n        : DEFAULT_WORKSPACE_SETTINGS.proxyStorageLimitBytes,\n    cacheStorageLimitBytes:\n      Number.isFinite(cacheStorageLimitBytes) && cacheStorageLimitBytes > 0\n        ? Math.round(Math.min(MAX_LIMIT_BYTES, cacheStorageLimitBytes))\n        : DEFAULT_WORKSPACE_SETTINGS.cacheStorageLimitBytes,\n    thumbnailsStorageLimitBytes:\n      Number.isFinite(thumbnailsStorageLimitBytes) && thumbnailsStorageLimitBytes > 0\n        ? Math.round(Math.min(MAX_LIMIT_BYTES, thumbnailsStorageLimitBytes))\n        : DEFAULT_WORKSPACE_SETTINGS.thumbnailsStorageLimitBytes,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/stop-frames.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":13,"messageId":"unexpectedAny","endLine":75,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2414,2417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2414,2417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { usToFrame, sanitizeFps } from '~/timeline/commands/utils';\n\nfunction sanitizeBaseName(name: string): string {\n  return name\n    .replace(/\\.[^.]+$/, '')\n    .replace(/[^a-zA-Z0-9._-]+/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_+|_+$/g, '');\n}\n\nexport interface FormatStopFrameTimecodeParams {\n  timeUs: number;\n  fps: number;\n}\n\nexport function formatStopFrameTimecode(params: FormatStopFrameTimecodeParams): string {\n  const fps = sanitizeFps(params.fps);\n  const frames = usToFrame(params.timeUs, fps, 'round');\n\n  const framesPerHour = fps * 3600;\n  const framesPerMinute = fps * 60;\n\n  const hh = Math.floor(frames / framesPerHour);\n  const mm = Math.floor((frames % framesPerHour) / framesPerMinute);\n  const ss = Math.floor((frames % framesPerMinute) / fps);\n  const ff = frames % fps;\n\n  return `${String(hh).padStart(2, '0')}-${String(mm).padStart(2, '0')}-${String(ss).padStart(2, '0')}-${String(ff).padStart(2, '0')}`;\n}\n\nexport interface BuildStopFrameBaseNameParams {\n  timelineName: string;\n  timeUs: number;\n  fps: number;\n}\n\nexport function buildStopFrameBaseName(params: BuildStopFrameBaseNameParams): string {\n  const safeTimeline = sanitizeBaseName(params.timelineName || 'timeline') || 'timeline';\n  const tc = formatStopFrameTimecode({ timeUs: params.timeUs, fps: params.fps });\n  return `${safeTimeline}_${tc}`;\n}\n\nexport interface RenderExportFrameBlobParams {\n  sourceCanvas: HTMLCanvasElement;\n  exportWidth: number;\n  exportHeight: number;\n  quality: number;\n  mimeType?: string;\n  createCanvas?: () => HTMLCanvasElement;\n}\n\nexport async function renderExportFrameBlob(params: RenderExportFrameBlobParams): Promise<Blob> {\n  const width = Math.round(Number(params.exportWidth) || 0);\n  const height = Math.round(Number(params.exportHeight) || 0);\n  if (!Number.isFinite(width) || width <= 0 || !Number.isFinite(height) || height <= 0) {\n    throw new Error('Invalid export resolution');\n  }\n\n  const quality = Math.max(0.01, Math.min(1, Number(params.quality) || 0.85));\n  const mimeType = params.mimeType || 'image/webp';\n\n  const targetCanvas = params.createCanvas\n    ? params.createCanvas()\n    : document.createElement('canvas');\n  targetCanvas.width = width;\n  targetCanvas.height = height;\n\n  const ctx = targetCanvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Canvas context is not available');\n  }\n\n  ctx.imageSmoothingEnabled = true;\n  try {\n    (ctx as any).imageSmoothingQuality = 'high';\n  } catch {\n    // ignore if not supported\n  }\n\n  ctx.drawImage(params.sourceCanvas, 0, 0, width, height);\n\n  return await new Promise<Blob>((resolve, reject) => {\n    targetCanvas.toBlob(\n      (blob) => {\n        if (!blob) {\n          reject(new Error('Failed to create snapshot blob'));\n          return;\n        }\n        resolve(blob);\n      },\n      mimeType,\n      quality,\n    );\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/svg.ts","messages":[{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":39,"column":51,"messageId":"unnecessaryEscape","endLine":39,"endColumn":52,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1119,1120],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1119,1119],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":39,"column":58,"messageId":"unnecessaryEscape","endLine":39,"endColumn":59,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1126,1127],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1126,1126],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":39,"column":65,"messageId":"unnecessaryEscape","endLine":39,"endColumn":66,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1133,1134],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1133,1133],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":40,"column":53,"messageId":"unnecessaryEscape","endLine":40,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1212,1213],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1212,1212],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":40,"column":60,"messageId":"unnecessaryEscape","endLine":40,"endColumn":61,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1219,1220],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1219,1219],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":40,"column":67,"messageId":"unnecessaryEscape","endLine":40,"endColumn":68,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1226,1227],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1226,1226],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":43,"column":42,"messageId":"unnecessaryEscape","endLine":43,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1344,1345],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1344,1344],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":43,"column":49,"messageId":"unnecessaryEscape","endLine":43,"endColumn":50,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1351,1352],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1351,1351],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":1,"message":"Unnecessary escape character: \\\".","line":43,"column":56,"messageId":"unnecessaryEscape","endLine":43,"endColumn":57,"suggestions":[{"messageId":"removeEscape","fix":{"range":[1358,1359],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[1358,1358],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface SvgDimensions {\n  width: number;\n  height: number;\n}\n\nexport interface SvgRasterizeOptions {\n  maxWidth?: number;\n  maxHeight?: number;\n}\n\nexport function parseSvgDimensions(svgText: string): SvgDimensions {\n  const fallback: SvgDimensions = { width: 800, height: 600 };\n  if (typeof svgText !== 'string' || svgText.length === 0) return fallback;\n\n  try {\n    if (typeof DOMParser !== 'undefined') {\n      const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');\n      const svgEl = doc.querySelector('svg');\n      if (!svgEl) return fallback;\n\n      const widthAttr = svgEl.getAttribute('width');\n      const heightAttr = svgEl.getAttribute('height');\n      const viewBoxAttr = svgEl.getAttribute('viewBox');\n\n      const width = parseSvgLengthPx(widthAttr);\n      const height = parseSvgLengthPx(heightAttr);\n      if (width && height) return { width, height };\n\n      const vb = parseViewBox(viewBoxAttr);\n      if (vb) return vb;\n\n      return fallback;\n    }\n  } catch {\n    // ignore\n  }\n\n  // Regex fallback (non-DOM environments)\n  const width = parseSvgLengthPx(/\\bwidth\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/i.exec(svgText)?.[1]);\n  const height = parseSvgLengthPx(/\\bheight\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/i.exec(svgText)?.[1]);\n  if (width && height) return { width, height };\n\n  const viewBoxAttr = /\\bviewBox\\s*=\\s*['\\\"]([^'\\\"]+)['\\\"]/i.exec(svgText)?.[1];\n  return parseViewBox(viewBoxAttr) ?? fallback;\n}\n\nexport function computeSvgRasterSize(params: {\n  intrinsic: SvgDimensions;\n  maxWidth?: number;\n  maxHeight?: number;\n}): SvgDimensions {\n  const { intrinsic, maxWidth, maxHeight } = params;\n\n  const MAX_DIMENSION = 8192;\n\n  const w0 = Math.max(1, Number(intrinsic.width) || 1);\n  const h0 = Math.max(1, Number(intrinsic.height) || 1);\n\n  const mw =\n    Number.isFinite(Number(maxWidth)) && Number(maxWidth) > 0\n      ? Math.min(MAX_DIMENSION, Math.max(1, Math.round(Number(maxWidth))))\n      : undefined;\n  const mh =\n    Number.isFinite(Number(maxHeight)) && Number(maxHeight) > 0\n      ? Math.min(MAX_DIMENSION, Math.max(1, Math.round(Number(maxHeight))))\n      : undefined;\n\n  if (!mw && !mh) {\n    return {\n      width: Math.min(MAX_DIMENSION, Math.round(w0)),\n      height: Math.min(MAX_DIMENSION, Math.round(h0)),\n    };\n  }\n\n  const scaleW = mw ? mw / w0 : Number.POSITIVE_INFINITY;\n  const scaleH = mh ? mh / h0 : Number.POSITIVE_INFINITY;\n  const scale = Math.max(1e-6, Math.min(scaleW, scaleH));\n\n  const width = Math.min(MAX_DIMENSION, Math.max(1, Math.round(w0 * scale)));\n  const height = Math.min(MAX_DIMENSION, Math.max(1, Math.round(h0 * scale)));\n  return { width, height };\n}\n\nfunction parseSvgLengthPx(value: string | null | undefined): number | null {\n  if (!value) return null;\n  const trimmed = value.trim();\n  if (trimmed.length === 0) return null;\n\n  // Support plain numbers, px and common absolute units.\n  const match = /^(-?\\d*\\.?\\d+)(px|pt|pc|mm|cm|in)?$/i.exec(trimmed);\n  if (!match) return null;\n  const raw = Number(match[1]);\n  if (!Number.isFinite(raw) || raw <= 0) return null;\n\n  const unit = (match[2] ?? 'px').toLowerCase();\n  const pxPerIn = 96;\n  switch (unit) {\n    case 'px':\n      return raw;\n    case 'in':\n      return raw * pxPerIn;\n    case 'cm':\n      return (raw * pxPerIn) / 2.54;\n    case 'mm':\n      return (raw * pxPerIn) / 25.4;\n    case 'pt':\n      return (raw * pxPerIn) / 72;\n    case 'pc':\n      return (raw * pxPerIn) / 6;\n    default:\n      return null;\n  }\n}\n\nfunction parseViewBox(viewBox: string | null | undefined): SvgDimensions | null {\n  if (!viewBox) return null;\n  const parts = viewBox\n    .trim()\n    .split(/[\\s,]+/)\n    .map((p) => Number(p));\n  if (parts.length !== 4) return null;\n  const width = parts[2] ?? Number.NaN;\n  const height = parts[3] ?? Number.NaN;\n  if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) return null;\n  return { width, height };\n}\n\nexport async function convertSvgToPng(\n  file: File,\n  options: SvgRasterizeOptions = {},\n): Promise<File> {\n  if (\n    typeof document === 'undefined' ||\n    typeof Image === 'undefined' ||\n    typeof URL === 'undefined'\n  ) {\n    throw new Error('SVG to PNG conversion requires a browser environment');\n  }\n\n  const svgText = await file.text();\n  const intrinsic = parseSvgDimensions(svgText);\n  const { width, height } = computeSvgRasterSize({\n    intrinsic,\n    maxWidth: options.maxWidth,\n    maxHeight: options.maxHeight,\n  });\n\n  return new Promise((resolve, reject) => {\n    const url = URL.createObjectURL(file);\n    const img = new Image();\n    img.decoding = 'async';\n\n    img.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = Math.max(1, Math.round(width));\n      canvas.height = Math.max(1, Math.round(height));\n\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        URL.revokeObjectURL(url);\n        return reject(new Error('Failed to create canvas context'));\n      }\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n      canvas.toBlob((blob) => {\n        URL.revokeObjectURL(url);\n        if (!blob) {\n          return reject(new Error('Failed to convert canvas to blob'));\n        }\n\n        const pngName = file.name.replace(/\\.svg$/i, '.png');\n        const pngFile = new File([blob], pngName, {\n          type: 'image/png',\n          lastModified: file.lastModified,\n        });\n\n        resolve(pngFile);\n      }, 'image/png');\n    };\n\n    img.onerror = () => {\n      URL.revokeObjectURL(url);\n      reject(new Error('Failed to load SVG image'));\n    };\n\n    img.src = url;\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/thumbnail-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":21,"messageId":"unexpectedAny","endLine":105,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3372,3375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3372,3375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":17,"messageId":"unexpectedAny","endLine":117,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3673,3676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3673,3676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":51,"messageId":"unexpectedAny","endLine":207,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6596,6599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6596,6599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":21,"messageId":"unexpectedAny","endLine":246,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7770,7773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7770,7773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":17,"messageId":"unexpectedAny","endLine":278,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8637,8640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8637,8640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useProjectStore } from '~/stores/project.store';\nimport { useWorkspaceStore } from '~/stores/workspace.store';\nimport { TIMELINE_CLIP_THUMBNAILS } from '~/utils/constants';\nimport { getProjectThumbnailsSegments } from '~/utils/vardata-paths';\n\nexport interface ThumbnailTask {\n  id: string; // usually clip hash\n  projectId: string;\n  projectRelativePath: string;\n  duration: number; // video duration in seconds\n  onProgress?: (progress: number, url: string, time: number) => void;\n  onComplete?: () => void;\n  onError?: (err: Error) => void;\n}\n\nfunction hashString(input: string): string {\n  let hash = 2166136261;\n  for (let i = 0; i < input.length; i++) {\n    hash ^= input.charCodeAt(i);\n    hash = Math.imul(hash, 16777619);\n  }\n  return `h${(hash >>> 0).toString(16)}`;\n}\n\nexport function getClipThumbnailsHash(input: {\n  projectId: string;\n  projectRelativePath: string;\n}): string {\n  return hashString(`${input.projectId}:${input.projectRelativePath}`);\n}\n\nclass ThumbnailGenerator {\n  private queue: ThumbnailTask[] = [];\n  private activeTasks = new Set<string>();\n  private cache = new Map<string, string[]>(); // hash -> array of blob urls\n\n  addTask(task: ThumbnailTask) {\n    if (this.queue.some((t) => t.id === task.id) || this.activeTasks.has(task.id)) {\n      return; // Already in queue or processing\n    }\n\n    // Check if we already generated it\n    if (this.cache.has(task.id)) {\n      const urls = this.cache.get(task.id)!;\n      urls.forEach((url, index) => {\n        const time = index * TIMELINE_CLIP_THUMBNAILS.INTERVAL_SECONDS;\n        task.onProgress?.((index + 1) / urls.length, url, time);\n      });\n      task.onComplete?.();\n      return;\n    }\n\n    this.queue.push(task);\n    this.processQueue();\n  }\n\n  private processQueue() {\n    while (\n      this.activeTasks.size < TIMELINE_CLIP_THUMBNAILS.MAX_CONCURRENT_TASKS &&\n      this.queue.length > 0\n    ) {\n      const task = this.queue.shift();\n      if (task) {\n        this.activeTasks.add(task.id);\n        this.generateThumbnails(task).finally(() => {\n          this.activeTasks.delete(task.id);\n          this.processQueue();\n        });\n      }\n    }\n  }\n\n  private async loadThumbnailsFromOPFS(task: ThumbnailTask): Promise<boolean> {\n    const workspaceStore = useWorkspaceStore();\n    if (!workspaceStore.workspaceHandle) return false;\n\n    try {\n      const parts = [\n        ...getProjectThumbnailsSegments(task.projectId),\n        TIMELINE_CLIP_THUMBNAILS.DIR_NAME,\n        task.id,\n      ];\n\n      let dir = workspaceStore.workspaceHandle;\n      for (const segment of parts) {\n        dir = await dir.getDirectoryHandle(segment);\n      }\n\n      const hashDir = dir;\n\n      const urls: string[] = [];\n      const totalFrames = Math.ceil(task.duration / TIMELINE_CLIP_THUMBNAILS.INTERVAL_SECONDS);\n      let framesProcessed = 0;\n\n      // We expect filenames to be \"0.webp\", \"5.webp\", \"10.webp\", etc.\n      for (let i = 0; i <= task.duration; i += TIMELINE_CLIP_THUMBNAILS.INTERVAL_SECONDS) {\n        const fileName = `${Math.round(i)}.webp`;\n        try {\n          const fileHandle = await hashDir.getFileHandle(fileName);\n          const file = await fileHandle.getFile();\n          const url = URL.createObjectURL(file);\n          urls.push(url);\n          framesProcessed++;\n          task.onProgress?.(framesProcessed / totalFrames, url, i);\n        } catch (e: any) {\n          if (e?.name === 'NotFoundError') {\n            // If any frame is missing, we consider OPFS cache incomplete\n            return false;\n          }\n          throw e;\n        }\n      }\n\n      this.cache.set(task.id, urls);\n      task.onComplete?.();\n      return true;\n    } catch (e: any) {\n      if (e?.name !== 'NotFoundError') {\n        console.warn('Failed to load thumbnails from OPFS', task.id, e);\n      }\n      return false;\n    }\n  }\n\n  private async generateThumbnails(task: ThumbnailTask): Promise<void> {\n    const isLoaded = await this.loadThumbnailsFromOPFS(task);\n    if (isLoaded) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const workspaceStore = useWorkspaceStore();\n      const projectStore = useProjectStore();\n\n      if (!workspaceStore.workspaceHandle) {\n        reject(new Error('Workspace is not opened'));\n        return;\n      }\n\n      const video = document.createElement('video');\n      video.muted = true;\n      video.crossOrigin = 'anonymous';\n\n      const canvas = document.createElement('canvas');\n      canvas.width = TIMELINE_CLIP_THUMBNAILS.WIDTH;\n      canvas.height = TIMELINE_CLIP_THUMBNAILS.HEIGHT;\n      const ctx = canvas.getContext('2d');\n\n      if (!ctx) {\n        reject(new Error('Failed to get 2d context'));\n        return;\n      }\n\n      let currentTime = 0;\n      const totalFrames = Math.ceil(task.duration / TIMELINE_CLIP_THUMBNAILS.INTERVAL_SECONDS);\n      let framesProcessed = 0;\n\n      let sourceObjectUrl: string | null = null;\n\n      const ensureTargetDir = async () => {\n        const parts = [\n          ...getProjectThumbnailsSegments(task.projectId),\n          TIMELINE_CLIP_THUMBNAILS.DIR_NAME,\n          task.id,\n        ];\n\n        let dir = workspaceStore.workspaceHandle!;\n        for (const segment of parts) {\n          dir = await dir.getDirectoryHandle(segment, { create: true });\n        }\n        return dir;\n      };\n\n      const ensureSourceUrl = async () => {\n        const sourceHandle = await projectStore.getFileHandleByPath(task.projectRelativePath);\n        if (!sourceHandle) throw new Error(`Source file not found: ${task.projectRelativePath}`);\n        const file = await sourceHandle.getFile();\n        sourceObjectUrl = URL.createObjectURL(file);\n        video.src = sourceObjectUrl;\n      };\n\n      const processNextFrame = async () => {\n        if (currentTime > task.duration) {\n          task.onComplete?.();\n          if (sourceObjectUrl) {\n            URL.revokeObjectURL(sourceObjectUrl);\n          }\n          resolve();\n          return;\n        }\n\n        video.currentTime = currentTime;\n      };\n\n      video.addEventListener('seeked', async () => {\n        try {\n          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n          const blob = await new Promise<Blob | null>((res) => {\n            canvas.toBlob(res, 'image/webp', TIMELINE_CLIP_THUMBNAILS.QUALITY);\n          });\n\n          if (blob) {\n            const dir = await ensureTargetDir();\n            const fileName = `${Math.round(currentTime)}.webp`;\n            const fileHandle = await dir.getFileHandle(fileName, { create: true });\n            const writable = await (fileHandle as any).createWritable();\n            await writable.write(blob);\n            await writable.close();\n\n            const savedFile = await fileHandle.getFile();\n            const thumbUrl = URL.createObjectURL(savedFile);\n\n            const urls = this.cache.get(task.id) ?? [];\n            urls.push(thumbUrl);\n            this.cache.set(task.id, urls);\n\n            framesProcessed++;\n            task.onProgress?.(framesProcessed / totalFrames, thumbUrl, currentTime);\n          }\n        } catch (e) {\n          console.error('Error extracting frame', e);\n        }\n\n        currentTime += TIMELINE_CLIP_THUMBNAILS.INTERVAL_SECONDS;\n\n        // Yield to main thread to prevent UI freezing\n        setTimeout(processNextFrame, 50);\n      });\n\n      video.addEventListener('error', (e) => {\n        task.onError?.(new Error('Video error'));\n        if (sourceObjectUrl) {\n          URL.revokeObjectURL(sourceObjectUrl);\n        }\n        reject(e);\n      });\n\n      (async () => {\n        try {\n          await ensureSourceUrl();\n          video.addEventListener('loadeddata', () => {\n            processNextFrame();\n          });\n          video.load();\n        } catch (e: any) {\n          task.onError?.(e instanceof Error ? e : new Error(String(e)));\n          reject(e);\n        }\n      })();\n    });\n  }\n\n  async clearThumbnails(input: { projectId: string; hash: string }) {\n    const urls = this.cache.get(input.hash);\n    if (urls) {\n      for (const url of urls) {\n        URL.revokeObjectURL(url);\n      }\n    }\n    this.cache.delete(input.hash);\n\n    const workspaceStore = useWorkspaceStore();\n    if (!workspaceStore.workspaceHandle) return;\n\n    try {\n      const parts = [\n        ...getProjectThumbnailsSegments(input.projectId),\n        TIMELINE_CLIP_THUMBNAILS.DIR_NAME,\n      ];\n\n      let dir = workspaceStore.workspaceHandle;\n      for (const segment of parts) {\n        dir = await dir.getDirectoryHandle(segment, { create: true });\n      }\n\n      await dir.removeEntry(input.hash, { recursive: true });\n    } catch (e: any) {\n      if (e?.name !== 'NotFoundError') {\n        console.warn('Failed to clear thumbnails for', input.hash, e);\n      }\n    }\n  }\n}\n\nexport const thumbnailGenerator = new ThumbnailGenerator();\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/timeline-media-usage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/timeline-modes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/vardata-paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/AudioEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":64,"column":54,"messageId":"bannedFunctionType","endLine":64,"endColumn":62},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":64,"column":72,"messageId":"bannedFunctionType","endLine":64,"endColumn":80},{"ruleId":"@typescript-eslint/no-useless-constructor","severity":1,"message":"Useless constructor.","line":70,"column":3,"messageId":"noUselessConstructor","endLine":70,"endColumn":14,"suggestions":[{"messageId":"removeConstructor","fix":{"range":[1879,1895],"text":""},"desc":"Remove the constructor."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":39,"messageId":"unexpectedAny","endLine":89,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2575,2578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2575,2578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":40,"messageId":"unexpectedAny","endLine":90,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2643,2646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2643,2646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":30,"messageId":"unexpectedAny","endLine":293,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9584,9587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9584,9587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sourceDurationS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":443,"column":11,"messageId":"unusedVar","endLine":443,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":510,"column":68,"messageId":"unexpectedAny","endLine":510,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15967,15970],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15967,15970],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":514,"column":66,"messageId":"unexpectedAny","endLine":514,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16134,16137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16134,16137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":544,"column":32,"messageId":"unexpectedAny","endLine":544,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17017,17020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17017,17020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":546,"column":86,"messageId":"unexpectedAny","endLine":546,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17175,17178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17175,17178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":579,"column":22,"messageId":"unexpectedAny","endLine":579,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18170,18173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18170,18173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":579,"column":45,"messageId":"unexpectedAny","endLine":579,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18193,18196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18193,18196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":652,"column":17,"messageId":"unusedVar","endLine":652,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":656,"column":16,"messageId":"unusedVar","endLine":656,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createDevLogger } from '~/utils/dev-logger';\nimport {\n  computeFadeDurationsSeconds,\n  getGainAtClipTime,\n  normalizeBalance,\n  normalizeGain,\n} from '~/utils/audio/envelope';\n\nconst logger = createDevLogger('AudioEngine');\n\nexport interface AudioEngineClip {\n  id: string;\n  sourcePath: string;\n  fileHandle: FileSystemFileHandle;\n  startUs: number;\n  durationUs: number;\n  sourceStartUs: number;\n  sourceDurationUs: number;\n  speed?: number;\n  audioGain?: number;\n  audioBalance?: number;\n  audioFadeInUs?: number;\n  audioFadeOutUs?: number;\n}\n\ninterface DecodeRequest {\n  type: 'decode' | 'extract-peaks';\n  id: number;\n  sourceKey: string;\n  arrayBuffer: ArrayBuffer;\n  options?: {\n    maxLength?: number;\n    precision?: number;\n  };\n}\n\ninterface DecodeResponse {\n  type: 'decode-result';\n  id: number;\n  ok: boolean;\n  error?: { name?: string; message: string; stack?: string };\n  result?: {\n    sampleRate: number;\n    numberOfChannels: number;\n    channelBuffers: ArrayBuffer[];\n    peaks?: number[][];\n  };\n}\n\nexport class AudioEngine {\n  private ctx: AudioContext | null = null;\n  private decodedCache = new Map<string, AudioBuffer | null>();\n  private reversedDecodedCache = new Map<string, AudioBuffer | null>();\n  private decodeInFlight = new Map<string, Promise<AudioBuffer | null>>();\n  private activeNodes = new Map<string, AudioBufferSourceNode>();\n  private masterGain: GainNode | null = null;\n  private isPlaying = false;\n  private baseTimeS = 0;\n  private playbackContextTimeS = 0;\n  private currentClips: AudioEngineClip[] = [];\n\n  private decodeWorker: Worker | null = null;\n  private decodeCallId = 0;\n  private decodePending = new Map<number, { resolve: Function; reject: Function }>();\n  private decodeQueue: Array<() => void> = [];\n  private decodeInFlightCount = 0;\n  private readonly maxDecodeConcurrency = 2;\n  private currentVolume = 1;\n\n  constructor() {}\n\n  private ensureDecodeWorker() {\n    if (this.decodeWorker) return this.decodeWorker;\n\n    const worker = new Worker(new URL('../../workers/audio-decode.worker.ts', import.meta.url), {\n      type: 'module',\n      name: 'audio-decode',\n    });\n\n    worker.addEventListener('message', (event: MessageEvent<DecodeResponse>) => {\n      const data = event.data;\n      if (!data || data.type !== 'decode-result') return;\n      const pending = this.decodePending.get(data.id);\n      if (!pending) return;\n      this.decodePending.delete(data.id);\n\n      if (!data.ok) {\n        const err = new Error(data.error?.message || 'Audio decode failed');\n        if (data.error?.name) (err as any).name = data.error.name;\n        if (data.error?.stack) (err as any).stack = data.error.stack;\n        pending.reject(err);\n        return;\n      }\n\n      pending.resolve(data.result);\n    });\n\n    worker.addEventListener('error', (event) => {\n      console.error('[AudioEngine] Decode worker error', event);\n      for (const [, pending] of this.decodePending.entries()) {\n        pending.reject(new Error('Audio decode worker crashed'));\n      }\n      this.decodePending.clear();\n    });\n\n    this.decodeWorker = worker;\n    return worker;\n  }\n\n  private extractPeaksInWorker(\n    arrayBuffer: ArrayBuffer,\n    sourceKey: string,\n    options?: { maxLength?: number; precision?: number },\n  ) {\n    const worker = this.ensureDecodeWorker();\n    return new Promise<DecodeResponse['result']>((resolve, reject) => {\n      const id = ++this.decodeCallId;\n      this.decodePending.set(id, { resolve, reject });\n      const req: DecodeRequest = { type: 'extract-peaks', id, sourceKey, arrayBuffer, options };\n      worker.postMessage(req, [arrayBuffer]);\n    });\n  }\n\n  private decodeInWorker(arrayBuffer: ArrayBuffer, sourceKey: string) {\n    const worker = this.ensureDecodeWorker();\n    return new Promise<DecodeResponse['result']>((resolve, reject) => {\n      const id = ++this.decodeCallId;\n      this.decodePending.set(id, { resolve, reject });\n      const req: DecodeRequest = { type: 'decode', id, sourceKey, arrayBuffer };\n      worker.postMessage(req, [arrayBuffer]);\n    });\n  }\n\n  private async withDecodeSlot<T>(task: () => Promise<T>): Promise<T> {\n    if (this.decodeInFlightCount >= this.maxDecodeConcurrency) {\n      await new Promise<void>((resolve) => this.decodeQueue.push(resolve));\n    }\n    this.decodeInFlightCount += 1;\n    try {\n      return await task();\n    } finally {\n      this.decodeInFlightCount = Math.max(0, this.decodeInFlightCount - 1);\n      const next = this.decodeQueue.shift();\n      if (next) next();\n    }\n  }\n\n  public async extractPeaks(\n    fileHandle: FileSystemFileHandle,\n    sourceKey: string,\n    options?: { maxLength?: number; precision?: number },\n  ): Promise<number[][] | null> {\n    const task = this.withDecodeSlot(async () => {\n      try {\n        const file = await fileHandle.getFile();\n        const arrayBuffer = await file.arrayBuffer();\n\n        const decoded = await this.extractPeaksInWorker(arrayBuffer, sourceKey, options);\n        if (!decoded || !decoded.peaks) {\n          console.warn(`[AudioEngine] Failed to extract peaks for ${sourceKey}`);\n          return null;\n        }\n\n        return decoded.peaks;\n      } catch (err) {\n        console.warn(`[AudioEngine] Failed to extract peaks for ${sourceKey}`, err);\n        return null;\n      }\n    });\n\n    return task;\n  }\n\n  async init(options?: { sampleRate?: number; audioChannels?: 'stereo' | 'mono' }) {\n    const sampleRate = options?.sampleRate || 48000;\n    const channelCount = options?.audioChannels === 'mono' ? 1 : 2;\n\n    if (this.ctx && this.ctx.sampleRate !== sampleRate) {\n      void this.ctx.close();\n      this.ctx = null;\n    }\n\n    if (!this.ctx) {\n      this.ctx = new AudioContext({ sampleRate });\n      this.masterGain = this.ctx.createGain();\n      this.masterGain.gain.value = this.currentVolume;\n      this.masterGain.connect(this.ctx.destination);\n      if (this.ctx.destination) {\n        this.ctx.destination.channelCount = channelCount;\n      }\n    } else {\n      if (this.ctx.destination && this.ctx.destination.channelCount !== channelCount) {\n        this.ctx.destination.channelCount = channelCount;\n      }\n    }\n  }\n\n  resumeContext() {\n    if (this.ctx && this.ctx.state === 'suspended') {\n      this.ctx.resume().catch((err) => {\n        console.warn('[AudioEngine] resumeContext: Failed to resume', err);\n      });\n    }\n  }\n\n  async loadClips(clips: AudioEngineClip[]) {\n    logger.info(\n      'loadClips',\n      clips.map((c) => ({\n        id: c.id,\n        startUs: c.startUs,\n        durationUs: c.durationUs,\n        sourceStartUs: c.sourceStartUs,\n        sourceDurationUs: c.sourceDurationUs,\n      })),\n    );\n    this.currentClips = clips;\n\n    // Best-effort prefetch: decode lazily and yield between tasks to avoid blocking UI.\n    // Decoding is still async and browser-implemented; we just avoid a tight loop.\n    for (const clip of clips) {\n      const sourceKey = clip.sourcePath;\n      if (!sourceKey) continue;\n      if (this.decodedCache.has(sourceKey)) continue;\n      void this.ensureDecoded(sourceKey, clip.fileHandle);\n      await new Promise<void>((resolve) => setTimeout(resolve, 0));\n    }\n  }\n\n  updateTimelineLayout(clips: AudioEngineClip[]) {\n    this.currentClips = clips;\n    if (this.isPlaying) {\n      // Re-evaluate playing nodes\n      const currentTimeUs = this.getCurrentTimeUs();\n      this.stopAllNodes();\n      this.play(currentTimeUs);\n    }\n  }\n\n  private async ensureDecoded(sourceKey: string, fileHandle: FileSystemFileHandle) {\n    const existing = this.decodeInFlight.get(sourceKey);\n    if (existing) return existing;\n\n    if (this.decodedCache.has(sourceKey)) {\n      const cached = this.decodedCache.get(sourceKey);\n      // null means decode failed previously, not in-progress\n      return cached ?? null;\n    }\n\n    const task = this.withDecodeSlot(async () => {\n      try {\n        const file = await fileHandle.getFile();\n        const arrayBuffer = await file.arrayBuffer();\n        if (!this.ctx) return null;\n\n        const decoded = await this.decodeInWorker(arrayBuffer, sourceKey);\n        if (!decoded) {\n          console.warn(`[AudioEngine] Worker returned null for ${sourceKey}`);\n          return null;\n        }\n        if (!decoded.channelBuffers?.length) {\n          console.warn(`[AudioEngine] Worker returned empty channels for ${sourceKey}`);\n          return null;\n        }\n\n        const numChannels = Math.max(1, Math.round(Number(decoded.numberOfChannels) || 1));\n        const sampleRate = Math.max(8000, Math.round(Number(decoded.sampleRate) || 48000));\n        const first = decoded.channelBuffers[0];\n        if (!first) {\n          console.warn(`[AudioEngine] First channel buffer is undefined for ${sourceKey}`);\n          return null;\n        }\n        const frames = Math.floor(first.byteLength / Float32Array.BYTES_PER_ELEMENT);\n        if (frames <= 0) {\n          console.warn(`[AudioEngine] Decoded audio has 0 frames for ${sourceKey}`);\n          return null;\n        }\n\n        const audioBuffer = this.ctx.createBuffer(numChannels, frames, sampleRate);\n        for (let ch = 0; ch < numChannels; ch += 1) {\n          const buf = decoded.channelBuffers[ch];\n          if (!buf) continue;\n          const data = new Float32Array(buf);\n          audioBuffer.copyToChannel(data, ch, 0);\n        }\n\n        logger.info(\n          `Successfully decoded ${sourceKey}: ${numChannels}ch, ${sampleRate}Hz, ${frames} frames`,\n        );\n        this.decodedCache.set(sourceKey, audioBuffer);\n        return audioBuffer;\n      } catch (err) {\n        const name = (err as any)?.name;\n        if (name !== 'NoAudioTrackError') {\n          console.warn('[AudioEngine] Failed to decode audio', err);\n        }\n        this.decodedCache.set(sourceKey, null);\n        return null;\n      } finally {\n        this.decodeInFlight.delete(sourceKey);\n      }\n    });\n\n    this.decodeInFlight.set(sourceKey, task);\n    return task;\n  }\n\n  private globalSpeed = 1;\n\n  async play(timeUs: number, speed = 1) {\n    this.isPlaying = true;\n    this.globalSpeed = speed;\n    const timeS = timeUs / 1_000_000;\n    this.baseTimeS = timeS;\n\n    if (!this.ctx) return;\n\n    this.playbackContextTimeS = this.ctx.currentTime;\n\n    if (this.ctx.state === 'suspended') {\n      await this.ctx.resume().catch((err) => {\n        console.warn('[AudioEngine] play: Failed to resume AudioContext', err);\n      });\n      // Update context time after resume since it might have been delayed\n      this.playbackContextTimeS = this.ctx.currentTime;\n    }\n\n    if (this.globalSpeed !== 0) {\n      for (const clip of this.currentClips) {\n        // Fire and forget\n        void this.scheduleClip(clip, timeS);\n      }\n    }\n  }\n\n  stop() {\n    this.isPlaying = false;\n    this.stopAllNodes();\n  }\n\n  setGlobalSpeed(speed: number) {\n    const parsed = Number(speed);\n    if (!Number.isFinite(parsed)) return;\n\n    const currentTimeS = this.getCurrentTimeS();\n    this.globalSpeed = parsed;\n\n    if (!this.isPlaying) {\n      return;\n    }\n\n    if (!this.ctx) {\n      return;\n    }\n\n    this.stopAllNodes();\n\n    this.baseTimeS = currentTimeS;\n    this.playbackContextTimeS = this.ctx.currentTime;\n\n    for (const clip of this.currentClips) {\n      void this.scheduleClip(clip, currentTimeS);\n    }\n  }\n\n  seek(timeUs: number) {\n    if (this.isPlaying) {\n      this.stopAllNodes();\n\n      const timeS = timeUs / 1_000_000;\n      this.baseTimeS = timeS;\n\n      if (!this.ctx) return;\n\n      this.playbackContextTimeS = this.ctx.currentTime;\n\n      for (const clip of this.currentClips) {\n        void this.scheduleClip(clip, timeS);\n      }\n    }\n  }\n\n  setVolume(volume: number) {\n    this.currentVolume = Math.max(0, Math.min(1, volume));\n    if (this.masterGain) {\n      this.masterGain.gain.value = this.currentVolume;\n    }\n  }\n\n  getCurrentTimeS(): number {\n    if (!this.isPlaying || !this.ctx) return this.baseTimeS;\n    return this.baseTimeS + (this.ctx.currentTime - this.playbackContextTimeS) * this.globalSpeed;\n  }\n\n  getCurrentTimeUs(): number {\n    const s = this.getCurrentTimeS();\n    return Math.round(s * 1_000_000);\n  }\n\n  private async scheduleClip(clip: AudioEngineClip, currentTimeS: number) {\n    if (!this.ctx || !this.masterGain) return;\n\n    const sourceKey = clip.sourcePath;\n    if (!sourceKey) return;\n\n    let buffer = this.decodedCache.get(sourceKey) ?? null;\n    if (!buffer) {\n      const inFlight = this.decodeInFlight.get(sourceKey);\n      if (inFlight) {\n        logger.debug(`Buffer not in cache for ${clip.id}, awaiting decode...`);\n        buffer = await inFlight;\n      } else {\n        logger.debug(`Buffer not in cache for ${clip.id}, awaiting decode...`);\n        buffer = await this.ensureDecoded(sourceKey, clip.fileHandle);\n      }\n      // Re-evaluate current time since decoding takes time\n      currentTimeS = this.getCurrentTimeS();\n    }\n    if (!this.isPlaying) return;\n    if (!buffer) {\n      if (!clip.id.endsWith('__audio')) {\n        console.warn(\n          `[AudioEngine] Buffer could not be decoded for clip ${clip.id} (${sourceKey})`,\n        );\n      }\n      return;\n    }\n\n    const clipStartS = clip.startUs / 1_000_000;\n    const clipDurationS = clip.durationUs / 1_000_000;\n    const clipEndS = clipStartS + clipDurationS;\n\n    const isBackward = this.globalSpeed < 0;\n\n    // If the clip is already completely in the past relative to current time, skip\n    if (isBackward) {\n      if (clipStartS >= currentTimeS) return;\n    } else {\n      if (clipEndS <= currentTimeS) return;\n    }\n\n    const sourceStartS = clip.sourceStartUs / 1_000_000;\n    const sourceDurationS = Math.max(0, clip.sourceDurationUs / 1_000_000);\n\n    const speedRaw = clip.speed;\n    const speed =\n      typeof speedRaw === 'number' && Number.isFinite(speedRaw)\n        ? Math.max(0.1, Math.min(10, speedRaw))\n        : 1;\n\n    const effectiveSpeed = speed * Math.abs(this.globalSpeed);\n\n    const currentClipLocalS = isBackward\n      ? Math.max(0, Math.min(clipEndS, currentTimeS) - clipStartS)\n      : Math.max(0, currentTimeS - clipStartS);\n\n    const { fadeInS, fadeOutS } = computeFadeDurationsSeconds({\n      clipDurationS,\n      fadeInUs: clip.audioFadeInUs,\n      fadeOutUs: clip.audioFadeOutUs,\n    });\n\n    const audioGain = normalizeGain(clip.audioGain, 1);\n    const audioBalance = normalizeBalance(clip.audioBalance, 0);\n\n    // When to start playing in AudioContext time.\n    const playStartS = isBackward\n      ? currentTimeS > clipEndS\n        ? this.ctx.currentTime + (currentTimeS - clipEndS) / Math.abs(this.globalSpeed)\n        : this.ctx.currentTime\n      : currentTimeS < clipStartS\n        ? this.ctx.currentTime + (clipStartS - currentTimeS) / Math.abs(this.globalSpeed)\n        : this.ctx.currentTime;\n\n    const originalBufferOffsetS = sourceStartS + currentClipLocalS * speed;\n\n    if (isBackward) {\n      let reversedBuffer = this.reversedDecodedCache.get(sourceKey) ?? null;\n      if (!reversedBuffer) {\n        reversedBuffer = this.ctx.createBuffer(\n          buffer.numberOfChannels,\n          buffer.length,\n          buffer.sampleRate,\n        );\n        for (let i = 0; i < buffer.numberOfChannels; i++) {\n          const dest = reversedBuffer.getChannelData(i);\n          dest.set(buffer.getChannelData(i));\n          dest.reverse();\n        }\n        this.reversedDecodedCache.set(sourceKey, reversedBuffer);\n      }\n      buffer = reversedBuffer;\n    }\n\n    const remainingInClipS = isBackward\n      ? currentClipLocalS\n      : Math.max(0, clipDurationS - currentClipLocalS);\n    const durationToPlayS = remainingInClipS * speed;\n\n    let safeBufferOffsetS = isBackward\n      ? buffer.duration - originalBufferOffsetS\n      : originalBufferOffsetS;\n    let safeDurationToPlayS = durationToPlayS;\n\n    if (!Number.isFinite(safeBufferOffsetS) || safeBufferOffsetS < 0) {\n      safeBufferOffsetS = 0;\n    }\n\n    if (safeBufferOffsetS >= buffer.duration) {\n      const epsilon = 1 / Math.max(1, Math.round(Number((buffer as any).sampleRate) || 48000));\n      safeBufferOffsetS = Math.max(0, buffer.duration - epsilon);\n    }\n\n    const epsilon = 1 / Math.max(1, Math.round(Number((buffer as any).sampleRate) || 48000));\n    const remainingInBufferS = Math.max(0, buffer.duration - safeBufferOffsetS);\n    safeDurationToPlayS = Math.min(\n      Math.max(safeDurationToPlayS, epsilon),\n      Math.max(remainingInBufferS, epsilon),\n    );\n\n    if (!Number.isFinite(safeDurationToPlayS) || safeDurationToPlayS <= 0) {\n      return;\n    }\n\n    logger.debug(`scheduleClip ${clip.id}`, {\n      clipStartS,\n      clipDurationS,\n      currentTimeS,\n      bufferOffsetS: originalBufferOffsetS,\n      durationToPlayS,\n      playStartS,\n      ctxCurrentTime: this.ctx.currentTime,\n      bufferDuration: buffer.duration,\n    });\n\n    const sourceNode = this.ctx.createBufferSource();\n    sourceNode.buffer = buffer;\n    if (sourceNode.playbackRate) {\n      sourceNode.playbackRate.value = effectiveSpeed;\n    }\n\n    const clipGain = this.ctx.createGain();\n\n    const anyCtx = this.ctx as any;\n    const canPan = typeof anyCtx.createStereoPanner === 'function';\n    const panner: StereoPannerNode | null = canPan ? (anyCtx.createStereoPanner() as any) : null;\n    if (panner) {\n      panner.pan.value = audioBalance;\n      sourceNode.connect(panner);\n      panner.connect(clipGain);\n    } else {\n      sourceNode.connect(clipGain);\n    }\n\n    clipGain.connect(this.masterGain);\n\n    // Apply clip-local fade envelope (in timeline time, not buffer time).\n    // Since playbackRate is set, the node plays `durationToPlayS / speed` seconds in context time,\n    // which equals `remainingInClipS`.\n    const nowS = this.ctx.currentTime;\n    const startAtS = playStartS;\n    const endAtS = startAtS + remainingInClipS;\n\n    function gainAtClipTime(tClipS: number): number {\n      return getGainAtClipTime({\n        clipDurationS,\n        fadeInS,\n        fadeOutS,\n        baseGain: audioGain,\n        tClipS,\n      });\n    }\n\n    const t0 = currentClipLocalS;\n    const t1 = isBackward\n      ? Math.max(0, currentClipLocalS - remainingInClipS)\n      : currentClipLocalS + remainingInClipS;\n    const g0 = gainAtClipTime(t0);\n    const gainParam: any = clipGain.gain as any;\n    if (typeof gainParam.cancelScheduledValues === 'function') {\n      gainParam.cancelScheduledValues(nowS);\n    }\n    if (typeof gainParam.setValueAtTime === 'function') {\n      gainParam.setValueAtTime(g0, startAtS);\n    } else {\n      gainParam.value = g0;\n    }\n\n    if (!isBackward) {\n      const inEndClipS = fadeInS;\n      if (fadeInS > 0 && t0 < inEndClipS && t1 > 0) {\n        const rampEndClipS = Math.min(inEndClipS, t1);\n        const rampEndAtS = startAtS + (rampEndClipS - t0);\n        if (typeof gainParam.linearRampToValueAtTime === 'function') {\n          gainParam.linearRampToValueAtTime(gainAtClipTime(rampEndClipS), rampEndAtS);\n        } else if (typeof gainParam.setValueAtTime === 'function') {\n          gainParam.setValueAtTime(gainAtClipTime(rampEndClipS), rampEndAtS);\n        }\n      }\n\n      const outStartClipS = clipDurationS - fadeOutS;\n      if (fadeOutS > 0 && t1 > outStartClipS) {\n        const rampStartClipS = Math.max(outStartClipS, t0);\n        const rampStartAtS = startAtS + (rampStartClipS - t0);\n        // Ensure we are at the correct value at ramp start, then ramp down to end.\n        if (typeof gainParam.setValueAtTime === 'function') {\n          gainParam.setValueAtTime(gainAtClipTime(rampStartClipS), rampStartAtS);\n        }\n        if (typeof gainParam.linearRampToValueAtTime === 'function') {\n          gainParam.linearRampToValueAtTime(gainAtClipTime(t1), Math.max(rampStartAtS, endAtS));\n        } else if (typeof gainParam.setValueAtTime === 'function') {\n          gainParam.setValueAtTime(gainAtClipTime(t1), Math.max(rampStartAtS, endAtS));\n        }\n      }\n    } else {\n      // In backward playback, the time t decreases from t0 down to t1.\n      // E.g. fading out at the end, if we play backward, we are fading IN.\n      // It starts at t0 (which is e.g. end of clip) and goes down to t1 (e.g. start of clip).\n      const outStartClipS = clipDurationS - fadeOutS;\n      if (fadeOutS > 0 && t0 > outStartClipS) {\n        const rampEndClipS = Math.max(outStartClipS, t1); // the time we stop fading (during backward)\n        const rampEndAtS = startAtS + (t0 - rampEndClipS) / speed;\n        if (typeof gainParam.setValueAtTime === 'function') {\n          // It's a bit complex with linearRampToValueAtTime since we ramp to a value over backward time.\n          // We can just use setValueAtTime for the endpoints.\n          gainParam.linearRampToValueAtTime?.(gainAtClipTime(rampEndClipS), rampEndAtS);\n        }\n      }\n      const inEndClipS = fadeInS;\n      if (fadeInS > 0 && t1 < inEndClipS) {\n        const rampStartClipS = Math.min(inEndClipS, t0);\n        const rampStartAtS = startAtS + (t0 - rampStartClipS) / speed;\n        gainParam.setValueAtTime?.(gainAtClipTime(rampStartClipS), rampStartAtS);\n        gainParam.linearRampToValueAtTime?.(gainAtClipTime(t1), endAtS);\n      }\n    }\n\n    sourceNode.start(playStartS, safeBufferOffsetS, safeDurationToPlayS);\n\n    // Keep track to stop if needed\n    // Using a composite key since a clip might be split or repeated (id should be unique though)\n    this.activeNodes.set(clip.id, sourceNode);\n\n    sourceNode.onended = () => {\n      if (this.activeNodes.get(clip.id) === sourceNode) {\n        this.activeNodes.delete(clip.id);\n      }\n    };\n  }\n\n  private stopAllNodes() {\n    for (const [id, node] of this.activeNodes.entries()) {\n      try {\n        node.stop();\n        node.disconnect();\n      } catch (e) {\n        // ignore errors if already stopped\n      }\n    }\n    this.activeNodes.clear();\n  }\n\n  destroy() {\n    this.stopAllNodes();\n    if (this.ctx) {\n      this.ctx.close();\n      this.ctx = null;\n    }\n    this.decodedCache.clear();\n    this.decodeInFlight.clear();\n\n    if (this.decodeWorker) {\n      this.decodeWorker.terminate();\n      this.decodeWorker = null;\n    }\n    this.decodePending.clear();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/TimelineActiveTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/VideoCompositor.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Container' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"messageId":"unusedVar","endLine":13,"endColumn":12,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Container"},"fix":{"range":[268,281],"text":""},"desc":"Remove unused variable \"Container\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'easeInOutCubic' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":33,"messageId":"unusedVar","endLine":17,"endColumn":47,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"easeInOutCubic"},"fix":{"range":[440,456],"text":""},"desc":"Remove unused variable \"easeInOutCubic\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":12,"messageId":"unexpectedAny","endLine":25,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[745,748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[745,748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":30,"messageId":"unexpectedAny","endLine":27,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[849,852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[849,852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":31,"messageId":"unexpectedAny","endLine":28,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[906,909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[906,909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":34,"messageId":"unexpectedAny","endLine":40,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1348,1351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1348,1351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":35,"messageId":"unexpectedAny","endLine":41,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1409,1412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1409,1412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":30,"messageId":"unexpectedAny","endLine":57,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1832,1835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1832,1835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":31,"messageId":"unexpectedAny","endLine":58,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1889,1892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1889,1892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":13,"messageId":"unexpectedAny","endLine":93,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2813,2816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2813,2816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":62,"messageId":"unexpectedAny","endLine":192,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5868,5871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5868,5871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":23,"messageId":"unexpectedAny","endLine":193,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5898,5901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5898,5901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":23,"messageId":"unexpectedAny","endLine":194,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5990,5993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5990,5993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":30,"messageId":"unexpectedAny","endLine":200,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6157,6160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6157,6160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":20,"messageId":"unexpectedAny","endLine":228,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6843,6846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6843,6846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":249,"column":22,"messageId":"unexpectedAny","endLine":249,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7714,7717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7714,7717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":40,"messageId":"unexpectedAny","endLine":254,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7858,7861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7858,7861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":37,"messageId":"unexpectedAny","endLine":286,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9146,9149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9146,9149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":22,"messageId":"unexpectedAny","endLine":303,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9736,9739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9736,9739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":43,"messageId":"unexpectedAny","endLine":336,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11097,11100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11097,11100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":338,"column":58,"messageId":"unexpectedAny","endLine":338,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11215,11218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11215,11218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":363,"column":20,"messageId":"unexpectedAny","endLine":363,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12058,12061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12058,12061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":53,"messageId":"unexpectedAny","endLine":366,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12176,12179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12176,12179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":81,"messageId":"unexpectedAny","endLine":381,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12725,12728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12725,12728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":389,"column":35,"messageId":"unexpectedAny","endLine":389,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12969,12972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12969,12972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":392,"column":28,"messageId":"unexpectedAny","endLine":392,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13024,13027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13024,13027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":86,"messageId":"unexpectedAny","endLine":417,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13863,13866],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13863,13866],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":423,"column":20,"messageId":"unexpectedAny","endLine":423,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14100,14103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14100,14103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":426,"column":73,"messageId":"unexpectedAny","endLine":426,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14238,14241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14238,14241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":427,"column":49,"messageId":"unexpectedAny","endLine":427,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14294,14297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14294,14297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":446,"column":37,"messageId":"unexpectedAny","endLine":446,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14846,14849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14846,14849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":31,"messageId":"unexpectedAny","endLine":447,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14894,14897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14894,14897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":450,"column":35,"messageId":"unexpectedAny","endLine":450,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15014,15017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15014,15017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":455,"column":28,"messageId":"unexpectedAny","endLine":455,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15165,15168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15165,15168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":478,"column":20,"messageId":"unexpectedAny","endLine":478,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15864,15867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15864,15867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":493,"column":81,"messageId":"unexpectedAny","endLine":493,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16393,16396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16393,16396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":500,"column":35,"messageId":"unexpectedAny","endLine":500,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16610,16613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16610,16613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":503,"column":28,"messageId":"unexpectedAny","endLine":503,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16665,16668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16665,16668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":532,"column":86,"messageId":"unexpectedAny","endLine":532,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17578,17581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17578,17581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":538,"column":20,"messageId":"unexpectedAny","endLine":538,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17796,17799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17796,17799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":544,"column":57,"messageId":"unexpectedAny","endLine":544,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18023,18026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18023,18026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":545,"column":57,"messageId":"unexpectedAny","endLine":545,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18098,18101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18098,18101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":547,"column":27,"messageId":"unexpectedAny","endLine":547,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18190,18193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18190,18193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":547,"column":50,"messageId":"unexpectedAny","endLine":547,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18213,18216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18213,18216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":551,"column":16,"messageId":"unexpectedAny","endLine":551,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18336,18339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18336,18339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":552,"column":18,"messageId":"unusedVar","endLine":552,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":585,"column":35,"messageId":"unexpectedAny","endLine":585,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19238,19241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19238,19241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":597,"column":69,"messageId":"unexpectedAny","endLine":597,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19604,19607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19604,19607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":624,"column":86,"messageId":"unexpectedAny","endLine":624,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20753,20756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20753,20756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":631,"column":20,"messageId":"unexpectedAny","endLine":631,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20972,20975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20972,20975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":660,"column":35,"messageId":"unexpectedAny","endLine":660,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21738,21741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21738,21741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":698,"column":39,"messageId":"unexpectedAny","endLine":698,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22934,22937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22934,22937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":699,"column":34,"messageId":"unexpectedAny","endLine":699,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22984,22987],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22984,22987],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":724,"column":33,"messageId":"unexpectedAny","endLine":724,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23941,23944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23941,23944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":729,"column":47,"messageId":"unexpectedAny","endLine":729,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24158,24161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24158,24161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":745,"column":33,"messageId":"unexpectedAny","endLine":745,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24817,24820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24817,24820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":746,"column":36,"messageId":"unexpectedAny","endLine":746,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24868,24871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24868,24871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":747,"column":37,"messageId":"unexpectedAny","endLine":747,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24923,24926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24923,24926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":750,"column":20,"messageId":"unexpectedAny","endLine":750,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25040,25043],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25040,25043],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":799,"column":75,"messageId":"unexpectedAny","endLine":799,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26594,26597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26594,26597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":847,"column":55,"messageId":"unexpectedAny","endLine":847,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28090,28093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28090,28093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":863,"column":80,"messageId":"unexpectedAny","endLine":863,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28784,28787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28784,28787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":902,"column":32,"messageId":"unexpectedAny","endLine":902,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[30505,30508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[30505,30508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":924,"column":30,"messageId":"unexpectedAny","endLine":924,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31389,31392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31389,31392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1000,"column":42,"messageId":"unexpectedAny","endLine":1000,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34009,34012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34009,34012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1000,"column":50,"messageId":"unexpectedAny","endLine":1000,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34017,34020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34017,34020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1001,"column":49,"messageId":"unexpectedAny","endLine":1001,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34075,34078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34075,34078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1001,"column":73,"messageId":"unexpectedAny","endLine":1001,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34099,34102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34099,34102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1002,"column":49,"messageId":"unexpectedAny","endLine":1002,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34152,34155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34152,34155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1002,"column":73,"messageId":"unexpectedAny","endLine":1002,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34176,34179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34176,34179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1017,"column":39,"messageId":"unexpectedAny","endLine":1017,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34663,34666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34663,34666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1018,"column":45,"messageId":"unexpectedAny","endLine":1018,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[34726,34729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[34726,34729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1042,"column":36,"messageId":"unexpectedAny","endLine":1042,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35524,35527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35524,35527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1123,"column":69,"messageId":"unexpectedAny","endLine":1123,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38353,38356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38353,38356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1124,"column":50,"messageId":"unexpectedAny","endLine":1124,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[38410,38413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[38410,38413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1258,"column":20,"messageId":"unexpectedAny","endLine":1258,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42974,42977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42974,42977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1264,"column":60,"messageId":"unexpectedAny","endLine":1264,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43101,43104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43101,43104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1267,"column":53,"messageId":"unexpectedAny","endLine":1267,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43171,43174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43171,43174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1280,"column":32,"messageId":"unexpectedAny","endLine":1280,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43636,43639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43636,43639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1280,"column":63,"messageId":"unexpectedAny","endLine":1280,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43667,43670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43667,43670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1284,"column":32,"messageId":"unexpectedAny","endLine":1284,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43778,43781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43778,43781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1284,"column":64,"messageId":"unexpectedAny","endLine":1284,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43810,43813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43810,43813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1289,"column":60,"messageId":"unexpectedAny","endLine":1289,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44000,44003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44000,44003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1298,"column":30,"messageId":"unexpectedAny","endLine":1298,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44305,44308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44305,44308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1298,"column":55,"messageId":"unexpectedAny","endLine":1298,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44330,44333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44330,44333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1410,"column":51,"messageId":"unexpectedAny","endLine":1410,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[48177,48180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[48177,48180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1411,"column":42,"messageId":"unexpectedAny","endLine":1411,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[48249,48252],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[48249,48252],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1464,"column":29,"messageId":"unexpectedAny","endLine":1464,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50051,50054],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50051,50054],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1474,"column":31,"messageId":"unexpectedAny","endLine":1474,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50428,50431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50428,50431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1589,"column":38,"messageId":"unexpectedAny","endLine":1589,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54301,54304],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54301,54304],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1595,"column":44,"messageId":"unexpectedAny","endLine":1595,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54403,54406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54403,54406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1601,"column":22,"messageId":"unexpectedAny","endLine":1601,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[54582,54585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[54582,54585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1682,"column":35,"messageId":"unexpectedAny","endLine":1682,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[57218,57221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[57218,57221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1708,"column":65,"messageId":"unexpectedAny","endLine":1708,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[57978,57981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[57978,57981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1710,"column":25,"messageId":"unexpectedAny","endLine":1710,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[58022,58025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[58022,58025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1711,"column":25,"messageId":"unexpectedAny","endLine":1711,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[58119,58122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[58119,58122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1743,"column":22,"messageId":"unexpectedAny","endLine":1743,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[58847,58850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[58847,58850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":97,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { safeDispose } from './utils';\nimport { TimelineActiveTracker } from './TimelineActiveTracker';\nimport type { Filter } from 'pixi.js';\nimport {\n  Application,\n  Sprite,\n  Texture,\n  CanvasSource,\n  ImageSource,\n  DOMAdapter,\n  WebWorkerAdapter,\n  RenderTexture,\n  Container,\n} from 'pixi.js';\nimport type { Input, VideoSampleSink } from 'mediabunny';\nimport { getEffectManifest } from '../../effects';\nimport { getTransitionManifest, easeInOutCubic } from '../../transitions';\nimport type { TextClipStyle } from '~/timeline/types';\nimport { VIDEO_CORE_LIMITS } from '../constants';\n\nexport async function getVideoSampleWithZeroFallback(\n  sink: Pick<VideoSampleSink, 'getSample'>,\n  timeS: number,\n  firstTimestampS?: number,\n): Promise<any | null> {\n  const primary = await sink.getSample(timeS).catch((e) => {\n    const msg = String((e as any)?.message ?? e ?? '');\n    const name = String((e as any)?.name ?? '');\n    if (name === 'InputDisposedError' || msg.includes('Input has been disposed')) {\n      return null;\n    }\n    throw e;\n  });\n  if (primary) return primary;\n\n  if (Number.isFinite(firstTimestampS) && typeof firstTimestampS === 'number') {\n    const safeFirst = Math.max(0, firstTimestampS);\n    if (timeS <= safeFirst) {\n      const first = await sink.getSample(safeFirst).catch((e) => {\n        const msg = String((e as any)?.message ?? e ?? '');\n        const name = String((e as any)?.name ?? '');\n        if (name === 'InputDisposedError' || msg.includes('Input has been disposed')) {\n          return null;\n        }\n        throw e;\n      });\n      if (first) return first;\n    }\n  }\n\n  if (timeS !== 0) {\n    return null;\n  }\n\n  // Some decoders return null for exact 0.0 but can provide the first frame for a tiny epsilon.\n  return sink.getSample(1e-6).catch((e) => {\n    const msg = String((e as any)?.message ?? e ?? '');\n    const name = String((e as any)?.name ?? '');\n    if (name === 'InputDisposedError' || msg.includes('Input has been disposed')) {\n      return null;\n    }\n    throw e;\n  });\n}\n\nexport interface CompositorClip {\n  itemId: string;\n  layer: number;\n  sourcePath?: string;\n  fileHandle?: FileSystemFileHandle;\n  input?: Input;\n  sink?: VideoSampleSink;\n  firstTimestampS?: number;\n  startUs: number;\n  endUs: number;\n  durationUs: number;\n  sourceStartUs: number;\n  sourceDurationUs: number;\n  speed?: number;\n  freezeFrameSourceUs?: number;\n  sprite: Sprite;\n  clipKind: 'video' | 'image' | 'solid' | 'adjustment' | 'text';\n  sourceKind: 'videoFrame' | 'canvas' | 'bitmap';\n  imageSource: ImageSource;\n  lastVideoFrame: VideoFrame | null;\n  canvas: OffscreenCanvas | null;\n  ctx: OffscreenCanvasRenderingContext2D | null;\n  bitmap: ImageBitmap | null;\n  backgroundColor?: string;\n  text?: string;\n  style?: TextClipStyle;\n  opacity?: number;\n  effects?: any[];\n  transform?: {\n    scale?: { x: number; y: number; linked?: boolean };\n    rotationDeg?: number;\n    position?: { x: number; y: number };\n    anchor?: { preset: string; x?: number; y?: number };\n  };\n  effectFilters?: Map<string, Filter>;\n  transitionIn?: {\n    type: string;\n    durationUs: number;\n    mode?: 'blend' | 'composite';\n    curve?: 'linear' | 'bezier';\n  };\n  transitionOut?: {\n    type: string;\n    durationUs: number;\n    mode?: 'blend' | 'composite';\n    curve?: 'linear' | 'bezier';\n  };\n}\n\nexport class VideoCompositor {\n  public app: Application | null = null;\n  public canvas: OffscreenCanvas | HTMLCanvasElement | null = null;\n  public clips: CompositorClip[] = [];\n  public maxDurationUs = 0;\n\n  private width = 1920;\n  private height = 1080;\n  private clipById = new Map<string, CompositorClip>();\n  private replacedClipIds = new Set<string>();\n  private lastRenderedTimeUs = 0;\n  private clipPreferBitmapFallback = new Map<string, boolean>();\n  private clipPreferCanvasFallback = new Map<string, boolean>();\n  private stageSortDirty = true;\n  private activeSortDirty = true;\n  private contextLost = false;\n  private adjustmentTexture: RenderTexture | null = null;\n  private stageVisibilityState: boolean[] = [];\n  private sampleRequestsInFlight = 0;\n  private readonly sampleRequestQueue: Array<() => void> = [];\n  private readonly activeTracker = new TimelineActiveTracker<CompositorClip>({\n    getId: (clip) => clip.itemId,\n    getStartUs: (clip) => clip.startUs,\n    getEndUs: (clip) => clip.endUs,\n  });\n\n  private async withVideoSampleSlot<T>(task: () => Promise<T>): Promise<T> {\n    const max = Math.max(1, Math.round(VIDEO_CORE_LIMITS.MAX_CONCURRENT_VIDEO_SAMPLE_REQUESTS));\n    if (this.sampleRequestsInFlight >= max) {\n      await new Promise<void>((resolve) => this.sampleRequestQueue.push(resolve));\n    }\n    this.sampleRequestsInFlight += 1;\n    try {\n      return await task();\n    } finally {\n      this.sampleRequestsInFlight = Math.max(0, this.sampleRequestsInFlight - 1);\n      const next = this.sampleRequestQueue.shift();\n      if (next) next();\n    }\n  }\n\n  async init(\n    width: number,\n    height: number,\n    bgColor = '#000',\n    offscreen = true,\n    externalCanvas?: OffscreenCanvas | HTMLCanvasElement,\n  ): Promise<void> {\n    if (this.app) {\n      try {\n        this.destroy();\n      } catch (err) {\n        console.error('[VideoCompositor] Failed to destroy previous application instance', err);\n        this.app = null;\n      }\n    }\n\n    this.width = width;\n    this.height = height;\n    this.contextLost = false;\n\n    if (typeof window === 'undefined') {\n      DOMAdapter.set(WebWorkerAdapter);\n    }\n\n    this.app = new Application();\n\n    if (externalCanvas) {\n      this.canvas = externalCanvas;\n    } else if (offscreen) {\n      this.canvas = new OffscreenCanvas(width, height);\n    } else {\n      this.canvas = document.createElement('canvas');\n      this.canvas.width = width;\n      this.canvas.height = height;\n    }\n\n    if (this.canvas && 'addEventListener' in (this.canvas as any)) {\n      (this.canvas as any).addEventListener('webglcontextlost', this.onContextLost, false);\n      (this.canvas as any).addEventListener('webglcontextrestored', this.onContextRestored, false);\n    }\n\n    await this.app.init({\n      width,\n      height,\n      canvas: this.canvas as any,\n      backgroundColor: bgColor,\n      preference: 'webgl',\n      clearBeforeRender: true,\n    });\n\n    // Stop the automatic ticker, we will render manually\n    this.app.ticker.stop();\n\n    this.adjustmentTexture = RenderTexture.create({\n      width: this.width,\n      height: this.height,\n    });\n  }\n\n  private onContextLost = (event: Event) => {\n    event.preventDefault();\n    console.warn('[VideoCompositor] WebGL context lost!');\n    this.contextLost = true;\n  };\n\n  private onContextRestored = () => {\n    console.warn('[VideoCompositor] WebGL context restored!');\n    this.contextLost = false;\n    this.stageSortDirty = true;\n  };\n\n  async loadTimeline(\n    timelineClips: any[],\n    getFileHandleByPath: (path: string) => Promise<FileSystemFileHandle | null>,\n    checkCancel?: () => boolean,\n  ): Promise<number> {\n    if (!this.app) throw new Error('VideoCompositor not initialized');\n\n    const { Input, BlobSource, VideoSampleSink, ALL_FORMATS } = await import('mediabunny');\n\n    const nextClips: CompositorClip[] = [];\n    const nextClipById = new Map<string, CompositorClip>();\n    let sequentialTimeUs = 0; // For fallback if startUs is missing\n\n    for (const [index, clipData] of timelineClips.entries()) {\n      if (checkCancel?.()) {\n        // ÐÑÐ¸ÑÐ°ÐµÐ¼ ÑÐ°ÑÑÐ¸ÑÐ½Ð¾ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð½ÑÐµ ÑÐµÑÑÑÑÑ\n        for (const clip of nextClips) {\n          if (!this.clipById.has(clip.itemId)) {\n            this.destroyClip(clip);\n          }\n        }\n        const abortErr = new Error('Export was cancelled during timeline load');\n        (abortErr as any).name = 'AbortError';\n        throw abortErr;\n      }\n      if (clipData.kind !== 'clip') continue;\n\n      const clipTypeRaw = (clipData as any).clipType;\n      const clipType =\n        clipTypeRaw === 'background' ||\n        clipTypeRaw === 'adjustment' ||\n        clipTypeRaw === 'media' ||\n        clipTypeRaw === 'text'\n          ? clipTypeRaw\n          : 'media';\n\n      const itemId =\n        typeof clipData.id === 'string' && clipData.id.length > 0 ? clipData.id : `clip_${index}`;\n      const sourcePath =\n        typeof clipData?.source?.path === 'string' && clipData.source.path.length > 0\n          ? clipData.source.path\n          : '';\n\n      const sourceStartUs = Math.max(0, Math.round(Number(clipData.sourceRange?.startUs ?? 0)));\n      const freezeFrameSourceUsRaw = clipData.freezeFrameSourceUs;\n      const freezeFrameSourceUs =\n        typeof freezeFrameSourceUsRaw === 'number' && Number.isFinite(freezeFrameSourceUsRaw)\n          ? Math.max(0, Math.round(freezeFrameSourceUsRaw))\n          : undefined;\n      const layer = Math.round(Number(clipData.layer ?? 0));\n      const requestedTimelineDurationUs = Math.max(\n        0,\n        Math.round(Number(clipData.timelineRange?.durationUs ?? 0)),\n      );\n      const requestedSourceDurationUs = Math.max(\n        0,\n        Math.round(Number(clipData.sourceRange?.durationUs ?? requestedTimelineDurationUs)),\n      );\n\n      const speedRaw = (clipData as any).speed;\n      const speed =\n        typeof speedRaw === 'number' && Number.isFinite(speedRaw)\n          ? Math.max(0.1, Math.min(10, speedRaw))\n          : undefined;\n\n      const startUs =\n        typeof clipData.timelineRange?.startUs === 'number'\n          ? Math.max(0, Math.round(Number(clipData.timelineRange.startUs)))\n          : sequentialTimeUs;\n\n      const endUsFallback = startUs + Math.max(0, requestedTimelineDurationUs);\n\n      const reusable = this.clipById.get(itemId);\n      if (\n        reusable &&\n        reusable.sourcePath === sourcePath &&\n        (reusable as any).clipType === clipType\n      ) {\n        const safeSourceDurationUs =\n          requestedSourceDurationUs > 0 ? requestedSourceDurationUs : reusable.sourceDurationUs;\n        const safeTimelineDurationUs =\n          requestedTimelineDurationUs > 0 ? requestedTimelineDurationUs : safeSourceDurationUs;\n\n        if (reusable.clipKind === 'video') {\n          const hasFirstTimestamp =\n            typeof reusable.firstTimestampS === 'number' &&\n            Number.isFinite(reusable.firstTimestampS);\n          if (!hasFirstTimestamp && reusable.input) {\n            try {\n              const track = await reusable.input.getPrimaryVideoTrack();\n              if (track) {\n                reusable.firstTimestampS = await track.getFirstTimestamp();\n              }\n            } catch {\n              // ignore\n            }\n          }\n        }\n\n        reusable.startUs = startUs;\n        reusable.durationUs = safeTimelineDurationUs;\n        reusable.endUs = startUs + safeTimelineDurationUs;\n        reusable.sourceStartUs = sourceStartUs;\n        reusable.sourceDurationUs = safeSourceDurationUs;\n        reusable.speed = speed;\n        reusable.freezeFrameSourceUs = freezeFrameSourceUs;\n        reusable.layer = layer;\n        reusable.opacity = clipData.opacity;\n        reusable.effects = clipData.effects;\n        reusable.transform = (clipData as any).transform;\n        if (reusable.clipKind === 'solid') {\n          reusable.backgroundColor = String((clipData as any).backgroundColor ?? '#000000');\n          reusable.sprite.tint = parseHexColor(reusable.backgroundColor);\n          this.applySolidLayout(reusable);\n        }\n        reusable.sprite.visible = false;\n\n        nextClips.push(reusable);\n        nextClipById.set(itemId, reusable);\n        sequentialTimeUs = Math.max(sequentialTimeUs, reusable.endUs, endUsFallback);\n        continue;\n      }\n\n      if (clipType === 'background') {\n        const endUs = startUs + Math.max(0, requestedTimelineDurationUs);\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n\n        if (reusable) {\n          this.destroyClip(reusable);\n          this.replacedClipIds.add(itemId);\n        }\n\n        const sprite = new Sprite(Texture.WHITE);\n        sprite.width = 1;\n        sprite.height = 1;\n        sprite.visible = false;\n        (sprite as any).__clipId = itemId;\n        this.app.stage.addChild(sprite);\n\n        const backgroundColor = String((clipData as any).backgroundColor ?? '#000000');\n        sprite.tint = parseHexColor(backgroundColor);\n\n        const compositorClip: CompositorClip = {\n          itemId,\n          layer,\n          startUs,\n          endUs,\n          durationUs: Math.max(0, requestedTimelineDurationUs),\n          sourceStartUs: 0,\n          sourceDurationUs: Math.max(0, requestedTimelineDurationUs),\n          speed,\n          sprite,\n          clipKind: 'solid',\n          sourceKind: 'bitmap',\n          imageSource: new ImageSource({ resource: new OffscreenCanvas(2, 2) as any }),\n          lastVideoFrame: null,\n          canvas: null,\n          ctx: null,\n          bitmap: null,\n          backgroundColor,\n          opacity: clipData.opacity,\n          effects: clipData.effects,\n          transform: (clipData as any).transform,\n        };\n\n        (compositorClip as any).clipType = 'background';\n\n        this.applySolidLayout(compositorClip);\n\n        nextClips.push(compositorClip);\n        nextClipById.set(itemId, compositorClip);\n        continue;\n      }\n\n      if (clipType === 'text') {\n        const endUs = startUs + Math.max(0, requestedTimelineDurationUs);\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n\n        if (reusable) {\n          this.destroyClip(reusable);\n          this.replacedClipIds.add(itemId);\n        }\n\n        const clipCanvas = new OffscreenCanvas(Math.max(1, this.width), Math.max(1, this.height));\n        const clipCtx = clipCanvas.getContext('2d');\n        if (!clipCtx) {\n          sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n          continue;\n        }\n\n        const imageSource = new ImageSource({ resource: new OffscreenCanvas(2, 2) as any });\n        const texture = new Texture({ source: imageSource });\n        const sprite = new Sprite(texture);\n        sprite.width = this.width;\n        sprite.height = this.height;\n        sprite.visible = false;\n        (sprite as any).__clipId = itemId;\n        this.app.stage.addChild(sprite);\n\n        const canvasSource = new CanvasSource({ resource: clipCanvas as any });\n        sprite.texture.source = canvasSource as any;\n\n        const compositorClip: CompositorClip = {\n          itemId,\n          layer,\n          startUs,\n          endUs,\n          durationUs: Math.max(0, requestedTimelineDurationUs),\n          sourceStartUs: 0,\n          sourceDurationUs: Math.max(0, requestedTimelineDurationUs),\n          speed,\n          sprite,\n          clipKind: 'text',\n          sourceKind: 'canvas',\n          imageSource,\n          lastVideoFrame: null,\n          canvas: clipCanvas,\n          ctx: clipCtx,\n          bitmap: null,\n          text: String((clipData as any).text ?? ''),\n          style: (clipData as any).style,\n          opacity: clipData.opacity,\n          effects: clipData.effects,\n          transform: (clipData as any).transform,\n          transitionIn: clipData.transitionIn,\n          transitionOut: clipData.transitionOut,\n        };\n\n        (compositorClip as any).clipType = 'text';\n\n        this.drawTextClip(compositorClip);\n        this.applySolidLayout(compositorClip);\n\n        nextClips.push(compositorClip);\n        nextClipById.set(itemId, compositorClip);\n        continue;\n      }\n\n      if (clipType === 'adjustment') {\n        const endUs = startUs + Math.max(0, requestedTimelineDurationUs);\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n\n        if (reusable) {\n          this.destroyClip(reusable);\n          this.replacedClipIds.add(itemId);\n        }\n\n        const sprite = new Sprite(Texture.EMPTY);\n        sprite.width = this.width;\n        sprite.height = this.height;\n        sprite.visible = false;\n        (sprite as any).__clipId = itemId;\n        this.app.stage.addChild(sprite);\n\n        const compositorClip: CompositorClip = {\n          itemId,\n          layer,\n          startUs,\n          endUs,\n          durationUs: Math.max(0, requestedTimelineDurationUs),\n          sourceStartUs: 0,\n          sourceDurationUs: Math.max(0, requestedTimelineDurationUs),\n          speed,\n          sprite,\n          clipKind: 'adjustment',\n          sourceKind: 'bitmap',\n          imageSource: new ImageSource({ resource: new OffscreenCanvas(2, 2) as any }),\n          lastVideoFrame: null,\n          canvas: null,\n          ctx: null,\n          bitmap: null,\n          opacity: clipData.opacity,\n          effects: clipData.effects,\n          transform: (clipData as any).transform,\n        };\n\n        (compositorClip as any).clipType = 'adjustment';\n\n        nextClips.push(compositorClip);\n        nextClipById.set(itemId, compositorClip);\n        continue;\n      }\n\n      if (!sourcePath) {\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUsFallback);\n        continue;\n      }\n\n      if (reusable) {\n        this.destroyClip(reusable);\n        this.replacedClipIds.add(itemId);\n      }\n\n      const fileHandle = await getFileHandleByPath(sourcePath);\n      if (!fileHandle) {\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUsFallback);\n        continue;\n      }\n\n      const file = await fileHandle.getFile();\n\n      if (typeof file?.type === 'string' && file.type.startsWith('image/')) {\n        const endUs = startUs + Math.max(0, requestedTimelineDurationUs);\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n\n        const imageSource = new ImageSource({ resource: new OffscreenCanvas(2, 2) as any });\n        const texture = new Texture({ source: imageSource });\n        const sprite = new Sprite(texture);\n        sprite.width = 1;\n        sprite.height = 1;\n        sprite.visible = false;\n        (sprite as any).__clipId = itemId;\n        this.app.stage.addChild(sprite);\n\n        let bmp: ImageBitmap | null = null;\n        try {\n          bmp = await createImageBitmap(file);\n          const frameW = Math.max(1, Math.round((bmp as any).width ?? 1));\n          const frameH = Math.max(1, Math.round((bmp as any).height ?? 1));\n          imageSource.resize(frameW, frameH);\n          (imageSource as any).resource = bmp as any;\n          imageSource.update();\n          this.applySpriteLayout(frameW, frameH, {\n            sprite,\n          } as any);\n        } catch (e) {\n          if (bmp) {\n            try {\n              bmp.close();\n            } catch {\n              // ignore\n            }\n          }\n          sprite.visible = false;\n        }\n\n        const compositorClip: CompositorClip = {\n          itemId,\n          layer,\n          sourcePath,\n          fileHandle,\n          startUs,\n          endUs,\n          durationUs: Math.max(0, requestedTimelineDurationUs),\n          sourceStartUs: 0,\n          sourceDurationUs: Math.max(0, requestedTimelineDurationUs),\n          speed,\n          sprite,\n          clipKind: 'image',\n          sourceKind: 'bitmap',\n          imageSource,\n          lastVideoFrame: null,\n          canvas: null,\n          ctx: null,\n          bitmap: bmp,\n          backgroundColor: undefined,\n          opacity: clipData.opacity,\n          effects: clipData.effects,\n          transform: (clipData as any).transform,\n          transitionIn: clipData.transitionIn,\n          transitionOut: clipData.transitionOut,\n        };\n\n        nextClips.push(compositorClip);\n        nextClipById.set(itemId, compositorClip);\n        continue;\n      }\n\n      try {\n        const source = new BlobSource(file);\n        const input = new Input({ source, formats: ALL_FORMATS } as any);\n        const track = await input.getPrimaryVideoTrack();\n\n        if (!track || !(await track.canDecode())) {\n          safeDispose(input);\n          continue;\n        }\n\n        const sink = new VideoSampleSink(track);\n        const firstTimestampS = await track.getFirstTimestamp();\n        const mediaDurationUs = Math.max(\n          0,\n          Math.round((await track.computeDuration()) * 1_000_000),\n        );\n        const maxSourceTailUs = Math.max(0, mediaDurationUs - sourceStartUs);\n        const sourceDurationUs =\n          requestedSourceDurationUs > 0\n            ? Math.min(requestedSourceDurationUs, maxSourceTailUs)\n            : maxSourceTailUs;\n        const durationUs =\n          requestedTimelineDurationUs > 0 ? requestedTimelineDurationUs : sourceDurationUs;\n        const endUs = startUs + durationUs;\n\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUs);\n\n        // Start with a VideoFrame-powered texture source when available.\n        // Fallback to a per-clip OffscreenCanvas if VideoFrame upload fails at runtime.\n        const imageSource = new ImageSource({ resource: new OffscreenCanvas(2, 2) as any });\n        const texture = new Texture({ source: imageSource });\n        const sprite = new Sprite(texture);\n\n        sprite.width = 1;\n        sprite.height = 1;\n        sprite.visible = false;\n        (sprite as any).__clipId = itemId;\n        this.app.stage.addChild(sprite);\n\n        const compositorClip: CompositorClip = {\n          itemId,\n          layer,\n          sourcePath,\n          fileHandle,\n          input,\n          sink,\n          firstTimestampS,\n          startUs,\n          endUs,\n          durationUs,\n          sourceStartUs,\n          sourceDurationUs,\n          speed,\n          freezeFrameSourceUs,\n          sprite,\n          clipKind: 'video',\n          sourceKind: 'videoFrame',\n          imageSource,\n          lastVideoFrame: null,\n          canvas: null,\n          ctx: null,\n          bitmap: null,\n          backgroundColor: undefined,\n          opacity: clipData.opacity,\n          effects: clipData.effects,\n          transform: (clipData as any).transform,\n          transitionIn: clipData.transitionIn,\n          transitionOut: clipData.transitionOut,\n        };\n\n        nextClips.push(compositorClip);\n        nextClipById.set(itemId, compositorClip);\n      } catch (err) {\n        console.error(`[VideoCompositor] Failed to load video clip ${itemId}:`, err);\n        sequentialTimeUs = Math.max(sequentialTimeUs, endUsFallback);\n        continue;\n      }\n    }\n\n    for (const [prevId, prevClip] of this.clipById.entries()) {\n      if (this.replacedClipIds.has(prevId)) {\n        continue;\n      }\n      if (!nextClipById.has(prevId)) {\n        this.destroyClip(prevClip);\n      }\n    }\n    this.replacedClipIds.clear();\n\n    this.clips = nextClips;\n    this.clipById = nextClipById;\n    this.clips.sort((a, b) => a.startUs - b.startUs || a.layer - b.layer);\n    const maxClipEndUs = this.clips.length > 0 ? Math.max(0, ...this.clips.map((c) => c.endUs)) : 0;\n    this.maxDurationUs = Math.max(maxClipEndUs, sequentialTimeUs);\n\n    this.lastRenderedTimeUs = 0;\n    this.activeTracker.reset();\n    this.stageSortDirty = true;\n    this.activeSortDirty = true;\n\n    return this.maxDurationUs;\n  }\n\n  updateTimelineLayout(timelineClips: any[]): number {\n    const byId = new Map<string, any>();\n    for (const clipData of timelineClips) {\n      if (clipData?.kind !== 'clip') continue;\n      if (typeof clipData.id !== 'string' || clipData.id.length === 0) continue;\n      byId.set(clipData.id, clipData);\n    }\n\n    for (const clip of this.clips) {\n      const next = byId.get(clip.itemId);\n      if (!next) continue;\n\n      const startUs = Math.max(0, Math.round(Number(next.timelineRange?.startUs ?? clip.startUs)));\n      const timelineDurationUs = Math.max(\n        0,\n        Math.round(Number(next.timelineRange?.durationUs ?? clip.durationUs)),\n      );\n      const sourceStartUs = Math.max(\n        0,\n        Math.round(Number(next.sourceRange?.startUs ?? clip.sourceStartUs)),\n      );\n      const sourceDurationUs = Math.max(\n        0,\n        Math.round(Number(next.sourceRange?.durationUs ?? clip.sourceDurationUs)),\n      );\n      const layer = Math.round(Number(next.layer ?? clip.layer ?? 0));\n      const speedRaw = (next as any).speed;\n      const speed =\n        typeof speedRaw === 'number' && Number.isFinite(speedRaw)\n          ? Math.max(0.1, Math.min(10, speedRaw))\n          : undefined;\n      const freezeFrameSourceUsRaw = (next as any).freezeFrameSourceUs;\n      const freezeFrameSourceUs =\n        typeof freezeFrameSourceUsRaw === 'number' && Number.isFinite(freezeFrameSourceUsRaw)\n          ? Math.max(0, Math.round(freezeFrameSourceUsRaw))\n          : undefined;\n\n      clip.startUs = startUs;\n      clip.durationUs = timelineDurationUs;\n      clip.endUs = startUs + timelineDurationUs;\n      clip.sourceStartUs = sourceStartUs;\n      clip.sourceDurationUs = sourceDurationUs;\n      clip.speed = speed;\n      clip.freezeFrameSourceUs = freezeFrameSourceUs;\n      clip.layer = layer;\n      clip.opacity = next.opacity;\n      clip.effects = next.effects;\n      clip.transform = (next as any).transform;\n      clip.transitionIn = (next as any).transitionIn;\n      clip.transitionOut = (next as any).transitionOut;\n      if (clip.clipKind === 'solid') {\n        clip.backgroundColor = String(\n          (next as any).backgroundColor ?? clip.backgroundColor ?? '#000000',\n        );\n        clip.sprite.tint = parseHexColor(clip.backgroundColor);\n        this.applySolidLayout(clip);\n      }\n      if (!clip.effectFilters) {\n        clip.effectFilters = new Map();\n      }\n    }\n\n    this.clips.sort((a, b) => a.startUs - b.startUs || a.layer - b.layer);\n    this.maxDurationUs = this.clips.length > 0 ? Math.max(0, ...this.clips.map((c) => c.endUs)) : 0;\n\n    this.lastRenderedTimeUs = 0;\n    this.activeTracker.reset();\n    this.stageSortDirty = true;\n    this.activeSortDirty = true;\n    return this.maxDurationUs;\n  }\n\n  async renderFrame(timeUs: number): Promise<OffscreenCanvas | HTMLCanvasElement | null> {\n    if (!this.app || !this.canvas) return null;\n\n    if (this.contextLost) {\n      return null;\n    }\n\n    if (timeUs === this.lastRenderedTimeUs && !this.stageSortDirty && !this.activeSortDirty) {\n      return this.canvas;\n    }\n\n    const updatedClips: CompositorClip[] = [];\n    try {\n      const { activeClips: active, activeChanged } = this.activeTracker.update({\n        clips: this.clips,\n        timeUs,\n        lastTimeUs: this.lastRenderedTimeUs,\n        onDeactivate: (clip) => {\n          clip.sprite.visible = false;\n        },\n      });\n\n      if (activeChanged) {\n        this.activeSortDirty = true;\n      }\n      if (this.activeSortDirty) {\n        active.sort((a, b) => a.layer - b.layer || a.startUs - b.startUs);\n        this.activeSortDirty = false;\n      }\n      const sampleRequests: Array<Promise<{ clip: CompositorClip; sample: any | null }>> = [];\n\n      for (const clip of active) {\n        const effectiveOpacity = this.computeTransitionOpacity(clip, timeUs);\n        clip.sprite.alpha = effectiveOpacity;\n\n        this.applyClipEffects(clip);\n\n        if (clip.clipKind === 'image') {\n          clip.sprite.visible = true;\n          continue;\n        }\n\n        if (clip.clipKind === 'solid') {\n          clip.sprite.visible = true;\n          continue;\n        }\n\n        if (clip.clipKind === 'adjustment') {\n          clip.sprite.visible = true;\n          continue;\n        }\n\n        if (clip.clipKind === 'text') {\n          this.drawTextClip(clip);\n          clip.sprite.visible = true;\n          continue;\n        }\n\n        const localTimeUs = timeUs - clip.startUs;\n        const speed = typeof clip.speed === 'number' ? clip.speed : 1;\n        const maxTimelineUs = speed > 0 ? Math.round(clip.sourceDurationUs / speed) : 0;\n        if (localTimeUs < 0 || localTimeUs >= maxTimelineUs) {\n          clip.sprite.visible = false;\n          continue;\n        }\n\n        const freezeUs = clip.freezeFrameSourceUs;\n        const sampleTimeS =\n          typeof freezeUs === 'number'\n            ? Math.max(0, freezeUs) / 1_000_000\n            : (clip.sourceStartUs + Math.round(localTimeUs * speed)) / 1_000_000;\n        if (!clip.sink) {\n          clip.sprite.visible = false;\n          continue;\n        }\n\n        const request = this.withVideoSampleSlot(() =>\n          getVideoSampleWithZeroFallback(clip.sink as any, sampleTimeS, clip.firstTimestampS),\n        )\n          .then((sample) => ({ clip, sample }))\n          .catch((error) => {\n            console.error('[VideoCompositor] Failed to render sample', error);\n            return { clip, sample: null };\n          });\n\n        sampleRequests.push(request);\n      }\n\n      // --- Blend shadow rendering ---\n      // Behaviour:\n      //  - image / solid clips: always kept visible (infinite source)\n      //  - video with handle material (sourceDurationUs > durationUs): seek into handle frames\n      //  - video without handle material: freeze the last available frame\n      const blendShadowRequests: Array<Promise<{ clip: CompositorClip; sample: any | null }>> = [];\n\n      for (const clip of active) {\n        const tr = clip.transitionIn;\n        if (!tr || (tr.mode ?? 'blend') !== 'blend' || tr.durationUs <= 0) continue;\n        const localTimeUs = timeUs - clip.startUs;\n        if (localTimeUs >= tr.durationUs) continue;\n\n        const prevClip = this.findPrevClipOnLayer(clip);\n        if (!prevClip || active.includes(prevClip)) continue;\n\n        const manifest = getTransitionManifest(tr.type);\n        const rawProgress = Math.max(0, Math.min(1, localTimeUs / tr.durationUs));\n        const shadowAlpha = manifest\n          ? manifest.computeOutOpacity(rawProgress, {}, tr.curve ?? 'linear')\n          : 1 - rawProgress;\n\n        prevClip.sprite.alpha = Math.max(0, Math.min(1, shadowAlpha));\n\n        // Images and solid clips: keep visible indefinitely\n        if (prevClip.clipKind === 'image' || prevClip.clipKind === 'solid') {\n          prevClip.sprite.visible = true;\n          continue;\n        }\n\n        // Check if source media has frames beyond the clip's out-point (handle material)\n        // handleUs = total available source after clip end\n        const handleUs = prevClip.sourceDurationUs - prevClip.durationUs;\n        if (!prevClip.sink) {\n          prevClip.sprite.visible = false;\n          continue;\n        }\n\n        if (handleUs < 1_000) {\n          // No extra source material: freeze the last available frame of the previous clip.\n          const lastUs = Math.max(0, prevClip.sourceStartUs + prevClip.sourceDurationUs - 1_000);\n          const shadowSampleTimeS = Math.max(0, lastUs / 1_000_000);\n          const req = this.withVideoSampleSlot(() =>\n            getVideoSampleWithZeroFallback(\n              prevClip.sink as any,\n              shadowSampleTimeS,\n              prevClip.firstTimestampS,\n            ),\n          )\n            .then((sample) => ({ clip: prevClip, sample }))\n            .catch(() => ({ clip: prevClip, sample: null }));\n          blendShadowRequests.push(req);\n          continue;\n        }\n\n        // Seek into handle material: frames at sourceStartUs + durationUs + overrun\n        const overrunUs = localTimeUs;\n        const handleSampleUs = prevClip.sourceStartUs + prevClip.durationUs + overrunUs;\n        // Clamp to available handle\n        const clampedUs = Math.min(\n          handleSampleUs,\n          prevClip.sourceStartUs + prevClip.sourceDurationUs - 1_000,\n        );\n        const shadowSampleTimeS = Math.max(0, clampedUs / 1_000_000);\n        const req = this.withVideoSampleSlot(() =>\n          getVideoSampleWithZeroFallback(\n            prevClip.sink as any,\n            shadowSampleTimeS,\n            prevClip.firstTimestampS,\n          ),\n        )\n          .then((sample) => ({ clip: prevClip, sample }))\n          .catch(() => ({ clip: prevClip, sample: null }));\n        blendShadowRequests.push(req);\n      }\n\n      if (blendShadowRequests.length > 0) {\n        const shadowSamples = await Promise.all(blendShadowRequests);\n        for (const { clip, sample } of shadowSamples) {\n          if (!sample) {\n            clip.sprite.visible = false;\n            continue;\n          }\n          try {\n            await this.updateClipTextureFromSample(sample, clip);\n            clip.sprite.visible = true;\n            updatedClips.push(clip);\n          } catch {\n            clip.sprite.visible = false;\n          } finally {\n            if (typeof sample.close === 'function') {\n              try {\n                sample.close();\n              } catch {\n                /**/\n              }\n            }\n          }\n        }\n      }\n\n      // --- Composite mode: explicitly hide same-layer prev clip ---\n      // In composite mode, the clip fades in over lower tracks only; prev clip on same layer must not show.\n      for (const clip of active) {\n        const tr = clip.transitionIn;\n        if (!tr || (tr.mode ?? 'blend') !== 'composite' || tr.durationUs <= 0) continue;\n        const localTimeUs = timeUs - clip.startUs;\n        if (localTimeUs >= tr.durationUs) continue;\n        const prevClip = this.findPrevClipOnLayer(clip);\n        if (prevClip && !active.includes(prevClip)) {\n          prevClip.sprite.visible = false;\n        }\n      }\n\n      if (sampleRequests.length > 0) {\n        const samples = await Promise.all(sampleRequests);\n        for (const { clip, sample } of samples) {\n          if (!sample) {\n            clip.sprite.visible = false;\n            continue;\n          }\n          try {\n            await this.updateClipTextureFromSample(sample, clip);\n            clip.sprite.visible = true;\n            updatedClips.push(clip);\n          } catch (error) {\n            console.error('[VideoCompositor] Failed to update clip texture', error);\n            clip.sprite.visible = false;\n          } finally {\n            if (typeof sample.close === 'function') {\n              try {\n                sample.close();\n              } catch (err) {\n                console.error('[VideoCompositor] Failed to close VideoSample', err);\n              }\n            }\n          }\n        }\n      }\n\n      if (this.stageSortDirty) {\n        // Ensure stage ordering matches layer ordering for correct blending\n        this.app.stage.children.sort((a: any, b: any) => {\n          const aClip = this.clipById.get((a as any).__clipId ?? '') as any;\n          const bClip = this.clipById.get((b as any).__clipId ?? '') as any;\n          const aLayer = typeof aClip?.layer === 'number' ? aClip.layer : 0;\n          const bLayer = typeof bClip?.layer === 'number' ? bClip.layer : 0;\n          return aLayer - bLayer;\n        });\n        this.stageSortDirty = false;\n      }\n\n      this.lastRenderedTimeUs = timeUs;\n\n      if (\n        this.adjustmentTexture &&\n        active.some((c) => c.clipKind === 'adjustment' && c.sprite.visible)\n      ) {\n        const textureOk =\n          !(this.adjustmentTexture as any)?.destroyed &&\n          typeof (this.adjustmentTexture as any)?.uid === 'number';\n        if (!textureOk) {\n          try {\n            safeDispose(this.adjustmentTexture);\n          } catch {\n            // ignore\n          }\n          this.adjustmentTexture = RenderTexture.create({\n            width: this.width,\n            height: this.height,\n          });\n        }\n\n        const children = this.app.stage.children;\n        if (this.stageVisibilityState.length !== children.length) {\n          this.stageVisibilityState = new Array(children.length);\n        }\n        for (let i = 0; i < children.length; i++) {\n          this.stageVisibilityState[i] = children[i]?.visible ?? false;\n        }\n\n        let applied = false;\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          const clipId = (child as any)?.__clipId;\n          if (!clipId) continue;\n          const clip = this.clipById.get(clipId);\n          if (!clip || clip.clipKind !== 'adjustment' || !clip.sprite.visible) continue;\n\n          // Hide adjustment layer itself and everything above it\n          for (let j = i; j < children.length; j++) {\n            const childObj = children[j];\n            if (childObj) childObj.visible = false;\n          }\n\n          if (this.adjustmentTexture) {\n            this.app.renderer.render({\n              container: this.app.stage,\n              target: this.adjustmentTexture,\n              clear: true,\n            });\n          }\n\n          // Restore visibility\n          for (let j = 0; j < children.length; j++) {\n            const childObj = children[j];\n            if (childObj) childObj.visible = this.stageVisibilityState[j] as boolean;\n          }\n\n          if (this.adjustmentTexture) {\n            clip.sprite.texture = this.adjustmentTexture;\n          }\n\n          applied = true;\n          break;\n        }\n\n        if (!applied) {\n          for (const c of this.clips) {\n            if (c.clipKind !== 'adjustment') continue;\n            if (c.sprite.texture === this.adjustmentTexture) {\n              c.sprite.texture = Texture.EMPTY;\n            }\n          }\n        }\n      }\n\n      this.app.render();\n\n      return this.canvas;\n    } finally {\n      // Ensure VideoFrames are always closed even when rendering fails.\n      for (const clip of updatedClips) {\n        if (!clip.lastVideoFrame) continue;\n        safeDispose(clip.lastVideoFrame);\n        clip.lastVideoFrame = null;\n      }\n    }\n  }\n\n  /** Find the clip on the same layer immediately adjacent to `clip` (for blend shadow rendering).\n   *  Returns null if there is a gap larger than 200ms between the clips. */\n  private findPrevClipOnLayer(clip: CompositorClip): CompositorClip | null {\n    let best: CompositorClip | null = null;\n    for (const c of this.clips) {\n      if (c.layer !== clip.layer) continue;\n      if (c.itemId === clip.itemId) continue;\n      if (c.endUs > clip.startUs + 1_000) continue; // skip clips that end after current start\n      if (!best || c.endUs > best.endUs) best = c;\n    }\n    if (!best) return null;\n    // Reject only for a large gap â allow small gaps to still show a reasonable blend shadow.\n    if (clip.startUs - best.endUs > 1_000_000) return null;\n    return best;\n  }\n\n  private ensureCanvasFallback(clip: CompositorClip) {\n    if (clip.canvas && clip.ctx) return;\n    const clipCanvas = new OffscreenCanvas(2, 2);\n    const clipCtx = clipCanvas.getContext('2d');\n    if (!clipCtx) {\n      throw new Error('Failed to create 2D rendering context for clip canvas');\n    }\n    clip.canvas = clipCanvas;\n    clip.ctx = clipCtx;\n    const canvasSource = new CanvasSource({ resource: clipCanvas as any });\n    clip.sprite.texture.source = canvasSource as any;\n    clip.sourceKind = 'canvas';\n  }\n\n  private applySolidLayout(clip: CompositorClip) {\n    const tr = clip.transform;\n    const scaleX = typeof tr?.scale?.x === 'number' && Number.isFinite(tr.scale.x) ? tr.scale.x : 1;\n    const scaleY = typeof tr?.scale?.y === 'number' && Number.isFinite(tr.scale.y) ? tr.scale.y : 1;\n    const rotationDeg =\n      typeof tr?.rotationDeg === 'number' && Number.isFinite(tr.rotationDeg) ? tr.rotationDeg : 0;\n    const posX =\n      typeof tr?.position?.x === 'number' && Number.isFinite(tr.position.x) ? tr.position.x : 0;\n    const posY =\n      typeof tr?.position?.y === 'number' && Number.isFinite(tr.position.y) ? tr.position.y : 0;\n\n    const anchor = tr?.anchor;\n    const preset = typeof anchor?.preset === 'string' ? anchor.preset : 'center';\n    const normalizedAnchor = (() => {\n      switch (preset) {\n        case 'topLeft':\n          return { x: 0, y: 0 };\n        case 'topRight':\n          return { x: 1, y: 0 };\n        case 'bottomLeft':\n          return { x: 0, y: 1 };\n        case 'bottomRight':\n          return { x: 1, y: 1 };\n        case 'custom': {\n          const ax = typeof anchor?.x === 'number' && Number.isFinite(anchor.x) ? anchor.x : 0.5;\n          const ay = typeof anchor?.y === 'number' && Number.isFinite(anchor.y) ? anchor.y : 0.5;\n          return { x: Math.max(0, Math.min(1, ax)), y: Math.max(0, Math.min(1, ay)) };\n        }\n        case 'center':\n        default:\n          return { x: 0.5, y: 0.5 };\n      }\n    })();\n\n    this.applyTransformLayout({\n      clip,\n      baseX: 0,\n      baseY: 0,\n      targetW: this.width,\n      targetH: this.height,\n      normalizedAnchor,\n      scaleX,\n      scaleY,\n      rotationDeg,\n      posX,\n      posY,\n    });\n  }\n\n  private computeTransitionOpacity(clip: CompositorClip, timeUs: number): number {\n    const baseOpacity = clip.opacity ?? 1;\n    const localTimeUs = timeUs - clip.startUs;\n    let opacity = baseOpacity;\n\n    if (clip.transitionIn && clip.transitionIn.durationUs > 0) {\n      const dur = clip.transitionIn.durationUs;\n      const curve = clip.transitionIn.curve ?? 'linear';\n      // In composite mode the clip fades from the lower track composition â opacity still applies\n      if (localTimeUs < dur) {\n        const manifest = getTransitionManifest(clip.transitionIn.type);\n        if (manifest) {\n          const rawProgress = Math.max(0, Math.min(1, localTimeUs / dur));\n          opacity = Math.min(\n            opacity,\n            baseOpacity * manifest.computeInOpacity(rawProgress, {}, curve),\n          );\n        }\n      }\n    }\n\n    if (clip.transitionOut && clip.transitionOut.durationUs > 0) {\n      const dur = clip.transitionOut.durationUs;\n      const curve = clip.transitionOut.curve ?? 'linear';\n      const clipDurUs = clip.durationUs;\n      const outStartUs = clipDurUs - dur;\n      if (localTimeUs >= outStartUs) {\n        const manifest = getTransitionManifest(clip.transitionOut.type);\n        if (manifest) {\n          const rawProgress = Math.max(0, Math.min(1, (localTimeUs - outStartUs) / dur));\n          opacity = Math.min(\n            opacity,\n            baseOpacity * manifest.computeOutOpacity(rawProgress, {}, curve),\n          );\n        }\n      }\n    }\n\n    return Math.max(0, Math.min(1, opacity));\n  }\n\n  private applyClipEffects(clip: CompositorClip) {\n    if (!clip.effectFilters) {\n      clip.effectFilters = new Map();\n    }\n\n    const filters: Filter[] = [];\n    const seenIds = new Set<string>();\n\n    if (Array.isArray(clip.effects) && clip.effects.length > 0) {\n      for (const effect of clip.effects) {\n        if (!effect?.enabled) continue;\n        if (typeof effect.id !== 'string' || effect.id.length === 0) continue;\n        if (typeof effect.type !== 'string' || effect.type.length === 0) continue;\n\n        const manifest = getEffectManifest(effect.type);\n        if (!manifest) continue;\n\n        seenIds.add(effect.id);\n        let filter = clip.effectFilters.get(effect.id);\n        if (!filter) {\n          filter = manifest.createFilter();\n          clip.effectFilters.set(effect.id, filter);\n        }\n\n        try {\n          manifest.updateFilter(filter, effect);\n        } catch (err) {\n          console.error('[VideoCompositor] Failed to update effect filter', err);\n          continue;\n        }\n\n        filters.push(filter);\n      }\n    }\n\n    // Cleanup filters for removed effects\n    for (const [id, filter] of clip.effectFilters.entries()) {\n      if (seenIds.has(id)) continue;\n      clip.effectFilters.delete(id);\n      try {\n        (filter as any)?.destroy?.();\n      } catch {\n        // ignore\n      }\n    }\n\n    clip.sprite.filters = filters.length > 0 ? (filters as any) : null;\n  }\n\n  private async updateClipTextureFromSample(sample: any, clip: CompositorClip) {\n    const preferCanvas = this.clipPreferCanvasFallback.get(clip.itemId) === true;\n\n    try {\n      if (preferCanvas) {\n        throw new Error('Prefer canvas fallback');\n      }\n\n      // Prefer WebCodecs VideoFrame path (GPU-friendly upload).\n      if (typeof sample?.toVideoFrame === 'function') {\n        const frame = sample.toVideoFrame() as VideoFrame;\n        const frameW = Math.max(\n          1,\n          Math.round((frame as any).displayWidth ?? (frame as any).codedWidth ?? 1),\n        );\n        const frameH = Math.max(\n          1,\n          Math.round((frame as any).displayHeight ?? (frame as any).codedHeight ?? 1),\n        );\n\n        if (clip.sourceKind !== 'videoFrame') {\n          // Restore ImageSource-based texture\n          clip.sprite.texture.source = clip.imageSource as any;\n          clip.sourceKind = 'videoFrame';\n        }\n\n        if (clip.imageSource.width !== frameW || clip.imageSource.height !== frameH) {\n          clip.imageSource.resize(frameW, frameH);\n        }\n\n        // Assign the new frame as the resource and mark for upload.\n        (clip.imageSource as any).resource = frame as any;\n        clip.imageSource.update();\n\n        // Layout on stage\n        this.applySpriteLayout(frameW, frameH, clip);\n\n        clip.lastVideoFrame = frame;\n        return;\n      }\n    } catch (err) {\n      this.clipPreferCanvasFallback.set(clip.itemId, true);\n      console.warn('[VideoCompositor] VideoFrame path failed, falling back to canvas:', err);\n    }\n\n    // Fallback: draw into 2D canvas and upload.\n    await this.drawSampleToCanvas(sample, clip);\n  }\n\n  private applySpriteLayout(frameW: number, frameH: number, clip: CompositorClip) {\n    const viewportScale = Math.min(this.width / frameW, this.height / frameH);\n    const targetW = frameW * viewportScale;\n    const targetH = frameH * viewportScale;\n    const baseX = (this.width - targetW) / 2;\n    const baseY = (this.height - targetH) / 2;\n\n    const tr = clip.transform;\n    const scaleX = typeof tr?.scale?.x === 'number' && Number.isFinite(tr.scale.x) ? tr.scale.x : 1;\n    const scaleY = typeof tr?.scale?.y === 'number' && Number.isFinite(tr.scale.y) ? tr.scale.y : 1;\n    const rotationDeg =\n      typeof tr?.rotationDeg === 'number' && Number.isFinite(tr.rotationDeg) ? tr.rotationDeg : 0;\n    const posX =\n      typeof tr?.position?.x === 'number' && Number.isFinite(tr.position.x) ? tr.position.x : 0;\n    const posY =\n      typeof tr?.position?.y === 'number' && Number.isFinite(tr.position.y) ? tr.position.y : 0;\n\n    const anchor = tr?.anchor;\n    const preset = typeof anchor?.preset === 'string' ? anchor.preset : 'center';\n    const normalizedAnchor = (() => {\n      switch (preset) {\n        case 'topLeft':\n          return { x: 0, y: 0 };\n        case 'topRight':\n          return { x: 1, y: 0 };\n        case 'bottomLeft':\n          return { x: 0, y: 1 };\n        case 'bottomRight':\n          return { x: 1, y: 1 };\n        case 'custom': {\n          const ax = typeof anchor?.x === 'number' && Number.isFinite(anchor.x) ? anchor.x : 0.5;\n          const ay = typeof anchor?.y === 'number' && Number.isFinite(anchor.y) ? anchor.y : 0.5;\n          return { x: Math.max(0, Math.min(1, ax)), y: Math.max(0, Math.min(1, ay)) };\n        }\n        case 'center':\n        default:\n          return { x: 0.5, y: 0.5 };\n      }\n    })();\n\n    this.applyTransformLayout({\n      clip,\n      baseX,\n      baseY,\n      targetW,\n      targetH,\n      normalizedAnchor,\n      scaleX,\n      scaleY,\n      rotationDeg,\n      posX,\n      posY,\n    });\n  }\n\n  private applyTransformLayout(input: {\n    clip: CompositorClip;\n    baseX: number;\n    baseY: number;\n    targetW: number;\n    targetH: number;\n    normalizedAnchor: { x: number; y: number };\n    scaleX: number;\n    scaleY: number;\n    rotationDeg: number;\n    posX: number;\n    posY: number;\n  }) {\n    input.clip.sprite.anchor.set(input.normalizedAnchor.x, input.normalizedAnchor.y);\n    input.clip.sprite.width = input.targetW;\n    input.clip.sprite.height = input.targetH;\n    input.clip.sprite.scale.x *= input.scaleX;\n    input.clip.sprite.scale.y *= input.scaleY;\n    input.clip.sprite.rotation = (input.rotationDeg * Math.PI) / 180;\n\n    const anchorOffsetX = input.normalizedAnchor.x * input.targetW;\n    const anchorOffsetY = input.normalizedAnchor.y * input.targetH;\n    input.clip.sprite.x = input.baseX + anchorOffsetX + input.posX;\n    input.clip.sprite.y = input.baseY + anchorOffsetY + input.posY;\n  }\n\n  private drawTextClip(clip: CompositorClip) {\n    if (clip.clipKind !== 'text') return;\n    if (!clip.canvas || !clip.ctx) return;\n\n    const ctx = clip.ctx;\n    const canvas = clip.canvas;\n\n    const targetW = Math.max(1, Math.round(this.width));\n    const targetH = Math.max(1, Math.round(this.height));\n    if (canvas.width !== targetW || canvas.height !== targetH) {\n      canvas.width = targetW;\n      canvas.height = targetH;\n      try {\n        if (typeof (clip.sprite.texture.source as any)?.resize === 'function') {\n          (clip.sprite.texture.source as any).resize(targetW, targetH);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    const style = clip.style ?? {};\n    const fontSize =\n      typeof style.fontSize === 'number' && Number.isFinite(style.fontSize)\n        ? Math.max(1, Math.min(1000, Math.round(style.fontSize)))\n        : 64;\n    const fontFamily =\n      typeof style.fontFamily === 'string' && style.fontFamily.length > 0\n        ? style.fontFamily\n        : 'sans-serif';\n    const fontWeight =\n      typeof style.fontWeight === 'string' || typeof style.fontWeight === 'number'\n        ? String(style.fontWeight)\n        : '700';\n    const color =\n      typeof style.color === 'string' && style.color.length > 0 ? style.color : '#ffffff';\n    const align =\n      style.align === 'left' || style.align === 'center' || style.align === 'right'\n        ? style.align\n        : 'center';\n\n    const verticalAlign =\n      style.verticalAlign === 'top' ||\n      style.verticalAlign === 'middle' ||\n      style.verticalAlign === 'bottom'\n        ? style.verticalAlign\n        : 'middle';\n\n    const lineHeightMultiplier =\n      typeof style.lineHeight === 'number' && Number.isFinite(style.lineHeight)\n        ? Math.max(0.1, Math.min(10, style.lineHeight))\n        : 1.2;\n    const lineHeightPx = Math.max(1, Math.round(fontSize * lineHeightMultiplier));\n\n    const letterSpacing =\n      typeof style.letterSpacing === 'number' && Number.isFinite(style.letterSpacing)\n        ? Math.max(-1000, Math.min(1000, style.letterSpacing))\n        : 0;\n\n    const backgroundColor =\n      typeof style.backgroundColor === 'string' && style.backgroundColor.trim().length > 0\n        ? style.backgroundColor.trim()\n        : '';\n\n    const padding = (() => {\n      const raw = (style as any).padding;\n      const clampPadding = (v: unknown) =>\n        typeof v === 'number' && Number.isFinite(v) ? Math.max(0, Math.min(10_000, v)) : undefined;\n\n      if (typeof raw === 'number') {\n        const v = clampPadding(raw) ?? 0;\n        return { top: v, right: v, bottom: v, left: v };\n      }\n\n      if (raw && typeof raw === 'object') {\n        const anyPad = raw as any;\n        const x = clampPadding(anyPad.x);\n        const y = clampPadding(anyPad.y);\n        const top = clampPadding(anyPad.top);\n        const right = clampPadding(anyPad.right);\n        const bottom = clampPadding(anyPad.bottom);\n        const left = clampPadding(anyPad.left);\n\n        const fromXY =\n          x !== undefined || y !== undefined\n            ? { top: y ?? 0, right: x ?? 0, bottom: y ?? 0, left: x ?? 0 }\n            : undefined;\n        const fromEdges =\n          top !== undefined || right !== undefined || bottom !== undefined || left !== undefined\n            ? { top: top ?? 0, right: right ?? 0, bottom: bottom ?? 0, left: left ?? 0 }\n            : undefined;\n\n        return fromEdges ?? fromXY ?? { top: 60, right: 60, bottom: 60, left: 60 };\n      }\n\n      return { top: 60, right: 60, bottom: 60, left: 60 };\n    })();\n\n    const safeW = Math.max(1, canvas.width);\n    const safeH = Math.max(1, canvas.height);\n    const boxX = Math.max(0, padding.left);\n    const boxY = Math.max(0, padding.top);\n    const boxW = Math.max(1, safeW - Math.max(0, padding.left) - Math.max(0, padding.right));\n    const boxH = Math.max(1, safeH - Math.max(0, padding.top) - Math.max(0, padding.bottom));\n\n    if (backgroundColor.length > 0) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(boxX, boxY, boxW, boxH);\n      ctx.restore();\n    }\n\n    ctx.fillStyle = color;\n    ctx.textAlign = align;\n    ctx.textBaseline = 'top';\n    ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n\n    const rawText = String(clip.text ?? '');\n    const paragraphs = rawText.split(/\\r?\\n/g);\n\n    const wrapLine = (line: string): string[] => {\n      const trimmed = String(line);\n      if (trimmed.length === 0) return [''];\n\n      const words = trimmed.split(/\\s+/g);\n      const lines: string[] = [];\n      let curr = '';\n\n      for (const w of words) {\n        const next = curr.length > 0 ? `${curr} ${w}` : w;\n        const width =\n          ctx.measureText(next).width + Math.max(0, next.length - 1) * Math.max(0, letterSpacing);\n        if (width <= boxW || curr.length === 0) {\n          curr = next;\n          continue;\n        }\n        lines.push(curr);\n        curr = w;\n      }\n      lines.push(curr);\n      return lines;\n    };\n\n    const lines = paragraphs.flatMap((p) => wrapLine(p));\n    const textBlockH = lines.length * lineHeightPx;\n    const startY =\n      verticalAlign === 'top'\n        ? boxY\n        : verticalAlign === 'bottom'\n          ? boxY + Math.max(0, boxH - textBlockH)\n          : boxY + Math.max(0, (boxH - textBlockH) / 2);\n\n    const startX = align === 'left' ? boxX : align === 'right' ? boxX + boxW : boxX + boxW / 2;\n\n    const drawWithLetterSpacing = (text: string, x: number, y: number) => {\n      if (!Number.isFinite(letterSpacing) || letterSpacing === 0) {\n        ctx.fillText(text, x, y);\n        return;\n      }\n\n      if (ctx.textAlign === 'center' || ctx.textAlign === 'right') {\n        const baseWidth = ctx.measureText(text).width;\n        const extra = Math.max(0, text.length - 1) * letterSpacing;\n        const total = baseWidth + extra;\n        const leftX = ctx.textAlign === 'center' ? x - total / 2 : x - total;\n\n        let dx = leftX;\n        for (let i = 0; i < text.length; i++) {\n          const ch = text[i] ?? '';\n          ctx.fillText(ch, dx, y);\n          dx += ctx.measureText(ch).width + letterSpacing;\n        }\n        return;\n      }\n\n      let dx = x;\n      for (let i = 0; i < text.length; i++) {\n        const ch = text[i] ?? '';\n        ctx.fillText(ch, dx, y);\n        dx += ctx.measureText(ch).width + letterSpacing;\n      }\n    };\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i] ?? '';\n      const y = startY + i * lineHeightPx;\n      drawWithLetterSpacing(line, startX, y);\n    }\n\n    try {\n      (clip.sprite.texture.source as any)?.update?.();\n    } catch {\n      // ignore\n    }\n  }\n\n  private async drawSampleToCanvas(sample: any, clip: CompositorClip) {\n    this.ensureCanvasFallback(clip);\n    const ctx = clip.ctx;\n    const canvas = clip.canvas;\n    if (!ctx || !canvas) return;\n\n    let imageSource: any;\n    try {\n      imageSource =\n        typeof sample.toCanvasImageSource === 'function' ? sample.toCanvasImageSource() : sample;\n      const frameW = Math.max(1, Math.round(imageSource?.displayWidth ?? imageSource?.width ?? 1));\n      const frameH = Math.max(\n        1,\n        Math.round(imageSource?.displayHeight ?? imageSource?.height ?? 1),\n      );\n\n      if (canvas.width !== frameW || canvas.height !== frameH) {\n        canvas.width = frameW;\n        canvas.height = frameH;\n        if (typeof clip.sprite.texture.source.resize === 'function') {\n          clip.sprite.texture.source.resize(frameW, frameH);\n        }\n      }\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      const preferBitmap = this.clipPreferBitmapFallback.get(clip.itemId) === true;\n\n      try {\n        if (preferBitmap) {\n          throw new Error('Prefer createImageBitmap fallback');\n        }\n        ctx.drawImage(imageSource, 0, 0, frameW, frameH);\n        this.applySpriteLayout(frameW, frameH, clip);\n        clip.sprite.texture.source.update();\n        return;\n      } catch (err) {\n        this.clipPreferBitmapFallback.set(clip.itemId, true);\n        console.warn('[VideoCompositor] drawImage failed, trying createImageBitmap fallback:', err);\n        try {\n          const bmp = await createImageBitmap(imageSource);\n          ctx.drawImage(bmp, 0, 0, frameW, frameH);\n          this.applySpriteLayout(frameW, frameH, clip);\n          clip.sprite.texture.source.update();\n          bmp.close();\n          return;\n        } catch (innerErr) {\n          console.error('[VideoCompositor] Fallback createImageBitmap failed:', innerErr);\n          throw innerErr;\n        }\n      }\n    } catch (err) {\n      console.error('[VideoCompositor] drawSampleToCanvas failed to draw image:', err);\n    }\n\n    if (typeof sample.draw === 'function') {\n      try {\n        sample.draw(ctx, 0, 0, canvas.width, canvas.height);\n        clip.sprite.texture.source.update();\n      } catch (err) {\n        console.error('[VideoCompositor] sample.draw failed:', err);\n      }\n      return;\n    }\n  }\n\n  clearClips() {\n    for (const clip of this.clips) {\n      this.destroyClip(clip);\n    }\n    this.clips = [];\n    this.clipById.clear();\n    this.replacedClipIds.clear();\n    this.lastRenderedTimeUs = 0;\n    this.activeTracker.reset();\n    this.stageSortDirty = true;\n    this.activeSortDirty = true;\n    this.maxDurationUs = 0;\n  }\n\n  destroy() {\n    this.clearClips();\n    if (this.adjustmentTexture) {\n      safeDispose(this.adjustmentTexture);\n      this.adjustmentTexture = null;\n    }\n    if (this.app) {\n      const pixiApp = this.app as any;\n\n      // Pixi v8 ResizePlugin teardown may call an internal _cancelResize callback.\n      // Guard it because some lifecycle interleavings leave it unset.\n      if (typeof pixiApp._cancelResize !== 'function') {\n        pixiApp._cancelResize = () => {};\n      }\n      if (typeof pixiApp.cancelResize === 'function') {\n        pixiApp.cancelResize();\n      }\n\n      try {\n        this.app.destroy(\n          { removeView: false },\n          {\n            children: true,\n            texture: true,\n            textureSource: true,\n          },\n        );\n      } catch (err) {\n        console.error('[VideoCompositor] Application destroy failed', err);\n      }\n      this.app = null;\n    }\n\n    if (this.canvas && 'removeEventListener' in (this.canvas as any)) {\n      try {\n        (this.canvas as any).removeEventListener('webglcontextlost', this.onContextLost, false);\n        (this.canvas as any).removeEventListener(\n          'webglcontextrestored',\n          this.onContextRestored,\n          false,\n        );\n      } catch {\n        // ignore\n      }\n    }\n    this.canvas = null;\n  }\n\n  private destroyClip(clip: CompositorClip) {\n    safeDispose(clip.sink);\n    safeDispose(clip.input);\n    if (clip.lastVideoFrame) {\n      safeDispose(clip.lastVideoFrame);\n      clip.lastVideoFrame = null;\n    }\n\n    if (clip.bitmap) {\n      safeDispose(clip.bitmap);\n      clip.bitmap = null;\n    }\n\n    if (clip.sprite && clip.sprite.parent) {\n      clip.sprite.parent.removeChild(clip.sprite);\n    }\n\n    if (clip.effectFilters) {\n      for (const filter of clip.effectFilters.values()) {\n        try {\n          (filter as any)?.destroy?.();\n        } catch {\n          // ignore\n        }\n      }\n      clip.effectFilters.clear();\n    }\n    clip.sprite.destroy(true);\n  }\n}\n\nfunction parseHexColor(value: string): number {\n  const raw = String(value ?? '').trim();\n  const hex = raw.startsWith('#') ? raw.slice(1) : raw;\n  if (hex.length === 3) {\n    const r = hex[0] ?? '0';\n    const g = hex[1] ?? '0';\n    const b = hex[2] ?? '0';\n    const expanded = `${r}${r}${g}${g}${b}${b}`;\n    const parsed = Number.parseInt(expanded, 16);\n    return Number.isFinite(parsed) ? parsed : 0;\n  }\n  const parsed = Number.parseInt(hex.padStart(6, '0').slice(0, 6), 16);\n  return Number.isFinite(parsed) ? parsed : 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/worker-client.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":17,"column":40,"messageId":"bannedFunctionType","endLine":17,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":17,"column":58,"messageId":"bannedFunctionType","endLine":17,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":36,"messageId":"unexpectedAny","endLine":79,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2326,2329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2326,2329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":23,"messageId":"unexpectedAny","endLine":80,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2372,2375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2372,2375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":47,"messageId":"unexpectedAny","endLine":80,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2396,2399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2396,2399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":36,"messageId":"unexpectedAny","endLine":81,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2442,2445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2442,2445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":23,"messageId":"unexpectedAny","endLine":82,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2489,2492],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2489,2492],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":48,"messageId":"unexpectedAny","endLine":82,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2514,2517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2514,2517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":37,"messageId":"unexpectedAny","endLine":100,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3274,3277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3274,3277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":21,"messageId":"unexpectedAny","endLine":102,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3397,3400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3397,3400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":15,"messageId":"unexpectedAny","endLine":152,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4846,4849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4846,4849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":32,"messageId":"unexpectedAny","endLine":189,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5882,5885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5882,5885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { VideoCoreWorkerAPI } from './worker-rpc';\nimport { VIDEO_CORE_LIMITS } from '../constants';\n\nexport interface VideoCoreHostAPI {\n  getFileHandleByPath(path: string): Promise<FileSystemFileHandle | null>;\n  onExportProgress(progress: number): void;\n  onExportPhase?(phase: 'encoding' | 'saving'): void;\n  onExportWarning?(message: string): void;\n}\n\ntype WorkerChannel = 'preview' | 'export';\n\ninterface WorkerChannelState {\n  workerInstance: Worker | null;\n  hostApiInstance: VideoCoreHostAPI | null;\n  callIdCounter: number;\n  pendingCalls: Map<number, { resolve: Function; reject: Function }>;\n}\n\nconst channelStates: Record<WorkerChannel, WorkerChannelState> = {\n  preview: {\n    workerInstance: null,\n    hostApiInstance: null,\n    callIdCounter: 0,\n    pendingCalls: new Map(),\n  },\n  export: {\n    workerInstance: null,\n    hostApiInstance: null,\n    callIdCounter: 0,\n    pendingCalls: new Map(),\n  },\n};\n\nfunction rejectAllPendingCalls(state: WorkerChannelState, error: Error) {\n  for (const [id, pending] of state.pendingCalls.entries()) {\n    try {\n      pending.reject(error);\n    } finally {\n      state.pendingCalls.delete(id);\n    }\n  }\n}\n\nfunction terminateChannel(channel: WorkerChannel, reason: string) {\n  const state = channelStates[channel];\n  if (state.workerInstance) {\n    state.workerInstance.terminate();\n    state.workerInstance = null;\n  }\n  rejectAllPendingCalls(state, new Error(reason));\n}\n\nfunction createWorker(channel: WorkerChannel): Worker {\n  const state = channelStates[channel];\n  const worker = new Worker(new URL('../../workers/video-core.worker.ts', import.meta.url), {\n    type: 'module',\n    name: `video-core-${channel}`,\n  });\n\n  worker.addEventListener('message', async (e) => {\n    const data = e.data;\n    if (!data || !data.type) return;\n\n    if (data.type === 'rpc-response') {\n      const pending = state.pendingCalls.get(data.id);\n      if (pending) {\n        if (data.error) {\n          const errData = data.error;\n          const message =\n            typeof errData === 'string'\n              ? errData\n              : typeof errData?.message === 'string'\n                ? errData.message\n                : 'Worker error';\n\n          const err = new Error(message);\n          if (errData && typeof errData === 'object') {\n            if (typeof (errData as any).name === 'string')\n              (err as any).name = (errData as any).name;\n            if (typeof (errData as any).stack === 'string')\n              (err as any).stack = (errData as any).stack;\n          }\n          pending.reject(err);\n        } else pending.resolve(data.result);\n        state.pendingCalls.delete(data.id);\n      }\n    } else if (data.type === 'rpc-call') {\n      try {\n        if (!state.hostApiInstance) throw new Error('Host API not set');\n        const method = data.method as keyof VideoCoreHostAPI;\n        const fn = state.hostApiInstance[method];\n        if (typeof fn !== 'function') {\n          if (data.method === 'onExportPhase' || data.method === 'onExportWarning') {\n            worker.postMessage({ type: 'rpc-response', id: data.id, result: undefined });\n            return;\n          }\n          throw new Error(`Method ${data.method} not found on Host API`);\n        }\n        const result = await (fn as any)(...(data.args || []));\n        worker.postMessage({ type: 'rpc-response', id: data.id, result });\n      } catch (err: any) {\n        worker.postMessage({\n          type: 'rpc-response',\n          id: data.id,\n          error: {\n            name: err?.name || 'Error',\n            message: err?.message || String(err),\n            stack: err?.stack,\n          },\n        });\n      }\n    }\n  });\n\n  worker.addEventListener('error', (event) => {\n    console.error('[WorkerClient] Worker error', event);\n    if (state.workerInstance === worker) {\n      terminateChannel(channel, 'Worker crashed. Please retry the operation.');\n    }\n  });\n\n  worker.addEventListener('messageerror', (event) => {\n    console.error('[WorkerClient] Worker message error', event);\n    if (state.workerInstance === worker) {\n      terminateChannel(channel, 'Worker message channel failed. Please retry the operation.');\n    }\n  });\n\n  return worker;\n}\n\nfunction ensureWorker(channel: WorkerChannel): Worker {\n  const state = channelStates[channel];\n  if (!state.workerInstance) {\n    state.workerInstance = createWorker(channel);\n  }\n  return state.workerInstance;\n}\n\nfunction createChannelClient(channel: WorkerChannel): {\n  client: VideoCoreWorkerAPI;\n  worker: Worker;\n} {\n  const state = channelStates[channel];\n  const worker = ensureWorker(channel);\n\n  function ensurePendingSlot() {\n    const max = Math.max(1, Math.round(VIDEO_CORE_LIMITS.MAX_WORKER_RPC_PENDING_CALLS));\n    if (state.pendingCalls.size >= max) {\n      const err = new Error('Worker RPC queue overflow');\n      (err as any).name = 'WorkerQueueOverflowError';\n      throw err;\n    }\n  }\n\n  const clientAPI = new Proxy(\n    {},\n    {\n      get(_, method: string) {\n        if (method === 'initCompositor') {\n          return async (\n            canvas: OffscreenCanvas,\n            width: number,\n            height: number,\n            bgColor: string,\n          ) => {\n            return new Promise<void>((resolve, reject) => {\n              try {\n                ensurePendingSlot();\n              } catch (err) {\n                reject(err);\n                return;\n              }\n              const id = ++state.callIdCounter;\n              state.pendingCalls.set(id, { resolve, reject });\n              ensureWorker(channel).postMessage(\n                {\n                  type: 'rpc-call',\n                  id,\n                  method: 'initCompositor',\n                  args: [canvas, width, height, bgColor],\n                },\n                [canvas],\n              );\n            });\n          };\n        }\n        return async (...args: any[]) => {\n          return new Promise((resolve, reject) => {\n            try {\n              ensurePendingSlot();\n            } catch (err) {\n              reject(err);\n              return;\n            }\n            const id = ++state.callIdCounter;\n            state.pendingCalls.set(id, { resolve, reject });\n            ensureWorker(channel).postMessage({ type: 'rpc-call', id, method, args });\n          });\n        };\n      },\n    },\n  ) as VideoCoreWorkerAPI;\n\n  return {\n    client: clientAPI,\n    worker,\n  };\n}\n\nexport function setPreviewHostApi(api: VideoCoreHostAPI) {\n  channelStates.preview.hostApiInstance = api;\n}\n\nexport function setExportHostApi(api: VideoCoreHostAPI) {\n  channelStates.export.hostApiInstance = api;\n}\n\nexport function terminatePreviewWorker(reason = 'Preview worker terminated') {\n  terminateChannel('preview', reason);\n}\n\nexport function terminateExportWorker(reason = 'Export worker terminated') {\n  terminateChannel('export', reason);\n}\n\nexport function restartPreviewWorker() {\n  terminateChannel('preview', 'Preview worker restarted');\n  return getPreviewWorkerClient();\n}\n\nexport function restartExportWorker() {\n  terminateChannel('export', 'Export worker restarted');\n  return getExportWorkerClient();\n}\n\nexport function getPreviewWorkerClient(): { client: VideoCoreWorkerAPI; worker: Worker } {\n  return createChannelClient('preview');\n}\n\nexport function getExportWorkerClient(): { client: VideoCoreWorkerAPI; worker: Worker } {\n  return createChannelClient('export');\n}\n\n// Backward-compatible aliases (preview channel)\nexport function setHostApi(api: VideoCoreHostAPI) {\n  setPreviewHostApi(api);\n}\n\nexport function terminateWorker(reason = 'Worker terminated') {\n  terminatePreviewWorker(reason);\n}\n\nexport function restartWorker() {\n  return restartPreviewWorker();\n}\n\nexport function getWorkerClient(): { client: VideoCoreWorkerAPI; worker: Worker } {\n  return getPreviewWorkerClient();\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/video-editor/worker-rpc.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createChannel' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"messageId":"unusedVar","endLine":1,"endColumn":23,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"createChannel"},"fix":{"range":[0,38],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":62,"messageId":"unexpectedAny","endLine":5,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[152,155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[152,155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":23,"messageId":"unexpectedAny","endLine":14,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[372,375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[372,375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":31,"messageId":"unexpectedAny","endLine":15,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[427,430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[427,430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":14,"messageId":"unexpectedAny","endLine":23,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[651,654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[651,654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":20,"messageId":"unexpectedAny","endLine":24,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[675,678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[675,678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[699,702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[699,702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":20,"messageId":"unexpectedAny","endLine":34,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createChannel } from 'bidc';\n\nexport interface VideoCoreWorkerAPI {\n  // Metadata\n  extractMetadata(fileHandle: FileSystemFileHandle): Promise<any>;\n\n  // initCompositor is implemented manually in the client proxy\n  initCompositor(\n    canvas: OffscreenCanvas,\n    width: number,\n    height: number,\n    bgColor: string,\n  ): Promise<void>;\n  loadTimeline(clips: any[]): Promise<number>;\n  updateTimelineLayout(clips: any[]): Promise<number>;\n  renderFrame(timeUs: number): Promise<void>;\n  clearClips(): Promise<void>;\n  destroyCompositor(): Promise<void>;\n\n  // Export\n  exportTimeline(\n    targetHandle: FileSystemFileHandle,\n    options: any,\n    timelineClips: any[],\n    audioClips?: any[],\n  ): Promise<void>;\n\n  cancelExport(): Promise<void>;\n\n  extractFrameToBlob(\n    timeUs: number,\n    width: number,\n    height: number,\n    timelineClips: any[],\n    quality: number,\n  ): Promise<Blob | null>;\n}\n\nexport type WorkerCallbacks = {\n  // Functions the worker can call on the main thread\n  onExportProgress: (progress: number) => void;\n  onExportPhase?: (phase: 'encoding' | 'saving') => void;\n  getFileHandleByPath: (path: string) => Promise<FileSystemFileHandle | null>;\n};\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/utils/webcodecs.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":34,"messageId":"unexpectedAny","endLine":56,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1592,1595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1592,1595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":34,"messageId":"unexpectedAny","endLine":92,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2547,2550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2547,2550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface VideoCodecOption {\n  value: string;\n  label: string;\n}\n\nexport interface VideoCodecOptionResolved extends CodecOption {\n  disabled: boolean;\n}\n\nexport type CodecOption = VideoCodecOption;\nexport type AudioCodecOption = CodecOption;\nexport type AudioCodecOptionResolved = VideoCodecOptionResolved;\n\nexport const BASE_VIDEO_CODEC_OPTIONS: readonly VideoCodecOption[] = [\n  { value: 'avc1.640032', label: 'H.264 (High)' },\n  { value: 'vp09.00.10.08', label: 'VP9' },\n  { value: 'av01.0.05M.08', label: 'AV1' },\n];\n\nexport interface CheckVideoCodecSupportOptions {\n  width?: number;\n  height?: number;\n  framerate?: number;\n  bitrate?: number;\n}\n\nexport const BASE_AUDIO_CODEC_OPTIONS: readonly AudioCodecOption[] = [\n  { value: 'aac', label: 'AAC' },\n  { value: 'mp3', label: 'MP3' },\n  { value: 'opus', label: 'Opus' },\n  { value: 'vorbis', label: 'Vorbis' },\n  { value: 'alac', label: 'ALAC' },\n];\n\nexport interface CheckAudioCodecSupportOptions {\n  sampleRate?: number;\n  numberOfChannels?: number;\n  bitrate?: number;\n}\n\n/**\n * Checks which of the given codec options are supported by the current browser\n * via the WebCodecs VideoEncoder API.\n * Returns a map of codec string â supported boolean.\n * If VideoEncoder is unavailable, returns an empty map (all treated as unknown/enabled).\n */\nexport async function checkVideoCodecSupport(\n  codecs: readonly VideoCodecOption[],\n  {\n    width = 1280,\n    height = 720,\n    framerate = 30,\n    bitrate = 5_000_000,\n  }: CheckVideoCodecSupportOptions = {},\n): Promise<Record<string, boolean>> {\n  const encoder = (globalThis as any).VideoEncoder;\n  if (!encoder?.isConfigSupported) return {};\n\n  const entries = await Promise.all(\n    codecs.map(async (opt) => {\n      try {\n        const result = await encoder.isConfigSupported({\n          codec: opt.value,\n          width,\n          height,\n          framerate,\n          bitrate,\n        });\n        return [opt.value, !!result?.supported] as const;\n      } catch {\n        return [opt.value, false] as const;\n      }\n    }),\n  );\n\n  return Object.fromEntries(entries);\n}\n\n/**\n * Checks which of the given codec options are supported by the current browser\n * via the WebCodecs AudioEncoder API.\n * Returns a map of codec string â supported boolean.\n */\nexport async function checkAudioCodecSupport(\n  codecs: readonly AudioCodecOption[],\n  {\n    sampleRate = 48000,\n    numberOfChannels = 2,\n    bitrate = 128_000,\n  }: CheckAudioCodecSupportOptions = {},\n): Promise<Record<string, boolean>> {\n  const encoder = (globalThis as any).AudioEncoder;\n  if (!encoder?.isConfigSupported) return {};\n\n  const entries = await Promise.all(\n    codecs.map(async (opt) => {\n      try {\n        const result = await encoder.isConfigSupported({\n          codec: opt.value,\n          sampleRate,\n          numberOfChannels,\n          bitrate,\n        });\n        return [opt.value, !!result?.supported] as const;\n      } catch {\n        return [opt.value, false] as const;\n      }\n    }),\n  );\n\n  return Object.fromEntries(entries);\n}\n\n/**\n * Merges codec options with a support map to produce options with `disabled` flag.\n * An option is disabled only when its support is explicitly `false`\n * (unknown / not yet checked = enabled).\n */\nexport function resolveVideoCodecOptions(\n  codecs: readonly VideoCodecOption[],\n  support: Record<string, boolean>,\n): VideoCodecOptionResolved[] {\n  return codecs.map((opt) => ({\n    ...opt,\n    disabled: support[opt.value] === false,\n  }));\n}\n\nexport function resolveAudioCodecOptions(\n  codecs: readonly AudioCodecOption[],\n  support: Record<string, boolean>,\n): AudioCodecOptionResolved[] {\n  return codecs.map((opt) => ({\n    ...opt,\n    disabled: support[opt.value] === false,\n  }));\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/audio-decode.worker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":85,"messageId":"unexpectedAny","endLine":29,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[742,745],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[742,745],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":15,"messageId":"unexpectedAny","endLine":35,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[892,895],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[892,895],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":46,"messageId":"unexpectedAny","endLine":51,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1435,1438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1435,1438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":37,"messageId":"unexpectedAny","endLine":52,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1508,1511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1508,1511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":27,"messageId":"unexpectedAny","endLine":99,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3075,3078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3075,3078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":63,"messageId":"unexpectedAny","endLine":99,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3111,3114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3111,3114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":27,"messageId":"unexpectedAny","endLine":100,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3151,3154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3151,3154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":65,"messageId":"unexpectedAny","endLine":100,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3189,3192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3189,3192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":48,"messageId":"unexpectedAny","endLine":103,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3272,3275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3272,3275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":17,"messageId":"unexpectedAny","endLine":104,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3317,3320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3317,3320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":51,"messageId":"unexpectedAny","endLine":105,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3383,3386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3383,3386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":88,"messageId":"unexpectedAny","endLine":105,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3420,3423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3420,3423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":14,"messageId":"unexpectedAny","endLine":165,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4954,4957],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4954,4957],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":17,"messageId":"unexpectedAny","endLine":166,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5026,5029],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5026,5029],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":14,"messageId":"unexpectedAny","endLine":173,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5193,5196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5193,5196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AudioSampleSink, BlobSource, Input, ALL_FORMATS } from 'mediabunny';\n\ninterface DecodeRequest {\n  type: 'decode' | 'extract-peaks';\n  id: number;\n  sourceKey: string;\n  arrayBuffer: ArrayBuffer;\n  options?: {\n    maxLength?: number;\n    precision?: number;\n  };\n}\n\ninterface DecodeResponse {\n  type: 'decode-result';\n  id: number;\n  ok: boolean;\n  error?: { name?: string; message: string; stack?: string };\n  result?: {\n    sampleRate: number;\n    numberOfChannels: number;\n    channelBuffers: ArrayBuffer[];\n    peaks?: number[][];\n  };\n}\n\nasync function decodeToFloat32Channels(arrayBuffer: ArrayBuffer) {\n  const blob = new Blob([arrayBuffer]);\n  const input = new Input({ source: new BlobSource(blob), formats: ALL_FORMATS } as any);\n\n  try {\n    const aTrack = await input.getPrimaryAudioTrack();\n    if (!aTrack) {\n      const err = new Error('No audio track');\n      (err as any).name = 'NoAudioTrackError';\n      throw err;\n    }\n    if (!(await aTrack.canDecode())) throw new Error('Audio track cannot be decoded');\n\n    const sink = new AudioSampleSink(aTrack);\n    try {\n      const metaDurationS = await input.computeDuration();\n      const durationS = Number.isFinite(metaDurationS) && metaDurationS > 0 ? metaDurationS : 0;\n\n      let sampleRate = 48000;\n      let numberOfChannels = 2;\n\n      const channelChunks: Float32Array[][] = [];\n      let totalFrames = 0;\n\n      for await (const sampleRaw of (sink as any).samples(0, durationS || 1e9)) {\n        const sample = sampleRaw as any;\n        try {\n          sampleRate = sample.sampleRate;\n          numberOfChannels = sample.numberOfChannels;\n\n          if (channelChunks.length !== numberOfChannels) {\n            channelChunks.length = 0;\n            for (let ch = 0; ch < numberOfChannels; ch += 1) channelChunks.push([]);\n            totalFrames = 0;\n          }\n\n          const frames = Number(sample.numberOfFrames) || 0;\n          if (frames > 0) {\n            for (let ch = 0; ch < numberOfChannels; ch += 1) {\n              const bytesNeeded = sample.allocationSize({ format: 'f32-planar', planeIndex: ch });\n              const chunk = new Float32Array(bytesNeeded / 4);\n              sample.copyTo(chunk, { format: 'f32-planar', planeIndex: ch });\n              if (chunk.length > 0) {\n                channelChunks[ch]?.push(chunk);\n              }\n            }\n            totalFrames += frames;\n          }\n        } finally {\n          if (typeof sample.close === 'function') sample.close();\n        }\n      }\n\n      if (totalFrames <= 0) throw new Error('Decoded audio is empty');\n\n      const channelBuffers = channelChunks.map((chunks) => {\n        const combined = new Float32Array(totalFrames);\n        let offset = 0;\n        for (const chunk of chunks) {\n          if (!chunk.length) continue;\n          combined.set(chunk, offset);\n          offset += chunk.length;\n        }\n        return combined.buffer as ArrayBuffer;\n      });\n\n      return {\n        sampleRate,\n        numberOfChannels,\n        channelBuffers,\n      };\n    } finally {\n      if (typeof (sink as any).close === 'function') (sink as any).close();\n      if (typeof (sink as any).dispose === 'function') (sink as any).dispose();\n    }\n  } finally {\n    if ('dispose' in input && typeof (input as any).dispose === 'function')\n      (input as any).dispose();\n    else if ('close' in input && typeof (input as any).close === 'function') (input as any).close();\n  }\n}\n\nfunction extractPeaks(\n  channelBuffers: ArrayBuffer[],\n  options?: { maxLength?: number; precision?: number },\n): number[][] {\n  const maxLength = options?.maxLength || 8000;\n  const precision = options?.precision || 10000;\n  const peaks: number[][] = [];\n\n  for (const buffer of channelBuffers) {\n    const channel = new Float32Array(buffer);\n    const data: number[] = [];\n    const sampleSize = channel.length / maxLength;\n\n    for (let j = 0; j < maxLength; j++) {\n      const start = Math.floor(j * sampleSize);\n      const end = Math.ceil((j + 1) * sampleSize);\n      let max = 0;\n\n      for (let x = start; x < end && x < channel.length; x++) {\n        const n = channel[x];\n        if (n !== undefined && Math.abs(n) > Math.abs(max)) {\n          max = n;\n        }\n      }\n      data.push(Math.round(max * precision) / precision);\n    }\n    peaks.push(data);\n  }\n\n  return peaks;\n}\n\nself.addEventListener('message', async (event: MessageEvent<DecodeRequest>) => {\n  const data = event.data;\n  if (!data || (data.type !== 'decode' && data.type !== 'extract-peaks')) return;\n\n  const response: DecodeResponse = {\n    type: 'decode-result',\n    id: data.id,\n    ok: false,\n  };\n\n  try {\n    const result = await decodeToFloat32Channels(data.arrayBuffer);\n\n    let peaks: number[][] | undefined;\n    if (data.type === 'extract-peaks') {\n      peaks = extractPeaks(result.channelBuffers, data.options);\n    }\n\n    response.ok = true;\n    response.result = {\n      ...result,\n      peaks,\n    };\n\n    (self as any).postMessage(response, [...result.channelBuffers]);\n  } catch (err: any) {\n    response.ok = false;\n    response.error = {\n      name: err?.name,\n      message: err?.message || String(err),\n      stack: err?.stack,\n    };\n    (self as any).postMessage(response);\n  }\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/AudioMixer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":36,"messageId":"unexpectedAny","endLine":86,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2536,2539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2536,2539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":26,"messageId":"unexpectedAny","endLine":87,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2598,2601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2598,2601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":31,"messageId":"unexpectedAny","endLine":88,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2655,2658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2655,2658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":18,"messageId":"unexpectedAny","endLine":89,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2691,2694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2691,2694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-extraneous-class","severity":1,"message":"Unexpected class with only static properties.","line":111,"column":14,"messageId":"onlyStatic","endLine":111,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":22,"messageId":"unexpectedAny","endLine":121,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3665,3668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3665,3668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":89,"messageId":"unexpectedAny","endLine":179,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6036,6039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6036,6039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":43,"messageId":"unexpectedAny","endLine":194,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6442,6445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6442,6445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":219,"column":16,"messageId":"unusedVar","endLine":219,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":20,"messageId":"unexpectedAny","endLine":248,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7885,7888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7885,7888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":350,"column":16,"messageId":"unusedVar","endLine":350,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":33,"messageId":"unexpectedAny","endLine":386,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13101,13104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13101,13104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { MAX_AUDIO_FILE_BYTES } from '../../utils/constants';\nimport { safeDispose } from '../../utils/video-editor/utils';\nimport type { VideoCoreHostAPI } from '../../utils/video-editor/worker-client';\nimport { getGainAtClipTime, normalizeBalance, normalizeGain } from '../../utils/audio/envelope';\nimport { clampFloat32 } from './utils';\nimport { usToS } from './time';\n\nexport function interleavedToPlanar(params: {\n  interleaved: Float32Array;\n  frames: number;\n  numberOfChannels: number;\n}): Float32Array {\n  const { interleaved, frames, numberOfChannels } = params;\n  const planar = new Float32Array(frames * numberOfChannels);\n  for (let i = 0; i < frames; i += 1) {\n    for (let c = 0; c < numberOfChannels; c += 1) {\n      planar[c * frames + i] = interleaved[i * numberOfChannels + c] ?? 0;\n    }\n  }\n  return planar;\n}\n\nexport interface PreparedClip {\n  clipStartS: number;\n  offsetS: number;\n  playDurationS: number;\n  input: MediabunnyInput;\n  sink: MediabunnyAudioSampleSink;\n  sourcePath: string;\n  audioGain: number;\n  audioBalance: number;\n  audioFadeInS: number;\n  audioFadeOutS: number;\n}\n\ninterface MediabunnyInput {\n  getPrimaryAudioTrack(): Promise<MediabunnyAudioTrack | null>;\n}\n\ninterface MediabunnyAudioTrack {\n  canDecode(): Promise<boolean>;\n  duration?: number;\n}\n\ninterface MediabunnyAudioSampleSink {\n  samples(startS: number, endS: number): AsyncIterable<MediabunnyAudioSample>;\n}\n\ninterface MediabunnyAudioSample {\n  numberOfFrames: number;\n  sampleRate: number;\n  numberOfChannels: number;\n  timestamp: number;\n  allocationSize(options: { format: 'f32-planar'; planeIndex: number }): number;\n  copyTo(dst: Float32Array, options: { format: 'f32-planar'; planeIndex: number }): void;\n}\n\ninterface AudioClipData {\n  sourcePath?: string;\n  source?: { path?: string };\n  fileHandle?: FileSystemFileHandle;\n  timelineRange?: { startUs?: number; durationUs?: number };\n  sourceRange?: { startUs?: number; durationUs?: number };\n  startUs?: number;\n  durationUs?: number;\n  sourceStartUs?: number;\n  sourceDurationUs?: number;\n  audioGain?: number;\n  audioBalance?: number;\n  audioFadeInUs?: number;\n  audioFadeOutUs?: number;\n  gran?: {\n    audioGain?: number;\n    audioBalance?: number;\n    audioFadeInUs?: number;\n    audioFadeOutUs?: number;\n  };\n}\n\nexport interface AudioMixerPrepareParams {\n  audioClips: AudioClipData[];\n  hostClient: VideoCoreHostAPI | null;\n  reportExportWarning: (message: string) => Promise<void>;\n  checkCancel?: () => boolean;\n  mediabunny: {\n    AudioSampleSink: new (...args: any[]) => MediabunnyAudioSampleSink;\n    Input: new (...args: any[]) => MediabunnyInput;\n    BlobSource: new (...args: any[]) => unknown;\n    ALL_FORMATS: any;\n  };\n}\n\nexport interface AudioMixerWriteParams {\n  prepared: PreparedClip[];\n  durationS: number;\n  audioSource: { add(sample: unknown): Promise<void> };\n  chunkDurationS: number;\n  sampleRate: number;\n  numberOfChannels: number;\n  reportExportWarning: (message: string) => Promise<void>;\n  checkCancel?: () => boolean;\n  AudioSample: new (params: {\n    data: Float32Array;\n    format: 'f32-planar';\n    numberOfChannels: number;\n    sampleRate: number;\n    timestamp: number;\n  }) => unknown;\n}\n\nexport class AudioMixer {\n  static async prepareClips(params: AudioMixerPrepareParams): Promise<PreparedClip[]> {\n    const { audioClips, hostClient, reportExportWarning, checkCancel } = params;\n    const { AudioSampleSink, Input, BlobSource, ALL_FORMATS } = params.mediabunny;\n\n    const prepared: PreparedClip[] = [];\n\n    for (const clipData of audioClips) {\n      if (checkCancel?.()) {\n        const abortErr = new Error('Export was cancelled');\n        (abortErr as any).name = 'AbortError';\n        throw abortErr;\n      }\n\n      const sourcePath = clipData.sourcePath || clipData.source?.path;\n      if (!sourcePath) continue;\n\n      let fileHandle: FileSystemFileHandle | null = clipData.fileHandle || null;\n      if (!fileHandle && hostClient) {\n        fileHandle = await hostClient.getFileHandleByPath(sourcePath);\n      }\n      if (!fileHandle) continue;\n\n      let file: File;\n      try {\n        file = await fileHandle.getFile();\n      } catch {\n        await reportExportWarning('[Worker Export] Failed to read audio file handle');\n        continue;\n      }\n\n      if (file.size > MAX_AUDIO_FILE_BYTES) {\n        await reportExportWarning(\n          '[Worker Export] Audio file is too large to decode in memory; skipping audio clip.',\n        );\n        continue;\n      }\n\n      const startUs = clipData.startUs ?? clipData.timelineRange?.startUs ?? 0;\n      const sourceStartUs = clipData.sourceStartUs ?? clipData.sourceRange?.startUs ?? 0;\n      const sourceDurationUs = clipData.sourceDurationUs ?? clipData.sourceRange?.durationUs ?? 0;\n      const durationUs = clipData.durationUs ?? clipData.timelineRange?.durationUs ?? 0;\n\n      const audioFadeInUs = clipData.audioFadeInUs ?? clipData.gran?.audioFadeInUs ?? 0;\n      const audioFadeOutUs = clipData.audioFadeOutUs ?? clipData.gran?.audioFadeOutUs ?? 0;\n\n      const clipStartS = Math.max(0, usToS(Number(startUs)));\n      const rawOffsetS = Math.max(0, usToS(Number(sourceStartUs)));\n      const sourceDurationS = Math.max(0, usToS(Number(sourceDurationUs)));\n      const timelineDurationS = Math.max(0, usToS(Number(durationUs)));\n      const clipDurationS = Math.max(\n        0,\n        Math.min(sourceDurationS || Number.POSITIVE_INFINITY, timelineDurationS || sourceDurationS),\n      );\n      if (clipDurationS <= 0) continue;\n\n      const audioFadeInS = Math.min(clipDurationS, Math.max(0, usToS(Number(audioFadeInUs) || 0)));\n      const audioFadeOutS = Math.min(\n        clipDurationS,\n        Math.max(0, usToS(Number(audioFadeOutUs) || 0)),\n      );\n\n      const audioGain = normalizeGain(clipData.audioGain ?? clipData.gran?.audioGain, 1);\n      const audioBalance = normalizeBalance(\n        clipData.audioBalance ?? clipData.gran?.audioBalance,\n        0,\n      );\n\n      const input = new Input({ source: new BlobSource(file), formats: ALL_FORMATS } as any);\n      try {\n        const aTrack = await input.getPrimaryAudioTrack();\n        if (!aTrack) {\n          safeDispose(input);\n          continue;\n        }\n        if (!(await aTrack.canDecode())) {\n          safeDispose(input);\n          continue;\n        }\n\n        const sink = new AudioSampleSink(aTrack);\n\n        const offsetS = Math.max(0, rawOffsetS);\n        const trackDurationS = (aTrack as any).duration;\n        const maxPlayableS = Math.max(\n          0,\n          (Number.isFinite(trackDurationS) ? Number(trackDurationS) : Number.POSITIVE_INFINITY) -\n            offsetS,\n        );\n        const playDurationS = Math.min(clipDurationS, maxPlayableS);\n        if (playDurationS <= 0) {\n          safeDispose(sink);\n          safeDispose(input);\n          continue;\n        }\n\n        prepared.push({\n          clipStartS,\n          offsetS,\n          playDurationS,\n          input,\n          sink,\n          sourcePath,\n          audioGain,\n          audioBalance,\n          audioFadeInS,\n          audioFadeOutS,\n        });\n      } catch (err) {\n        await reportExportWarning('[Worker Export] Failed to decode audio clip');\n        safeDispose(input);\n      }\n    }\n\n    return prepared;\n  }\n\n  static async writeMixedToSource(params: AudioMixerWriteParams): Promise<void> {\n    const {\n      prepared,\n      durationS,\n      audioSource,\n      chunkDurationS,\n      sampleRate,\n      numberOfChannels,\n      reportExportWarning,\n      checkCancel,\n      AudioSample,\n    } = params;\n\n    const chunkFrames = sampleRate * chunkDurationS;\n    const totalFrames = Math.ceil(durationS * sampleRate);\n    const totalChunks = Math.max(1, Math.ceil(totalFrames / chunkFrames));\n\n    function ensureNotCancelled() {\n      if (!checkCancel?.()) return;\n      const abortErr = new Error('Export was cancelled');\n      (abortErr as any).name = 'AbortError';\n      throw abortErr;\n    }\n\n    async function mixClipIntoChunk(args: {\n      clip: PreparedClip;\n      chunkStartS: number;\n      chunkEndS: number;\n      framesInChunk: number;\n      mixedInterleaved: Float32Array;\n    }) {\n      const { clip, chunkStartS, chunkEndS, framesInChunk, mixedInterleaved } = args;\n\n      const fadeInS = clip.audioFadeInS;\n      const fadeOutS = clip.audioFadeOutS;\n\n      const audioGain = clip.audioGain;\n      const audioBalance = clip.audioBalance;\n\n      const hasStereoPan = numberOfChannels === 2;\n      const leftScale = hasStereoPan ? Math.max(0, Math.min(1, 1 - Math.max(0, audioBalance))) : 1;\n      const rightScale = hasStereoPan ? Math.max(0, Math.min(1, 1 + Math.min(0, audioBalance))) : 1;\n\n      function gainAtClipTimeS(tClipS: number): number {\n        return getGainAtClipTime({\n          clipDurationS: clip.playDurationS,\n          fadeInS,\n          fadeOutS,\n          baseGain: audioGain,\n          tClipS,\n        });\n      }\n\n      const clipGlobalStartS = clip.clipStartS;\n      const clipGlobalEndS = clip.clipStartS + clip.playDurationS;\n      const overlapStartS = Math.max(chunkStartS, clipGlobalStartS);\n      const overlapEndS = Math.min(chunkEndS, clipGlobalEndS);\n      if (overlapEndS <= overlapStartS) return;\n\n      const clipLocalStartS = overlapStartS - clipGlobalStartS;\n      const clipLocalEndS = overlapEndS - clipGlobalStartS;\n      const sinkStartS = clip.offsetS + clipLocalStartS;\n      const sinkEndS = clip.offsetS + clipLocalEndS;\n\n      try {\n        for await (const sampleRaw of clip.sink.samples(sinkStartS, sinkEndS)) {\n          ensureNotCancelled();\n\n          const sample = sampleRaw as MediabunnyAudioSample;\n          try {\n            const frames = Number(sample.numberOfFrames) || 0;\n            const sr = Number(sample.sampleRate) || 0;\n            const ch = Number(sample.numberOfChannels) || 0;\n\n            if (frames <= 0) continue;\n            if (sr !== sampleRate || ch !== numberOfChannels) {\n              await reportExportWarning(\n                '[Worker Export] Audio clip sample format mismatch; skipping some audio.',\n              );\n              continue;\n            }\n\n            const timelineTimeS = clip.clipStartS + (Number(sample.timestamp) - clip.offsetS);\n            if (!Number.isFinite(timelineTimeS)) continue;\n\n            const startFrameGlobal = Math.floor(timelineTimeS * sampleRate);\n            const startFrameInChunkGlobal = Math.floor(chunkStartS * sampleRate);\n            const writeOffsetFrames = startFrameGlobal - startFrameInChunkGlobal;\n            if (writeOffsetFrames >= framesInChunk) continue;\n\n            const tmpPlanes: Float32Array[] = [];\n            for (let planeIndex = 0; planeIndex < numberOfChannels; planeIndex += 1) {\n              const bytesNeeded = sample.allocationSize({\n                format: 'f32-planar',\n                planeIndex,\n              });\n              const plane = new Float32Array(bytesNeeded / 4);\n              sample.copyTo(plane, { format: 'f32-planar', planeIndex });\n              tmpPlanes.push(plane);\n            }\n\n            for (let i = 0; i < frames; i += 1) {\n              const dstFrame = writeOffsetFrames + i;\n              if (dstFrame < 0) continue;\n              if (dstFrame >= framesInChunk) break;\n\n              const tClipS = timelineTimeS + i / sampleRate - clip.clipStartS;\n              const gain = gainAtClipTimeS(tClipS);\n\n              for (let c = 0; c < numberOfChannels; c += 1) {\n                const plane = tmpPlanes[c];\n                const panScale =\n                  hasStereoPan && c === 0 ? leftScale : hasStereoPan && c === 1 ? rightScale : 1;\n                const v = (plane ? (plane[i] ?? 0) : 0) * gain * panScale;\n                const idx = dstFrame * numberOfChannels + c;\n                mixedInterleaved[idx] = clampFloat32(mixedInterleaved[idx]! + v);\n              }\n            }\n          } finally {\n            safeDispose(sample);\n          }\n        }\n      } catch (err) {\n        await reportExportWarning('[Worker Export] Failed to decode audio clip');\n      }\n    }\n\n    try {\n      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex += 1) {\n        ensureNotCancelled();\n\n        const chunkStartS = chunkIndex * chunkDurationS;\n        const chunkEndS = Math.min(durationS, chunkStartS + chunkDurationS);\n        const framesInChunk = Math.min(chunkFrames, totalFrames - chunkIndex * chunkFrames);\n        if (framesInChunk <= 0) continue;\n\n        const mixedInterleaved = new Float32Array(framesInChunk * numberOfChannels);\n\n        for (const clip of prepared) {\n          ensureNotCancelled();\n          await mixClipIntoChunk({ clip, chunkStartS, chunkEndS, framesInChunk, mixedInterleaved });\n        }\n\n        const planar = interleavedToPlanar({\n          interleaved: mixedInterleaved,\n          frames: framesInChunk,\n          numberOfChannels,\n        });\n\n        const audioSample = new AudioSample({\n          data: planar,\n          format: 'f32-planar',\n          numberOfChannels,\n          sampleRate,\n          timestamp: chunkStartS,\n        });\n\n        try {\n          await (audioSource as any).add(audioSample);\n        } finally {\n          safeDispose(audioSample);\n        }\n      }\n    } finally {\n      for (const clip of prepared) {\n        safeDispose(clip.sink);\n        safeDispose(clip.input);\n      }\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/audio.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":12,"messageId":"unexpectedAny","endLine":6,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[225,228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[225,228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":15,"messageId":"unexpectedAny","endLine":7,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[244,247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[244,247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { VideoCoreHostAPI } from '../../utils/video-editor/worker-client';\nimport { getBunnyAudioCodec } from './utils';\nimport { AudioMixer } from './AudioMixer';\n\nexport async function buildMixedAudioTrack(\n  options: any,\n  audioClips: any[],\n  durationS: number,\n  hostClient: VideoCoreHostAPI | null,\n  reportExportWarning: (message: string) => Promise<void>,\n  checkCancel?: () => boolean,\n) {\n  const { AudioSampleSink, AudioSampleSource, Input, BlobSource, ALL_FORMATS } =\n    await import('mediabunny');\n\n  const sampleRate = options.audioSampleRate || 48000;\n  const numberOfChannels = options.audioChannels === 'mono' ? 1 : 2;\n\n  const prepared = await AudioMixer.prepareClips({\n    audioClips,\n    hostClient,\n    reportExportWarning,\n    checkCancel,\n    mediabunny: {\n      AudioSampleSink,\n      Input,\n      BlobSource,\n      ALL_FORMATS,\n    },\n  });\n\n  if (prepared.length === 0) return null;\n\n  const audioSource = new AudioSampleSource({\n    codec: getBunnyAudioCodec(options.audioCodec),\n    bitrate: options.audioBitrate,\n  });\n\n  const chunkDurationS = 1;\n\n  async function writeMixedToSource() {\n    const { AudioSample } = await import('mediabunny');\n    await AudioMixer.writeMixedToSource({\n      prepared,\n      durationS,\n      audioSource,\n      chunkDurationS,\n      sampleRate,\n      numberOfChannels,\n      reportExportWarning,\n      checkCancel,\n      AudioSample,\n    });\n  }\n\n  return {\n    audioSource,\n    writeMixedToSource,\n    numberOfChannels,\n    sampleRate,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/export-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":38,"messageId":"unexpectedAny","endLine":9,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[176,179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[176,179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":50,"messageId":"unexpectedAny","endLine":26,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[822,825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[822,825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { usToS } from './time';\n\nexport interface ClipRangesS {\n  timelineStartS: number;\n  sourceStartS: number;\n  sourceEndS: number;\n}\n\nexport function getClipRangesS(clip: any): ClipRangesS {\n  const timelineStartUs = Number(clip.timelineRange?.startUs || 0);\n  const timelineDurationUs = Number(clip.timelineRange?.durationUs || 0);\n  const sourceStartUs = Number(clip.sourceRange?.startUs || 0);\n  const sourceDurationUs = Number(clip.sourceRange?.durationUs || timelineDurationUs || 0);\n\n  const timelineStartS = Math.max(0, usToS(timelineStartUs));\n  const sourceStartS = Math.max(0, usToS(sourceStartUs));\n  const durationS = Math.max(0, usToS(sourceDurationUs));\n\n  return {\n    timelineStartS,\n    sourceStartS,\n    sourceEndS: sourceStartS + durationS,\n  };\n}\n\nexport function computeMaxAudioDurationUs(clips: any[]): number {\n  return clips.reduce((max, clip) => {\n    const endUs =\n      Number(clip.timelineRange?.startUs || 0) + Number(clip.timelineRange?.durationUs || 0);\n    return Math.max(max, endUs);\n  }, 0);\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/export.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":65,"messageId":"unexpectedAny","endLine":27,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1070,1073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1070,1073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":19,"messageId":"unexpectedAny","endLine":34,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1275,1278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1275,1278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":9,"messageId":"unexpectedAny","endLine":87,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2853,2856],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2853,2856],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":85,"messageId":"unexpectedAny","endLine":101,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3502,3505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3502,3505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":12,"messageId":"unexpectedAny","endLine":134,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4467,4470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4467,4470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":18,"messageId":"unexpectedAny","endLine":135,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4489,4492],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4489,4492],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":15,"messageId":"unexpectedAny","endLine":136,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4510,4513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4510,4513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":18,"messageId":"unexpectedAny","endLine":150,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4957,4960],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4957,4960],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":28,"messageId":"unexpectedAny","endLine":157,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5120,5123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5120,5123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":49,"messageId":"unexpectedAny","endLine":163,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5238,5241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5238,5241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":75,"messageId":"unexpectedAny","endLine":163,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5264,5267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5264,5267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":90,"messageId":"unexpectedAny","endLine":163,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5279,5282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5279,5282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":45,"messageId":"unexpectedAny","endLine":164,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5332,5335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5332,5335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":47,"messageId":"unexpectedAny","endLine":174,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5645,5648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5645,5648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":62,"messageId":"unexpectedAny","endLine":174,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5660,5663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5660,5663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":29,"messageId":"unexpectedAny","endLine":177,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5748,5751],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5748,5751],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":26,"messageId":"unexpectedAny","endLine":178,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5803,5806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5803,5806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":31,"messageId":"unexpectedAny","endLine":185,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5903,5906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5903,5906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":28,"messageId":"unexpectedAny","endLine":186,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5959,5962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5959,5962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":20,"messageId":"unexpectedAny","endLine":195,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6121,6124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6121,6124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":196,"column":19,"messageId":"unexpectedAny","endLine":196,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6144,6147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6144,6147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":22,"messageId":"unexpectedAny","endLine":197,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6170,6173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6170,6173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":14,"messageId":"unexpectedAny","endLine":199,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6272,6275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6272,6275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":58,"messageId":"unexpectedAny","endLine":232,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7541,7544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7541,7544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":24,"messageId":"unexpectedAny","endLine":233,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7593,7596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7593,7596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":18,"messageId":"unexpectedAny","endLine":242,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7749,7752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7749,7752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":261,"column":38,"messageId":"unexpectedAny","endLine":261,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8469,8472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8469,8472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":70,"messageId":"unexpectedAny","endLine":322,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10571,10574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10571,10574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":24,"messageId":"unexpectedAny","endLine":330,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10809,10812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10809,10812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":335,"column":22,"messageId":"unexpectedAny","endLine":335,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11016,11019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11016,11019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":21,"messageId":"unexpectedAny","endLine":336,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11041,11044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11041,11044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":24,"messageId":"unexpectedAny","endLine":337,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11069,11072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11069,11072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":16,"messageId":"unexpectedAny","endLine":339,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11175,11178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11175,11178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'audioSampleRate' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":370,"column":13,"messageId":"unusedVar","endLine":370,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'audioNumberOfChannels' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":371,"column":13,"messageId":"unusedVar","endLine":371,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":397,"column":53,"messageId":"unexpectedAny","endLine":397,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12988,12991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12988,12991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":398,"column":68,"messageId":"unexpectedAny","endLine":398,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13069,13072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13069,13072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":411,"column":14,"messageId":"unusedVar","endLine":411,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e2' is defined but never used.","line":417,"column":16,"messageId":"unusedVar","endLine":417,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":39,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { VideoCoreHostAPI } from '../../utils/video-editor/worker-client';\nimport { VideoCompositor } from '../../utils/video-editor/VideoCompositor';\nimport { safeDispose } from '../../utils/video-editor/utils';\nimport { parseVideoCodec, parseAudioCodec, getBunnyVideoCodec } from './utils';\nimport { buildMixedAudioTrack } from './audio';\nimport { computeMaxAudioDurationUs, getClipRangesS } from './export-helpers';\nimport { usToS } from './time';\nimport { initEffects } from '../../effects';\nimport { initTransitions } from '../../transitions';\n\nexport async function extractMetadata(fileHandle: FileSystemFileHandle) {\n  const file = await fileHandle.getFile();\n\n  if (typeof file?.type === 'string' && file.type.startsWith('image/')) {\n    return {\n      source: {\n        size: file.size,\n        lastModified: file.lastModified,\n      },\n      duration: 0,\n    };\n  }\n\n  try {\n    const { Input, BlobSource, ALL_FORMATS } = await import('mediabunny');\n    const source = new BlobSource(file);\n    const input = new Input({ source, formats: ALL_FORMATS } as any);\n\n    try {\n      const durationS = await input.computeDuration();\n      const vTrack = await input.getPrimaryVideoTrack();\n      const aTrack = await input.getPrimaryAudioTrack();\n\n      const meta: any = {\n        source: {\n          size: file.size,\n          lastModified: file.lastModified,\n        },\n        duration: durationS,\n      };\n\n      if (vTrack) {\n        const stats = await vTrack.computePacketStats(100);\n        const codecParam = await vTrack.getCodecParameterString();\n        const colorSpace =\n          typeof vTrack.getColorSpace === 'function' ? await vTrack.getColorSpace() : undefined;\n\n        meta.video = {\n          width: vTrack.codedWidth,\n          height: vTrack.codedHeight,\n          displayWidth: vTrack.displayWidth,\n          displayHeight: vTrack.displayHeight,\n          rotation: vTrack.rotation,\n          codec: codecParam || vTrack.codec || '',\n          parsedCodec: parseVideoCodec(codecParam || vTrack.codec || ''),\n          fps: stats.averagePacketRate,\n          colorSpace,\n        };\n      }\n\n      if (aTrack) {\n        const codecParam = await aTrack.getCodecParameterString();\n        meta.audio = {\n          codec: codecParam || aTrack.codec || '',\n          parsedCodec: parseAudioCodec(codecParam || aTrack.codec || ''),\n          sampleRate: aTrack.sampleRate,\n          channels: aTrack.numberOfChannels,\n        };\n      }\n\n      return meta;\n    } finally {\n      safeDispose(input);\n    }\n  } catch (err) {\n    console.error('[Worker Export] Failed to extract metadata:', err);\n    throw err;\n  }\n}\n\nfunction isOpusCodec(codec: string | undefined): boolean {\n  const value = String(codec ?? '').toLowerCase();\n  return value.startsWith('opus');\n}\n\nasync function buildPassthroughAudioTrack(params: {\n  clip: any;\n  hostClient: VideoCoreHostAPI | null;\n  reportExportWarning: (message: string) => Promise<void>;\n}) {\n  const { clip, hostClient, reportExportWarning } = params;\n  const sourcePath = clip.sourcePath || clip.source?.path;\n  if (!sourcePath || !hostClient) return null;\n\n  const fileHandle = clip.fileHandle || (await hostClient.getFileHandleByPath(sourcePath));\n  if (!fileHandle) return null;\n\n  const file = await fileHandle.getFile();\n  const { Input, BlobSource, ALL_FORMATS, EncodedPacketSink, EncodedAudioPacketSource } =\n    await import('mediabunny');\n  const input = new Input({ source: new BlobSource(file), formats: ALL_FORMATS } as any);\n\n  try {\n    const audioTrack = await input.getPrimaryAudioTrack();\n    if (!audioTrack) return null;\n\n    const codecParam = await audioTrack.getCodecParameterString();\n    const codec = codecParam || audioTrack.codec || '';\n    if (!isOpusCodec(codec)) return null;\n\n    const decoderConfig = await audioTrack.getDecoderConfig();\n    if (!decoderConfig) {\n      await reportExportWarning(\n        '[Worker Export] Opus audio passthrough requires decoder config; falling back to re-encode.',\n      );\n      return null;\n    }\n\n    return {\n      audioSource: new EncodedAudioPacketSource('opus'),\n      packetSink: new EncodedPacketSink(audioTrack),\n      decoderConfig,\n      ranges: getClipRangesS(clip),\n      input,\n    } as const;\n  } catch (error) {\n    await reportExportWarning('[Worker Export] Failed to build Opus passthrough audio track.');\n    throw error;\n  }\n}\n\nexport async function runExport(\n  targetHandle: FileSystemFileHandle,\n  options: any,\n  timelineClips: any[],\n  audioClips: any[],\n  hostClient: VideoCoreHostAPI | null,\n  reportExportWarning: (msg: string) => Promise<void>,\n  checkCancel: () => boolean,\n) {\n  initEffects();\n  initTransitions();\n\n  const { Output, Mp4OutputFormat, WebMOutputFormat, MkvOutputFormat, CanvasSource, StreamTarget } =\n    await import('mediabunny');\n\n  function ensureNotCancelled() {\n    if (!checkCancel()) return;\n    const abortErr = new Error('Export was cancelled');\n    (abortErr as any).name = 'AbortError';\n    throw abortErr;\n  }\n\n  async function notifyPhase(phase: string) {\n    if (!hostClient) return;\n    try {\n      await (hostClient as any).onExportPhase?.(phase);\n    } catch {\n      // ignore\n    }\n  }\n\n  async function createOutput(params: { format: any }): Promise<{ output: any; writable: any }> {\n    const writable = await (targetHandle as any).createWritable({ keepExistingData: false });\n\n    const target = new StreamTarget(writable, {\n      chunked: true,\n      chunkSize: 16 * 1024 * 1024,\n    });\n    const output = new Output({ target, format: params.format });\n    return { output, writable };\n  }\n\n  async function safeCancel(params: { output: any; writable: any }) {\n    const { output, writable } = params;\n    try {\n      if (typeof (output as any).cancel === 'function') {\n        await (output as any).cancel();\n      }\n    } catch {\n      // ignore\n    }\n\n    try {\n      if (typeof (writable as any).abort === 'function') {\n        await (writable as any).abort();\n      }\n    } catch {\n      // ignore\n    }\n  }\n\n  async function writeOpusPassthroughIfNeeded(params: {\n    audioPacketState: {\n      audioSource: any;\n      packetSink: any;\n      decoderConfig: any;\n      ranges: { timelineStartS: number; sourceStartS: number; sourceEndS: number };\n      input: any;\n    } | null;\n  }) {\n    const audioPacketState = params.audioPacketState;\n    if (!audioPacketState) return;\n\n    const { packetSink, decoderConfig, ranges, input } = audioPacketState;\n    let isFirstPacket = true;\n    try {\n      for await (const packet of packetSink.packets()) {\n        ensureNotCancelled();\n        const packetStart = Number(packet.timestamp || 0);\n        const packetDuration = Number(packet.duration || 0);\n        const packetEnd = packetStart + packetDuration;\n        if (packetEnd <= ranges.sourceStartS) continue;\n        if (packetStart >= ranges.sourceEndS) break;\n\n        const adjustedTimestamp = packetStart - ranges.sourceStartS + ranges.timelineStartS;\n        const adjustedPacket = packet.clone({ timestamp: adjustedTimestamp });\n        if (isFirstPacket) {\n          await audioPacketState.audioSource.add(adjustedPacket, { decoderConfig });\n          isFirstPacket = false;\n        } else {\n          await audioPacketState.audioSource.add(adjustedPacket);\n        }\n      }\n\n      if (isFirstPacket) {\n        await reportExportWarning(\n          '[Worker Export] No audio packets in selected range; exporting without audio.',\n        );\n      }\n    } finally {\n      if ('close' in packetSink && typeof (packetSink as any).close === 'function') {\n        (packetSink as any).close();\n      }\n      safeDispose(input);\n    }\n  }\n\n  async function encodeFrames(params: {\n    durationS: number;\n    fps: number;\n    videoSource: any;\n    compositor: VideoCompositor;\n  }) {\n    const fps = Math.max(1, Math.round(Number(params.fps) || 30));\n    const totalFrames = Math.ceil(params.durationS * fps);\n    const dtUs = Math.floor(1_000_000 / fps);\n    const dtS = usToS(dtUs);\n    let currentTimeUs = 0;\n\n    let lastYieldAtMs = typeof performance !== 'undefined' ? performance.now() : Date.now();\n    let lastProgressAtMs = lastYieldAtMs;\n    const yieldIntervalMs = 16;\n    const progressIntervalMs = 250;\n\n    for (let frameNum = 0; frameNum < totalFrames; frameNum++) {\n      ensureNotCancelled();\n\n      const generatedCanvas = await params.compositor.renderFrame(currentTimeUs);\n      if (generatedCanvas) {\n        await (params.videoSource as any).add(usToS(currentTimeUs), dtS);\n      }\n      currentTimeUs += dtUs;\n\n      const progress = Math.min(100, Math.round(((frameNum + 1) / totalFrames) * 100));\n      const nowProgressMs = typeof performance !== 'undefined' ? performance.now() : Date.now();\n      const shouldReport =\n        frameNum + 1 === totalFrames || nowProgressMs - lastProgressAtMs >= progressIntervalMs;\n      if (hostClient && shouldReport) {\n        lastProgressAtMs = nowProgressMs;\n        await hostClient.onExportProgress(progress);\n      }\n\n      const nowMs = typeof performance !== 'undefined' ? performance.now() : Date.now();\n      if (nowMs - lastYieldAtMs >= yieldIntervalMs) {\n        lastYieldAtMs = nowMs;\n        await new Promise<void>((resolve) => setTimeout(resolve, 0));\n      }\n    }\n  }\n\n  const localCompositor = new VideoCompositor();\n  await localCompositor.init(options.width, options.height, '#000', true);\n\n  try {\n    const maxVideoDurationUs = await localCompositor.loadTimeline(\n      timelineClips,\n      async (path) => {\n        if (!hostClient) return null;\n        return hostClient.getFileHandleByPath(path);\n      },\n      checkCancel,\n    );\n\n    const maxAudioDurationUs = computeMaxAudioDurationUs(audioClips);\n\n    const maxDurationUs = Math.max(maxVideoDurationUs, maxAudioDurationUs);\n\n    if (maxDurationUs <= 0) throw new Error('No clips to export');\n\n    const durationS = usToS(maxDurationUs);\n    const hasAnyAudio = audioClips.length > 0;\n\n    const format =\n      options.format === 'webm'\n        ? new WebMOutputFormat()\n        : options.format === 'mkv'\n          ? new MkvOutputFormat()\n          : new Mp4OutputFormat();\n\n    async function runExportWithHardwareAcceleration(\n      preference: 'prefer-hardware' | 'prefer-software',\n      fallbackCodecString = true,\n    ) {\n      await notifyPhase('encoding');\n\n      const { output, writable } = await createOutput({ format });\n\n      const fullCodecString =\n        fallbackCodecString && options.videoCodec ? options.videoCodec : undefined;\n\n      const videoSource = new CanvasSource(localCompositor.canvas as any, {\n        codec: getBunnyVideoCodec(options.videoCodec),\n        fullCodecString,\n        bitrate: options.bitrate,\n        hardwareAcceleration: preference,\n      });\n      output.addVideoTrack(videoSource);\n\n      let audioSource: any = null;\n      let writeMixedAudioToSource: (() => Promise<void>) | null = null;\n      let audioSampleRate = 48000;\n      let audioNumberOfChannels = 2;\n      let audioPacketState: {\n        audioSource: any;\n        packetSink: any;\n        decoderConfig: any;\n        ranges: { timelineStartS: number; sourceStartS: number; sourceEndS: number };\n        input: any;\n      } | null = null;\n      if (options.audio && hasAnyAudio) {\n        if (options.audioPassthrough && audioClips.length === 1) {\n          audioPacketState = await buildPassthroughAudioTrack({\n            clip: audioClips[0],\n            hostClient,\n            reportExportWarning,\n          });\n          if (audioPacketState) {\n            audioSource = audioPacketState.audioSource;\n            output.addAudioTrack(audioSource);\n          } else {\n            await reportExportWarning(\n              '[Worker Export] Opus audio passthrough not available; falling back to re-encode.',\n            );\n          }\n        }\n\n        if (!audioSource) {\n          const audioTrack = await buildMixedAudioTrack(\n            options,\n            audioClips,\n            durationS,\n            hostClient,\n            reportExportWarning,\n            checkCancel,\n          );\n          if (audioTrack) {\n            audioSource = audioTrack.audioSource;\n            writeMixedAudioToSource = audioTrack.writeMixedToSource;\n            audioSampleRate = audioTrack.sampleRate;\n            audioNumberOfChannels = audioTrack.numberOfChannels;\n            output.addAudioTrack(audioSource);\n          } else {\n            await reportExportWarning(\n              '[Worker Export] No decodable audio track found; exporting without audio.',\n            );\n          }\n        }\n      }\n\n      try {\n        await output.start();\n\n        await writeOpusPassthroughIfNeeded({ audioPacketState });\n\n        if (audioSource && writeMixedAudioToSource) {\n          await writeMixedAudioToSource();\n        }\n\n        await encodeFrames({\n          durationS,\n          fps: options.fps,\n          videoSource,\n          compositor: localCompositor,\n        });\n\n        if ('close' in videoSource) (videoSource as any).close();\n        if (audioSource && 'close' in audioSource) (audioSource as any).close();\n\n        await notifyPhase('saving');\n\n        await output.finalize();\n      } catch (e) {\n        await safeCancel({ output, writable });\n        throw e;\n      }\n    }\n\n    try {\n      await runExportWithHardwareAcceleration('prefer-hardware', true);\n    } catch (e) {\n      await reportExportWarning(\n        '[Worker Export] Hardware acceleration export with exact profile failed, retrying with default HW profile.',\n      );\n      try {\n        await runExportWithHardwareAcceleration('prefer-hardware', false);\n      } catch (e2) {\n        await reportExportWarning(\n          '[Worker Export] Hardware acceleration export failed completely, retrying with software.',\n        );\n        await runExportWithHardwareAcceleration('prefer-software', false);\n      }\n    }\n  } finally {\n    localCompositor.destroy();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/core/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":1,"column":44,"messageId":"unexpectedAny","endLine":1,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43,46],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43,46],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":50,"messageId":"unexpectedAny","endLine":6,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[351,354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[351,354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":51,"messageId":"unexpectedAny","endLine":7,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[427,430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[427,430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":52,"messageId":"unexpectedAny","endLine":11,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[523,526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[523,526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":64,"messageId":"unexpectedAny","endLine":35,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1394,1397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1394,1397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function normalizeRpcError(errData: any): Error {\n  if (!errData) return new Error('Worker RPC error');\n  if (typeof errData === 'string') return new Error(errData);\n  const message = typeof errData?.message === 'string' ? errData.message : 'Worker RPC error';\n  const err = new Error(message);\n  if (typeof errData?.name === 'string') (err as any).name = errData.name;\n  if (typeof errData?.stack === 'string') (err as any).stack = errData.stack;\n  return err;\n}\n\nexport function getBunnyVideoCodec(codec: string): any {\n  if (codec.startsWith('avc1')) return 'avc';\n  if (codec.startsWith('hvc1') || codec.startsWith('hev1')) return 'hevc';\n  if (codec.startsWith('vp8')) return 'vp8';\n  if (codec.startsWith('vp09')) return 'vp9';\n  if (codec.startsWith('av01')) return 'av1';\n  return 'avc';\n}\n\nexport function parseVideoCodec(codec: string): string {\n  if (codec.startsWith('avc1')) return 'H.264 (AVC)';\n  if (codec.startsWith('hev1') || codec.startsWith('hvc1')) return 'H.265 (HEVC)';\n  if (codec.startsWith('vp09')) return 'VP9';\n  if (codec.startsWith('av01')) return 'AV1';\n  return codec;\n}\n\nexport function parseAudioCodec(codec: string): string {\n  if (codec.startsWith('mp4a')) return 'AAC';\n  if (codec.startsWith('opus')) return 'Opus';\n  if (codec.startsWith('vorbis')) return 'Vorbis';\n  return codec;\n}\n\nexport function getBunnyAudioCodec(codec: string | undefined): any {\n  if (!codec) return 'aac';\n  const v = String(codec).toLowerCase();\n  if (v === 'aac' || v.startsWith('mp4a')) return 'aac';\n  if (v === 'opus') return 'opus';\n  return codec;\n}\n\nexport function clampFloat32(v: number) {\n  if (v > 1) return 1;\n  if (v < -1) return -1;\n  return v;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/video-core.worker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":26,"messageId":"unexpectedAny","endLine":27,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[908,911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[908,911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":12,"messageId":"unexpectedAny","endLine":33,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[985,988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[985,988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":29,"messageId":"unexpectedAny","endLine":46,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1332,1335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1332,1335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":37,"messageId":"unexpectedAny","endLine":54,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1614,1617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1614,1617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":14,"messageId":"unexpectedAny","endLine":90,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2454,2457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2454,2457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":20,"messageId":"unexpectedAny","endLine":91,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2478,2481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2478,2481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":17,"messageId":"unexpectedAny","endLine":92,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2501,2504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2501,2504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":20,"messageId":"unexpectedAny","endLine":114,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2913,2916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2913,2916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":147,"column":49,"messageId":"bannedFunctionType","endLine":147,"endColumn":57},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":1,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":147,"column":67,"messageId":"bannedFunctionType","endLine":147,"endColumn":75},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":44,"messageId":"unexpectedAny","endLine":149,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3836,3839],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3836,3839],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":19,"messageId":"unexpectedAny","endLine":168,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4507,4510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4507,4510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":30,"messageId":"unexpectedAny","endLine":187,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4920,4923],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4920,4923],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":21,"messageId":"unexpectedAny","endLine":192,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5201,5204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5201,5204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import './worker-polyfill';\nimport { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n\nimport type { VideoCoreHostAPI } from '../utils/video-editor/worker-client';\nimport { VideoCompositor } from '../utils/video-editor/VideoCompositor';\nimport { initEffects } from '../effects';\nimport { initTransitions } from '../transitions';\nimport { normalizeRpcError } from './core/utils';\nimport { extractMetadata, runExport } from './core/export';\nimport { VIDEO_CORE_LIMITS } from '../utils/constants';\n\nDOMAdapter.set(WebWorkerAdapter);\ninitEffects();\ninitTransitions();\n\nlet hostClient: VideoCoreHostAPI | null = null;\nlet compositor: VideoCompositor | null = null;\nlet cancelExportRequested = false;\n\nlet renderInFlight = false;\nlet latestRenderTimeUs: number | null = null;\n\nasync function reportExportWarning(message: string) {\n  console.warn(message);\n  if (!hostClient) return;\n  try {\n    await (hostClient as any).onExportWarning?.(message);\n  } catch {\n    // ignore\n  }\n}\n\nconst api: any = {\n  extractMetadata,\n\n  async initCompositor(canvas: OffscreenCanvas, width: number, height: number, bgColor: string) {\n    if (compositor) {\n      compositor.destroy();\n      compositor = null;\n    }\n\n    compositor = new VideoCompositor();\n    await compositor.init(width, height, bgColor, true, canvas);\n  },\n\n  async loadTimeline(clips: any[]) {\n    if (!compositor) throw new Error('Compositor not initialized');\n    return compositor.loadTimeline(clips, async (path: string) => {\n      if (!hostClient) return null;\n      return hostClient.getFileHandleByPath(path);\n    });\n  },\n\n  async updateTimelineLayout(clips: any[]) {\n    if (!compositor) throw new Error('Compositor not initialized');\n    return compositor.updateTimelineLayout(clips);\n  },\n\n  async renderFrame(timeUs: number) {\n    if (!compositor) return;\n    latestRenderTimeUs = Math.round(Number(timeUs) || 0);\n    if (renderInFlight) return;\n\n    renderInFlight = true;\n    try {\n      while (latestRenderTimeUs !== null) {\n        const next = latestRenderTimeUs;\n        latestRenderTimeUs = null;\n        await compositor.renderFrame(next);\n      }\n    } finally {\n      renderInFlight = false;\n    }\n  },\n\n  async clearClips() {\n    if (!compositor) return;\n    compositor.clearClips();\n  },\n\n  async destroyCompositor() {\n    if (compositor) {\n      compositor.destroy();\n      compositor = null;\n    }\n  },\n\n  async exportTimeline(\n    targetHandle: FileSystemFileHandle,\n    options: any,\n    timelineClips: any[],\n    audioClips: any[] = [],\n  ) {\n    cancelExportRequested = false;\n    await runExport(\n      targetHandle,\n      options,\n      timelineClips,\n      audioClips,\n      hostClient,\n      reportExportWarning,\n      () => cancelExportRequested,\n    );\n  },\n\n  async cancelExport() {\n    cancelExportRequested = true;\n  },\n\n  async extractFrameToBlob(\n    timeUs: number,\n    width: number,\n    height: number,\n    timelineClips: any[],\n    quality: number,\n  ) {\n    const localCompositor = new VideoCompositor();\n    await localCompositor.init(width, height, '#000', true);\n\n    try {\n      await localCompositor.loadTimeline(\n        timelineClips,\n        async (path) => {\n          if (!hostClient) return null;\n          return hostClient.getFileHandleByPath(path);\n        },\n        () => false,\n      );\n\n      const canvas = await localCompositor.renderFrame(timeUs);\n      if (!canvas) {\n        throw new Error('Failed to render frame');\n      }\n\n      const blob = await (canvas as OffscreenCanvas).convertToBlob({\n        type: 'image/webp',\n        quality: Math.max(0.01, Math.min(1, quality)),\n      });\n      return blob;\n    } finally {\n      localCompositor.destroy();\n    }\n  },\n};\n\nlet callIdCounter = 0;\nconst pendingCalls = new Map<number, { resolve: Function; reject: Function }>();\n\nself.addEventListener('message', async (e: any) => {\n  const data = e.data;\n  if (!data) return;\n\n  if (data.type === 'rpc-response') {\n    const pending = pendingCalls.get(data.id);\n    if (pending) {\n      if (data.error) pending.reject(normalizeRpcError(data.error));\n      else pending.resolve(data.result);\n      pendingCalls.delete(data.id);\n    }\n  } else if (data.type === 'rpc-call') {\n    try {\n      const method = data.method;\n      if (typeof api[method] !== 'function') {\n        throw new Error(`Method ${method} not found on Worker API`);\n      }\n      const result = await api[method](...(data.args || []));\n      self.postMessage({ type: 'rpc-response', id: data.id, result });\n    } catch (err: any) {\n      console.error(`[Worker] Error in method ${data.method}:`, err);\n      self.postMessage({\n        type: 'rpc-response',\n        id: data.id,\n        error: {\n          name: err?.name || 'Error',\n          message: err?.message || String(err),\n          stack: err?.stack,\n        },\n      });\n    }\n  }\n});\n\nhostClient = new Proxy(\n  {},\n  {\n    get(_, method: string) {\n      return async (...args: any[]) => {\n        return new Promise((resolve, reject) => {\n          const max = Math.max(1, Math.round(VIDEO_CORE_LIMITS.MAX_WORKER_RPC_PENDING_CALLS));\n          if (pendingCalls.size >= max) {\n            const err = new Error('Host RPC queue overflow');\n            (err as any).name = 'HostQueueOverflowError';\n            reject(err);\n            return;\n          }\n          const id = ++callIdCounter;\n          pendingCalls.set(id, { resolve, reject });\n          self.postMessage({ type: 'rpc-call', id, method, args });\n        });\n      };\n    },\n  },\n) as VideoCoreHostAPI;\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/src/workers/worker-polyfill.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":18,"messageId":"unexpectedAny","endLine":3,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[106,109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[106,109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":18,"messageId":"unexpectedAny","endLine":18,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[458,461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[458,461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Mock document for PixiJS DOMPipe in Web Worker\nif (typeof document === 'undefined') {\n  (globalThis as any).document = {\n    createElement: () => ({\n      style: {},\n      appendChild: () => {},\n      removeChild: () => {},\n      remove: () => {},\n      contains: () => false,\n      addEventListener: () => {},\n      removeEventListener: () => {},\n    }),\n    body: {\n      appendChild: () => {},\n      removeChild: () => {},\n    },\n  };\n  (globalThis as any).window = globalThis;\n}\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/e2e/smoke.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/app.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/components/file-manager/FileManagerTree.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/components/wheel-slider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/fileManager/useFileManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/monitor/useMonitorCore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/monitor/useMonitorPlayback.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":10,"messageId":"unexpectedAny","endLine":24,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[782,785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[782,785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { ref, nextTick, defineComponent, h } from 'vue';\nimport { mount } from '@vue/test-utils';\nimport { useMonitorPlayback } from '../../../../src/composables/monitor/useMonitorPlayback';\n\ndescribe('useMonitorPlayback', () => {\n  beforeEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('pauses playback when document becomes hidden', async () => {\n    const isLoading = ref(false);\n    const loadError = ref<string | null>(null);\n    const isPlaying = ref(false);\n    const currentTime = ref(0);\n    const duration = ref(1_000_000);\n    const safeDurationUs = ref(1_000_000);\n\n    const audioEngine = {\n      play: vi.fn(),\n      stop: vi.fn(),\n      seek: vi.fn(),\n      getCurrentTimeUs: vi.fn(() => 0),\n    } as any;\n\n    const scheduleRender = vi.fn();\n    const updateStoreTime = vi.fn((t: number) => {\n      currentTime.value = t;\n    });\n\n    const TestComp = defineComponent({\n      setup() {\n        useMonitorPlayback({\n          isLoading,\n          loadError,\n          isPlaying,\n          currentTime,\n          duration,\n          safeDurationUs,\n          getFps: () => 30,\n          clampToTimeline: (t: number) => Math.max(0, Math.min(t, safeDurationUs.value)),\n          updateStoreTime,\n          scheduleRender,\n          audioEngine,\n        });\n        return () => h('div');\n      },\n    });\n\n    const wrapper = mount(TestComp);\n\n    isPlaying.value = true;\n    await nextTick();\n\n    expect(audioEngine.play).toHaveBeenCalledTimes(1);\n\n    Object.defineProperty(document, 'hidden', {\n      configurable: true,\n      get: () => true,\n    });\n\n    document.dispatchEvent(new Event('visibilitychange'));\n    await nextTick();\n\n    expect(isPlaying.value).toBe(false);\n\n    wrapper.unmount();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/timeline/useTimelineExport.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":32,"messageId":"unexpectedAny","endLine":33,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1199,1202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1199,1202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":75,"messageId":"unexpectedAny","endLine":89,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3198,3201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3198,3201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":12,"messageId":"unexpectedAny","endLine":123,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4252,4255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4252,4255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":18,"messageId":"unexpectedAny","endLine":126,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4282,4285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4282,4285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":75,"messageId":"unexpectedAny","endLine":133,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4527,4530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4527,4530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":54,"messageId":"unexpectedAny","endLine":136,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4658,4661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4658,4661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":151,"column":12,"messageId":"unexpectedAny","endLine":151,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5160,5163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5160,5163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":18,"messageId":"unexpectedAny","endLine":154,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5190,5193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5190,5193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":75,"messageId":"unexpectedAny","endLine":156,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5281,5284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5281,5284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":55,"messageId":"unexpectedAny","endLine":206,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6911,6914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6911,6914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":12,"messageId":"unexpectedAny","endLine":209,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7049,7052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7049,7052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":14,"messageId":"unexpectedAny","endLine":217,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7303,7306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7303,7306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":10,"messageId":"unexpectedAny","endLine":219,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7326,7329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7326,7329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":55,"messageId":"unexpectedAny","endLine":281,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9267,9270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9267,9270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":12,"messageId":"unexpectedAny","endLine":288,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9522,9525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9522,9525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":296,"column":14,"messageId":"unexpectedAny","endLine":296,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9776,9779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9776,9779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":10,"messageId":"unexpectedAny","endLine":298,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9799,9802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9799,9802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport {\n  getExt,\n  sanitizeBaseName,\n  resolveNextAvailableFilename,\n  resolveExportCodecs,\n  toWorkerTimelineClips,\n} from '../../../../src/composables/timeline/useTimelineExport';\nimport type { VideoCoreHostAPI } from '../../../../src/utils/video-editor/worker-client';\nimport type { TimelineTrackItem } from '../../../../src/timeline/types';\n\ndescribe('useTimelineExport pure functions', () => {\n  it('VideoCoreHostAPI allows omitting onExportPhase (backward compatible)', () => {\n    const api: VideoCoreHostAPI = {\n      getFileHandleByPath: async () => null,\n      onExportProgress: () => {},\n    };\n    expect(typeof api.onExportProgress).toBe('function');\n  });\n\n  it('VideoCoreHostAPI allows omitting onExportWarning (backward compatible)', () => {\n    const api: VideoCoreHostAPI = {\n      getFileHandleByPath: async () => null,\n      onExportProgress: () => {},\n    };\n    expect(typeof api.onExportProgress).toBe('function');\n  });\n\n  it('getExt should return correct extension', () => {\n    expect(getExt('mp4')).toBe('mp4');\n    expect(getExt('webm')).toBe('webm');\n    expect(getExt('mkv')).toBe('mkv');\n    expect(getExt('unknown' as any)).toBe('mp4');\n  });\n\n  it('sanitizeBaseName should sanitize filenames correctly', () => {\n    expect(sanitizeBaseName('my video.mp4')).toBe('my_video');\n    expect(sanitizeBaseName('special!@#$%^&*()chars')).toBe('special_chars');\n    expect(sanitizeBaseName('___leading_and_trailing___')).toBe('leading_and_trailing');\n    expect(sanitizeBaseName('multiple___underscores')).toBe('multiple_underscores');\n  });\n\n  it('resolveNextAvailableFilename should prefer base.ext and fallback to _001', () => {\n    expect(resolveNextAvailableFilename(new Set(), 'video', 'mp4')).toBe('video.mp4');\n    expect(resolveNextAvailableFilename(new Set(['video.mp4']), 'video', 'mp4')).toBe(\n      'video_001.mp4',\n    );\n    expect(\n      resolveNextAvailableFilename(new Set(['video.mp4', 'video_001.mp4']), 'video', '.mp4'),\n    ).toBe('video_002.mp4');\n  });\n\n  it('resolveExportCodecs should force codecs for webm and mkv', () => {\n    expect(resolveExportCodecs('webm', 'avc1.42E032', 'aac')).toEqual({\n      videoCodec: 'vp09.00.10.08',\n      audioCodec: 'opus',\n    });\n\n    expect(resolveExportCodecs('mkv', 'avc1.42E032', 'aac')).toEqual({\n      videoCodec: 'av01.0.05M.08',\n      audioCodec: 'opus',\n    });\n\n    expect(resolveExportCodecs('mp4', 'avc1.42E032', 'aac')).toEqual({\n      videoCodec: 'avc1.42E032',\n      audioCodec: 'aac',\n    });\n  });\n\n  it('toWorkerTimelineClips should attach layer (default 0)', async () => {\n    const items: TimelineTrackItem[] = [\n      {\n        kind: 'clip',\n        clipType: 'media',\n        id: 'c1',\n        trackId: 't1',\n        name: 'Clip 1',\n        source: { path: '/video.mp4' },\n        sourceDurationUs: 1_000_000,\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        audioGain: 1.5,\n        audioBalance: -0.25,\n        audioFadeInUs: 120_000,\n        audioFadeOutUs: 340_000,\n      },\n    ];\n\n    const projectStoreMock = { getFileHandleByPath: async () => null } as any;\n\n    expect(await toWorkerTimelineClips(items, projectStoreMock)).toMatchObject([\n      {\n        kind: 'clip',\n        clipType: 'media',\n        id: 'c1',\n        layer: 0,\n        source: { path: '/video.mp4' },\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        audioGain: 1.5,\n        audioBalance: -0.25,\n        audioFadeInUs: 120_000,\n        audioFadeOutUs: 340_000,\n      },\n    ]);\n\n    const nested = await toWorkerTimelineClips(items, projectStoreMock, { layer: 3 });\n    expect(nested[0]?.layer).toBe(3);\n  });\n\n  it('toWorkerTimelineClips should propagate transform', async () => {\n    const items: TimelineTrackItem[] = [\n      {\n        kind: 'clip',\n        clipType: 'media',\n        id: 'c1',\n        trackId: 't1',\n        name: 'Clip 1',\n        source: { path: '/video.mp4' },\n        sourceDurationUs: 1_000_000,\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n      } as any,\n    ];\n\n    (items[0] as any).transform = {\n      scale: { x: 1.25, y: 0.75, linked: false },\n      rotationDeg: 10,\n      position: { x: 12, y: -34 },\n      anchor: { preset: 'center' },\n    };\n\n    const projectStoreMock = { getFileHandleByPath: async () => null } as any;\n    const clips = await toWorkerTimelineClips(items, projectStoreMock);\n\n    expect(clips[0]?.transform).toEqual((items[0] as any).transform);\n  });\n\n  it('toWorkerTimelineClips should respect item.layer when options.layer is not provided', async () => {\n    const items: TimelineTrackItem[] = [\n      {\n        kind: 'clip',\n        clipType: 'media',\n        id: 'c1',\n        trackId: 't1',\n        name: 'Clip 1',\n        source: { path: '/video.mp4' },\n        sourceDurationUs: 1_000_000,\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n      } as any,\n    ];\n\n    (items[0] as any).layer = 5;\n\n    const projectStoreMock = { getFileHandleByPath: async () => null } as any;\n\n    const clips = await toWorkerTimelineClips(items, projectStoreMock);\n    expect(clips[0]?.layer).toBe(5);\n\n    const overridden = await toWorkerTimelineClips(items, projectStoreMock, { layer: 2 });\n    expect(overridden[0]?.layer).toBe(2);\n  });\n\n  it('toWorkerTimelineClips should resolve relative media paths inside nested timeline', async () => {\n    const nestedOtio = JSON.stringify({\n      OTIO_SCHEMA: 'Timeline.1',\n      name: 'nested',\n      metadata: { gran: { timebase: { fps: 25 } } },\n      tracks: {\n        OTIO_SCHEMA: 'Stack.1',\n        name: 'tracks',\n        children: [\n          {\n            OTIO_SCHEMA: 'Track.1',\n            name: 'V1',\n            kind: 'Video',\n            children: [\n              {\n                OTIO_SCHEMA: 'Clip.1',\n                name: 'Clip',\n                media_reference: {\n                  OTIO_SCHEMA: 'ExternalReference.1',\n                  target_url: 'media/video.mp4',\n                },\n                source_range: {\n                  OTIO_SCHEMA: 'TimeRange.1',\n                  start_time: { OTIO_SCHEMA: 'RationalTime.1', value: 0, rate: 1000000 },\n                  duration: { OTIO_SCHEMA: 'RationalTime.1', value: 1000000, rate: 1000000 },\n                },\n                metadata: { gran: { clipType: 'media', sourceDurationUs: 1000000 } },\n              },\n            ],\n          },\n        ],\n      },\n    });\n\n    const items: TimelineTrackItem[] = [\n      {\n        kind: 'clip',\n        clipType: 'timeline',\n        id: 'nested1',\n        trackId: 't1',\n        name: 'Nested',\n        source: { path: '_timelines/nested.otio' } as any,\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n      } as any,\n    ];\n\n    const projectStoreMock = {\n      getFileHandleByPath: async (path: string) => {\n        if (path !== '_timelines/nested.otio') return null;\n        return {\n          getFile: async () => ({ text: async () => nestedOtio }),\n        } as any;\n      },\n    } as any;\n\n    const clips = await toWorkerTimelineClips(items, projectStoreMock, {\n      layer: 1,\n      trackKind: 'video',\n    });\n\n    expect(clips.length).toBe(1);\n    expect(clips[0]?.clipType).toBe('media');\n    expect(clips[0]?.source?.path).toBe('_timelines/media/video.mp4');\n  });\n\n  it('toWorkerTimelineClips should apply nested timeline parent audio gain/balance/fades when trackKind is audio', async () => {\n    const nestedOtio = JSON.stringify({\n      OTIO_SCHEMA: 'Timeline.1',\n      name: 'nested',\n      metadata: { gran: { timebase: { fps: 25 } } },\n      tracks: {\n        OTIO_SCHEMA: 'Stack.1',\n        name: 'tracks',\n        children: [\n          {\n            OTIO_SCHEMA: 'Track.1',\n            name: 'A1',\n            kind: 'Audio',\n            children: [\n              {\n                OTIO_SCHEMA: 'Clip.1',\n                name: 'AudioClip',\n                media_reference: {\n                  OTIO_SCHEMA: 'ExternalReference.1',\n                  target_url: 'audio.wav',\n                },\n                source_range: {\n                  OTIO_SCHEMA: 'TimeRange.1',\n                  start_time: { OTIO_SCHEMA: 'RationalTime.1', value: 0, rate: 1000000 },\n                  duration: { OTIO_SCHEMA: 'RationalTime.1', value: 1000000, rate: 1000000 },\n                },\n                metadata: {\n                  gran: {\n                    clipType: 'media',\n                    sourceDurationUs: 1000000,\n                    audioGain: 2,\n                    audioBalance: 0.1,\n                    audioFadeInUs: 100000,\n                    audioFadeOutUs: 100000,\n                  },\n                },\n              },\n            ],\n          },\n        ],\n      },\n    });\n\n    const items: TimelineTrackItem[] = [\n      {\n        kind: 'clip',\n        clipType: 'timeline',\n        id: 'nested1',\n        trackId: 't1',\n        name: 'Nested',\n        source: { path: '_timelines/nested.otio' } as any,\n        timelineRange: { startUs: 0, durationUs: 1_000_000 },\n        sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        audioGain: 0.5,\n        audioBalance: -0.2,\n        audioFadeInUs: 200_000,\n        audioFadeOutUs: 300_000,\n      } as any,\n    ];\n\n    const projectStoreMock = {\n      getFileHandleByPath: async (path: string) => {\n        if (path !== '_timelines/nested.otio') return null;\n        return {\n          getFile: async () => ({ text: async () => nestedOtio }),\n        } as any;\n      },\n    } as any;\n\n    const clips = await toWorkerTimelineClips(items, projectStoreMock, {\n      trackKind: 'audio',\n    });\n\n    expect(clips.length).toBe(1);\n    expect(clips[0]?.source?.path).toBe('_timelines/audio.wav');\n    expect(clips[0]?.audioGain).toBeCloseTo(1);\n    expect(clips[0]?.audioBalance).toBeCloseTo(-0.1);\n    expect(clips[0]?.audioFadeInUs).toBe(200_000);\n    expect(clips[0]?.audioFadeOutUs).toBe(300_000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/timeline/useTimelineInteraction.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/useMonitorDisplay.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/composables/useMonitorTimeline.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":10,"messageId":"unexpectedAny","endLine":42,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1234,1237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1234,1237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":10,"messageId":"unexpectedAny","endLine":94,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2729,2732],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2729,2732],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":47,"messageId":"unexpectedAny","endLine":107,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3386,3389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3386,3389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":47,"messageId":"unexpectedAny","endLine":110,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3506,3509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3506,3509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":10,"messageId":"unexpectedAny","endLine":148,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4543,4546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4543,4546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":57,"messageId":"unexpectedAny","endLine":152,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4667,4670],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4667,4670],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":57,"messageId":"unexpectedAny","endLine":153,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4750,4753],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4750,4753],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":10,"messageId":"unexpectedAny","endLine":202,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6224,6227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6224,6227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":47,"messageId":"unexpectedAny","endLine":208,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6453,6456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6453,6456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":47,"messageId":"unexpectedAny","endLine":209,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6542,6545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6542,6545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":47,"messageId":"unexpectedAny","endLine":211,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6676,6679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6676,6679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":10,"messageId":"unexpectedAny","endLine":248,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7683,7686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7683,7686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":10,"messageId":"unexpectedAny","endLine":298,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9268,9271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9268,9271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":10,"messageId":"unexpectedAny","endLine":339,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10396,10399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10396,10399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":10,"messageId":"unexpectedAny","endLine":383,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11658,11661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11658,11661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":51,"messageId":"unexpectedAny","endLine":386,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11772,11775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11772,11775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach } from 'vitest';\nimport { setActivePinia, createPinia } from 'pinia';\nimport { useMonitorTimeline } from '../../../src/composables/monitor/useMonitorTimeline';\nimport { useTimelineStore } from '../../../src/stores/timeline.store';\n\ndescribe('useMonitorTimeline', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia());\n  });\n\n  it('provides computed videoTrack', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: '1',\n          kind: 'audio',\n          items: [\n            {\n              id: 'audio1',\n              kind: 'clip',\n              source: { path: 'test.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: '2',\n          kind: 'video',\n          items: [\n            {\n              id: 'item1',\n              kind: 'clip',\n              source: { path: 'test.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { videoTracks, videoItems, audioTracks, audioItems } = useMonitorTimeline();\n\n    expect(videoTracks.value.length).toBe(1);\n    expect(videoTracks.value[0].id).toBe('2');\n    expect(videoItems.value.length).toBe(1);\n    expect(videoItems.value[0].id).toBe('item1');\n\n    expect(audioTracks.value.length).toBe(1);\n    expect(audioItems.value.length).toBe(1);\n    expect(audioItems.value[0].id).toBe('audio1');\n  });\n\n  it('computes workerTimelineClips and workerAudioClips correctly', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: '2',\n          kind: 'video',\n          videoHidden: false,\n          items: [\n            {\n              id: 'item1',\n              kind: 'clip',\n              source: { path: 'test1.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n            {\n              id: 'item2',\n              kind: 'other',\n            },\n          ],\n        },\n        {\n          id: '1',\n          kind: 'audio',\n          audioMuted: false,\n          audioSolo: false,\n          items: [\n            {\n              id: 'audio1',\n              kind: 'clip',\n              source: { path: 'test1.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { rawWorkerTimelineClips, rawWorkerAudioClips } = useMonitorTimeline();\n\n    expect(rawWorkerTimelineClips.value.length).toBe(1);\n    expect(rawWorkerTimelineClips.value[0].id).toBe('item1');\n    expect(rawWorkerTimelineClips.value[0].clipType).toBe('media');\n    expect(rawWorkerTimelineClips.value[0].source?.path).toBe('test1.mp4');\n    expect(rawWorkerTimelineClips.value[0].timelineRange.startUs).toBe(0);\n    // Single video track: layer should be 0 (trackCount - 1 - 0 = 0)\n    expect(rawWorkerTimelineClips.value[0].layer).toBe(0);\n\n    expect(rawWorkerAudioClips.value.length).toBe(2);\n    expect(rawWorkerAudioClips.value.find((x: any) => x.id === 'audio1')?.source?.path).toBe(\n      'test1.mp3',\n    );\n    expect(rawWorkerAudioClips.value.find((x: any) => x.id === 'item1__audio')?.source?.path).toBe(\n      'test1.mp4',\n    );\n  });\n\n  it('assigns inverted layers so first track (top in UI) renders on top', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          videoHidden: false,\n          items: [\n            {\n              id: 'clip1',\n              kind: 'clip',\n              source: { path: 'a.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: 'v2',\n          kind: 'video',\n          videoHidden: false,\n          items: [\n            {\n              id: 'clip2',\n              kind: 'clip',\n              source: { path: 'b.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { rawWorkerTimelineClips } = useMonitorTimeline();\n\n    const clip1 = rawWorkerTimelineClips.value.find((c: any) => c.id === 'clip1');\n    const clip2 = rawWorkerTimelineClips.value.find((c: any) => c.id === 'clip2');\n\n    // rawWorkerTimelineClips still assigns initial layers (trackCount - 1 - trackIndex)\n    expect(clip1?.layer).toBe(1);\n    expect(clip2?.layer).toBe(0);\n  });\n\n  it('workerAudioClips does not duplicate audio from video clips', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          videoHidden: false,\n          items: [\n            {\n              id: 'vclip1',\n              kind: 'clip',\n              source: { path: 'video.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n            {\n              id: 'vclip2',\n              kind: 'clip',\n              source: { path: 'video2.mp4' },\n              audioFromVideoDisabled: true,\n              timelineRange: { startUs: 1000, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: 'a1',\n          kind: 'audio',\n          audioMuted: false,\n          audioSolo: false,\n          items: [\n            {\n              id: 'aclip1',\n              kind: 'clip',\n              source: { path: 'audio.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { rawWorkerAudioClips } = useMonitorTimeline();\n\n    // Should have: aclip1 + vclip1__audio (vclip2 is disabled)\n    expect(rawWorkerAudioClips.value.length).toBe(2);\n    expect(rawWorkerAudioClips.value.find((c: any) => c.id === 'aclip1')).toBeDefined();\n    expect(rawWorkerAudioClips.value.find((c: any) => c.id === 'vclip1__audio')).toBeDefined();\n    // Disabled audio must NOT appear\n    expect(rawWorkerAudioClips.value.find((c: any) => c.id === 'vclip2__audio')).toBeUndefined();\n  });\n\n  it('computes signatures correctly', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: '1',\n          kind: 'video',\n          videoHidden: false,\n          items: [\n            {\n              id: 'item1',\n              kind: 'clip',\n              source: { path: 'test1.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: '2',\n          kind: 'audio',\n          audioMuted: false,\n          audioSolo: false,\n          items: [\n            {\n              id: 'audio1',\n              kind: 'clip',\n              source: { path: 'test1.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const {\n      clipSourceSignature,\n      clipLayoutSignature,\n      audioClipSourceSignature,\n      audioClipLayoutSignature,\n    } = useMonitorTimeline();\n\n    const sig1 = clipSourceSignature.value;\n    const layout1 = clipLayoutSignature.value;\n    const audioSig1 = audioClipSourceSignature.value;\n    const audioLayout1 = audioClipLayoutSignature.value;\n\n    expect(typeof sig1).toBe('number');\n    expect(typeof layout1).toBe('number');\n    expect(typeof audioSig1).toBe('number');\n    expect(typeof audioLayout1).toBe('number');\n\n    // Changing layout should change layout signature but not source signature\n    timelineStore.timelineDoc.tracks[0].items[0].timelineRange.startUs = 500;\n\n    expect(clipSourceSignature.value).toBe(sig1);\n    expect(clipLayoutSignature.value).not.toBe(layout1);\n\n    timelineStore.timelineDoc.tracks[1].items[0].timelineRange.startUs = 500;\n\n    expect(audioClipSourceSignature.value).toBe(audioSig1);\n    expect(audioClipLayoutSignature.value).not.toBe(audioLayout1);\n  });\n\n  it('filters hidden video tracks from workerTimelineClips', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          videoHidden: true,\n          items: [\n            {\n              id: 'clip1',\n              kind: 'clip',\n              source: { path: 'a.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { workerTimelineClips } = useMonitorTimeline();\n    expect(workerTimelineClips.value.length).toBe(0);\n  });\n\n  it('applies audio solo/mute when building workerAudioClips', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: 'a1',\n          kind: 'audio',\n          audioMuted: true,\n          audioSolo: false,\n          items: [\n            {\n              id: 'aclip1',\n              kind: 'clip',\n              source: { path: 'audio1.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: 'a2',\n          kind: 'audio',\n          audioMuted: false,\n          audioSolo: true,\n          items: [\n            {\n              id: 'aclip2',\n              kind: 'clip',\n              source: { path: 'audio2.mp3' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { rawWorkerAudioClips } = useMonitorTimeline();\n    expect(rawWorkerAudioClips.value.length).toBe(1);\n    expect(rawWorkerAudioClips.value[0].id).toBe('aclip2');\n  });\n\n  it('applies video track solo/mute to __audio clips extracted from video', () => {\n    const timelineStore = useTimelineStore();\n    timelineStore.timelineDoc = {\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          videoHidden: false,\n          audioMuted: false,\n          audioSolo: false,\n          items: [\n            {\n              id: 'vclip1',\n              kind: 'clip',\n              source: { path: 'video1.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n        {\n          id: 'v2',\n          kind: 'video',\n          videoHidden: false,\n          audioMuted: false,\n          audioSolo: true,\n          items: [\n            {\n              id: 'vclip2',\n              kind: 'clip',\n              source: { path: 'video2.mp4' },\n              timelineRange: { startUs: 0, durationUs: 1000 },\n              sourceRange: { startUs: 0, durationUs: 1000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    const { rawWorkerAudioClips } = useMonitorTimeline();\n    const ids = rawWorkerAudioClips.value.map((c: any) => c.id);\n    expect(ids).toContain('vclip2__audio');\n    expect(ids).not.toContain('vclip1__audio');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/file-manager/application/fileManagerCommands.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":8,"messageId":"unexpectedAny","endLine":15,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[418,421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[418,421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":8,"messageId":"unexpectedAny","endLine":26,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[716,719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[716,719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":8,"messageId":"unexpectedAny","endLine":42,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1086,1089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1086,1089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":23,"messageId":"unexpectedAny","endLine":86,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2422,2425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2422,2425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":33,"messageId":"unexpectedAny","endLine":99,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3003,3006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3003,3006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":33,"messageId":"unexpectedAny","endLine":104,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3158,3161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3158,3161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":39,"messageId":"unexpectedAny","endLine":124,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3827,3830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3827,3830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":36,"messageId":"unexpectedAny","endLine":127,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3951,3954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3951,3954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":36,"messageId":"unexpectedAny","endLine":132,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4213,4216],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4213,4216],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":38,"messageId":"unexpectedAny","endLine":150,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4968,4971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4968,4971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":38,"messageId":"unexpectedAny","endLine":156,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5179,5182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5179,5182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, expect, it, vi } from 'vitest';\nimport type { FsEntry } from '../../../../src/types/fs';\nimport {\n  deleteEntryCommand,\n  renameEntryCommand,\n  moveEntryCommand,\n  createTimelineCommand,\n} from '../../../../src/file-manager/application/fileManagerCommands';\n\nfunction createDirHandleMock() {\n  return {\n    getFileHandle: vi.fn(),\n    getDirectoryHandle: vi.fn(),\n  } as any as FileSystemDirectoryHandle;\n}\n\nfunction createFileEntry(params: {\n  name: string;\n  path: string;\n  parent: FileSystemDirectoryHandle;\n}) {\n  const handle = {\n    getFile: vi.fn(async () => new File(['x'], params.name, { type: 'text/plain' })),\n    move: vi.fn(async () => undefined),\n  } as any as FileSystemFileHandle;\n\n  const entry: FsEntry = {\n    name: params.name,\n    kind: 'file',\n    handle,\n    parentHandle: params.parent,\n    path: params.path,\n  };\n\n  return { entry, handle };\n}\n\nfunction createDirEntry(params: { name: string; path: string; parent: FileSystemDirectoryHandle }) {\n  const handle = {\n    move: vi.fn(async () => undefined),\n  } as any as FileSystemDirectoryHandle;\n\n  const entry: FsEntry = {\n    name: params.name,\n    kind: 'directory',\n    handle,\n    parentHandle: params.parent,\n    path: params.path,\n    children: [],\n  };\n\n  return { entry, handle };\n}\n\ndescribe('fileManagerCommands', () => {\n  it('deleteEntryCommand calls removeEntry and onFileDeleted for files with path', async () => {\n    const parent = createDirHandleMock();\n    const { entry } = createFileEntry({ name: 'a.mp4', path: 'video/a.mp4', parent });\n\n    const removeEntry = vi.fn(async () => undefined);\n    const onFileDeleted = vi.fn(async () => undefined);\n\n    await deleteEntryCommand(entry, { removeEntry, onFileDeleted });\n\n    expect(removeEntry).toHaveBeenCalledWith({\n      parentHandle: parent,\n      name: 'a.mp4',\n      recursive: true,\n    });\n    expect(onFileDeleted).toHaveBeenCalledWith({ path: 'video/a.mp4' });\n  });\n\n  it('renameEntryCommand uses handle.move when available', async () => {\n    const parent = createDirHandleMock();\n    const { entry, handle } = createFileEntry({ name: 'a.txt', path: 'files/a.txt', parent });\n\n    await renameEntryCommand(\n      { target: entry, newName: 'b.txt' },\n      {\n        ensureTargetNameDoesNotExist: vi.fn(async () => undefined),\n        removeEntry: vi.fn(async () => undefined),\n      },\n    );\n\n    expect((handle as any).move).toHaveBeenCalledWith('b.txt');\n  });\n\n  it('moveEntryCommand calls deps.onFileMoved for files', async () => {\n    const parent = createDirHandleMock();\n    const targetDir = createDirHandleMock();\n    const { entry } = createFileEntry({ name: 'a.txt', path: 'files/a.txt', parent });\n\n    const removeEntry = vi.fn(async () => undefined);\n    const onFileMoved = vi.fn(async () => undefined);\n\n    // Mock: assertEntryDoesNotExist -> internally calls targetDir.getFileHandle / getDirectoryHandle.\n    // Here simulate file doesn't exist.\n    (targetDir.getFileHandle as any).mockRejectedValueOnce(\n      Object.assign(new Error('nf'), { name: 'NotFoundError' }),\n    );\n\n    // Mock file copy\n    (targetDir.getFileHandle as any).mockResolvedValueOnce({\n      createWritable: vi.fn(async () => ({ write: vi.fn(), close: vi.fn() })),\n    });\n\n    await moveEntryCommand(\n      {\n        source: entry,\n        targetDirHandle: targetDir,\n        targetDirPath: 'files2',\n      },\n      { removeEntry, onFileMoved },\n    );\n\n    expect(removeEntry).toHaveBeenCalled();\n    expect(onFileMoved).toHaveBeenCalledWith({ oldPath: 'files/a.txt', newPath: 'files2/a.txt' });\n  });\n\n  it('createTimelineCommand picks first available index on NotFoundError', async () => {\n    const projectDir = createDirHandleMock();\n    const timelinesDir = createDirHandleMock();\n    (projectDir.getDirectoryHandle as any).mockResolvedValue(timelinesDir);\n\n    // timeline_001 exists, timeline_002 does not\n    (timelinesDir.getFileHandle as any)\n      .mockResolvedValueOnce({})\n      .mockRejectedValueOnce(Object.assign(new Error('nf'), { name: 'NotFoundError' }));\n\n    const writable = { write: vi.fn(async () => undefined), close: vi.fn(async () => undefined) };\n    (timelinesDir.getFileHandle as any).mockResolvedValueOnce({\n      createWritable: vi.fn(async () => writable),\n    });\n\n    const path = await createTimelineCommand({ projectDir, timelinesDirName: '_timelines' });\n    expect(path).toBe('_timelines/timeline_002.otio');\n    expect(writable.write).toHaveBeenCalled();\n  });\n\n  it('moveEntryCommand calls deps.onDirectoryMoved for directories', async () => {\n    const parent = createDirHandleMock();\n    const targetDir = createDirHandleMock();\n    const { entry } = createDirEntry({ name: 'dir1', path: '_files/dir1', parent });\n\n    const removeEntry = vi.fn(async () => undefined);\n    const onDirectoryMoved = vi.fn(async () => undefined);\n\n    // assertEntryDoesNotExist: directory doesn't exist\n    (targetDir.getDirectoryHandle as any).mockRejectedValueOnce(\n      Object.assign(new Error('nf'), { name: 'NotFoundError' }),\n    );\n\n    // target dir creation\n    const createdDir = createDirHandleMock();\n    (targetDir.getDirectoryHandle as any).mockResolvedValueOnce(createdDir);\n\n    await moveEntryCommand(\n      { source: entry, targetDirHandle: targetDir, targetDirPath: '_files' },\n      { removeEntry, onDirectoryMoved },\n    );\n\n    expect(removeEntry).toHaveBeenCalledWith({\n      parentHandle: parent,\n      name: 'dir1',\n      recursive: true,\n    });\n    expect(onDirectoryMoved).toHaveBeenCalled();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/file-manager/application/fileManagerService.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":12,"messageId":"unexpectedAny","endLine":17,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[557,560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[557,560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":50,"messageId":"unexpectedAny","endLine":18,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[613,616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[613,616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":58,"messageId":"unexpectedAny","endLine":18,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[621,624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[621,624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":17,"messageId":"unexpectedAny","endLine":20,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[647,650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[647,650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":17,"messageId":"unexpectedAny","endLine":54,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1879,1882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1879,1882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":23,"messageId":"unexpectedAny","endLine":55,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1943,1946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1943,1946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":18,"messageId":"unexpectedAny","endLine":56,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2023,2026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2023,2026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":23,"messageId":"unexpectedAny","endLine":85,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3035,3038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3035,3038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":24,"messageId":"unexpectedAny","endLine":86,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3121,3124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3121,3124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":19,"messageId":"unexpectedAny","endLine":190,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6547,6550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6547,6550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":204,"column":23,"messageId":"unexpectedAny","endLine":204,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7119,7122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7119,7122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":21,"messageId":"unexpectedAny","endLine":209,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7247,7250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7247,7250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":21,"messageId":"unexpectedAny","endLine":244,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8371,8374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8371,8374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":19,"messageId":"unexpectedAny","endLine":295,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10010,10013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10010,10013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":69,"messageId":"unexpectedAny","endLine":295,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10060,10063],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10060,10063],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":35,"messageId":"unexpectedAny","endLine":301,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10261,10264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10261,10264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, expect, it, vi } from 'vitest';\nimport { ref } from 'vue';\nimport type { FsEntry } from '../../../../src/types/fs';\nimport { createFileManagerService } from '../../../../src/file-manager/application/fileManagerService';\nimport { VIDEO_DIR_NAME } from '../../../../src/utils/constants';\n\nfunction createAsyncIterable<T>(items: T[]): AsyncIterable<T> {\n  return {\n    async *[Symbol.asyncIterator]() {\n      for (const item of items) yield item;\n    },\n  };\n}\n\nfunction createDirHandleMock(params?: {\n  values?: any[];\n  getDirectoryHandleImpl?: (name: string, opts?: any) => any;\n}) {\n  const handle: any = {\n    kind: 'directory',\n    name: 'root',\n    values: params?.values ? () => createAsyncIterable(params.values!) : undefined,\n    entries: undefined,\n    getDirectoryHandle:\n      params?.getDirectoryHandleImpl ?? vi.fn(async () => ({ kind: 'directory', name: 'child' })),\n    getFileHandle: vi.fn(async () => ({ kind: 'file', name: 'file' })),\n  };\n\n  return handle as unknown as FileSystemDirectoryHandle;\n}\n\nfunction createFileHandleMock(params: { name: string; lastModified?: number; type?: string }) {\n  return {\n    kind: 'file',\n    name: params.name,\n    getFile: vi.fn(async () => {\n      const file = new File(['x'], params.name, { type: params.type ?? 'text/plain' });\n      Object.defineProperty(file, 'lastModified', {\n        value: params.lastModified ?? 1,\n        configurable: true,\n      });\n      return file;\n    }),\n    createWritable: vi.fn(async () => ({ write: vi.fn(), close: vi.fn() })),\n  } as unknown as FileSystemFileHandle;\n}\n\ndescribe('fileManagerService', () => {\n  it('readDirectory filters hidden files when showHiddenFiles=false and sorts directories first', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const dirA: any = { kind: 'directory', name: 'aaa' };\n    const fileHidden: any = { kind: 'file', name: '.secret.txt', getFile: vi.fn() };\n    const fileB: any = createFileHandleMock({ name: 'bbb.txt' });\n\n    const dirHandle = createDirHandleMock({ values: [fileB, fileHidden, dirA] });\n\n    const checkExistingProxies = vi.fn(async () => undefined);\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => false,\n      isPathExpanded: () => false,\n      setPathExpanded: vi.fn(),\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies,\n    });\n\n    const entries = await service.readDirectory(dirHandle);\n\n    expect(entries.map((e) => e.name)).toEqual(['aaa', 'bbb.txt']);\n    expect(entries[0]!.kind).toBe('directory');\n    expect(entries[1]!.kind).toBe('file');\n    expect(checkExistingProxies).not.toHaveBeenCalled();\n  });\n\n  it('readDirectory includes hidden files when showHiddenFiles=true', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const fileHidden: any = { kind: 'file', name: '.secret.txt', getFile: vi.fn() };\n    const fileVisible: any = createFileHandleMock({ name: 'a.txt' });\n    const dirHandle = createDirHandleMock({ values: [fileHidden, fileVisible] });\n\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      isPathExpanded: () => false,\n      setPathExpanded: vi.fn(),\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n    });\n\n    const entries = await service.readDirectory(dirHandle);\n    expect(new Set(entries.map((e) => e.name))).toEqual(new Set(['.secret.txt', 'a.txt']));\n  });\n\n  it('readDirectory calls checkExistingProxies for video files', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const video = createFileHandleMock({ name: 'a.mp4', type: 'video/mp4' });\n    const dirHandle = createDirHandleMock({ values: [video] });\n\n    const checkExistingProxies = vi.fn(async () => undefined);\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      isPathExpanded: () => false,\n      setPathExpanded: vi.fn(),\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies,\n    });\n\n    await service.readDirectory(dirHandle, VIDEO_DIR_NAME);\n\n    expect(checkExistingProxies).toHaveBeenCalledWith([`${VIDEO_DIR_NAME}/a.mp4`]);\n  });\n\n  it('toggleDirectory updates rootEntries expanded state, persists path, and lazy-loads children', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const childFile = createFileHandleMock({ name: 'child.txt' });\n    const childDirHandle = createDirHandleMock({ values: [childFile] });\n\n    const setPathExpanded = vi.fn();\n\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      hasPersistedFileTreeState: () => false,\n      isPathExpanded: () => false,\n      setPathExpanded,\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n    });\n\n    const entry: FsEntry = {\n      name: 'folder',\n      kind: 'directory',\n      handle: childDirHandle,\n      parentHandle: undefined,\n      path: 'folder',\n      expanded: false,\n      children: undefined,\n    };\n\n    rootEntries.value = [entry];\n\n    await service.toggleDirectory(entry);\n\n    const updated = rootEntries.value[0];\n    expect(updated?.expanded).toBe(true);\n    expect(setPathExpanded).toHaveBeenCalledWith('folder', true);\n    expect(updated?.children?.map((e) => e.name)).toEqual(['child.txt']);\n  });\n\n  it('readDirectory reports error via onError when iteration is not available', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const onError = vi.fn();\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      isPathExpanded: () => false,\n      setPathExpanded: vi.fn(),\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n      onError,\n    });\n\n    const noIter: any = { kind: 'directory', name: 'root', values: undefined, entries: undefined };\n    const result = await service.readDirectory(noIter as FileSystemDirectoryHandle);\n\n    expect(result).toEqual([]);\n    expect(onError).toHaveBeenCalledWith({\n      title: 'File manager error',\n      message: 'Failed to read directory: iteration is not available',\n    });\n  });\n\n  it('loadProjectDirectory merges entries and auto-expands media dirs', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const sourcesDir: any = {\n      kind: 'directory',\n      name: 'sources',\n      values: () => createAsyncIterable([]),\n    };\n    const videoDir: any = {\n      kind: 'directory',\n      name: VIDEO_DIR_NAME,\n      values: () => createAsyncIterable([]),\n    };\n\n    const projectDir = createDirHandleMock({ values: [sourcesDir, videoDir] });\n\n    const setPathExpanded = vi.fn();\n\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      isPathExpanded: () => false,\n      setPathExpanded,\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n    });\n\n    await service.loadProjectDirectory(projectDir);\n\n    const names = rootEntries.value.map((e) => e.name);\n    expect(new Set(names)).toEqual(new Set(['sources', VIDEO_DIR_NAME]));\n\n    const videoEntry = rootEntries.value.find((e) => e.name === VIDEO_DIR_NAME);\n    expect(videoEntry?.expanded).toBe(true);\n  });\n\n  it('loadProjectDirectory does not auto-expand media dirs when persisted tree state exists', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const videoDir: any = {\n      kind: 'directory',\n      name: VIDEO_DIR_NAME,\n      values: () => createAsyncIterable([]),\n    };\n\n    const projectDir = createDirHandleMock({ values: [videoDir] });\n\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      hasPersistedFileTreeState: () => true,\n      isPathExpanded: () => false,\n      setPathExpanded: vi.fn(),\n      getExpandedPaths: () => [],\n      sanitizeHandle: (h) => h,\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n    });\n\n    await service.loadProjectDirectory(projectDir);\n\n    const videoEntry = rootEntries.value.find((e) => e.name === VIDEO_DIR_NAME);\n    expect(videoEntry?.expanded).toBe(false);\n  });\n\n  it('expandPersistedDirectories expands saved paths and loads children', async () => {\n    const rootEntries = ref<FsEntry[]>([]);\n    const sortMode = ref<'name' | 'modified'>('name');\n\n    const childFile = createFileHandleMock({ name: 'child.txt' });\n    const nestedDirHandle = createDirHandleMock({ values: [childFile] });\n\n    const folderHandle = createDirHandleMock({\n      values: [\n        { kind: 'directory', name: 'nested', values: () => createAsyncIterable([childFile]) },\n      ],\n    });\n\n    const getExpandedPaths = () => ['folder/nested'];\n    const setPathExpanded = vi.fn();\n\n    const service = createFileManagerService({\n      rootEntries,\n      sortMode,\n      showHiddenFiles: () => true,\n      isPathExpanded: (path) => path === 'folder/nested',\n      setPathExpanded,\n      getExpandedPaths,\n      sanitizeHandle: (h) => {\n        if ((h as any).name === 'nested') return nestedDirHandle as any;\n        return h;\n      },\n      sanitizeParentHandle: (h) => h,\n      checkExistingProxies: vi.fn(async () => undefined),\n      getDirectoryIterator: (dir) => {\n        const rawValues = (dir as any).values?.();\n        return rawValues ?? null;\n      },\n    });\n\n    rootEntries.value = [\n      {\n        name: 'folder',\n        kind: 'directory',\n        handle: folderHandle,\n        parentHandle: undefined,\n        path: 'folder',\n        expanded: false,\n        children: undefined,\n      },\n    ];\n\n    await service.expandPersistedDirectories();\n\n    const folder = rootEntries.value[0]!;\n    expect(folder.expanded).toBe(true);\n    expect(setPathExpanded).toHaveBeenCalledWith('folder', true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/file-manager/core/tree.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/monitor-time.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/project-settings-normalization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/repositories/gran-fs.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":58,"messageId":"unexpectedAny","endLine":32,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[773,776],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[773,776],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":58,"messageId":"unexpectedAny","endLine":38,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[982,985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[982,985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":53,"messageId":"unexpectedAny","endLine":44,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1205,1208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1205,1208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":58,"messageId":"unexpectedAny","endLine":45,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1286,1289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1286,1289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, it, expect } from 'vitest';\nimport { readJsonFromFileHandle, writeJsonToFileHandle } from '../../../src/repositories/gran-fs';\n\nfunction createFileHandleMock(initialText: string) {\n  let text = initialText;\n\n  return {\n    async getFile() {\n      return {\n        async text() {\n          return text;\n        },\n      };\n    },\n    async createWritable() {\n      return {\n        async write(data: string) {\n          text = data;\n        },\n        async close() {\n          // no-op\n        },\n      };\n    },\n  };\n}\n\ndescribe('gran-fs', () => {\n  it('readJsonFromFileHandle returns null on empty text', async () => {\n    const handle = createFileHandleMock('   ');\n    const value = await readJsonFromFileHandle(handle as any);\n    expect(value).toBeNull();\n  });\n\n  it('readJsonFromFileHandle parses JSON', async () => {\n    const handle = createFileHandleMock('{\"a\":1}');\n    const value = await readJsonFromFileHandle(handle as any);\n    expect(value).toEqual({ a: 1 });\n  });\n\n  it('writeJsonToFileHandle writes pretty JSON with newline', async () => {\n    const handle = createFileHandleMock('');\n    await writeJsonToFileHandle({ handle: handle as any, data: { a: 1 } });\n    const value = await readJsonFromFileHandle(handle as any);\n    expect(value).toEqual({ a: 1 });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/repositories/project-meta.repository.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":33,"messageId":"unexpectedAny","endLine":29,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[627,630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[627,630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":32,"messageId":"unexpectedAny","endLine":30,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[666,669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[666,669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":20,"messageId":"unexpectedAny","endLine":36,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":20,"messageId":"unexpectedAny","endLine":47,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1215,1218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1215,1218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":74,"messageId":"unexpectedAny","endLine":61,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1633,1636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1633,1636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":23,"messageId":"unexpectedAny","endLine":67,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1764,1767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1764,1767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":74,"messageId":"unexpectedAny","endLine":82,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2420,2423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2420,2423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, it, expect } from 'vitest';\nimport { createProjectMetaRepository } from '../../../src/repositories/project-meta.repository';\n\nfunction createFileHandleMock(input: { text: string }) {\n  let text = input.text;\n  return {\n    async getFile() {\n      return {\n        async text() {\n          return text;\n        },\n      };\n    },\n    async createWritable() {\n      return {\n        async write(data: string) {\n          text = data;\n        },\n        async close() {\n          // no-op\n        },\n      };\n    },\n  };\n}\n\nfunction createDirMock() {\n  const files = new Map<string, any>();\n  const dirs = new Map<string, any>();\n\n  return {\n    async getDirectoryHandle(name: string, options?: { create?: boolean }) {\n      if (dirs.has(name)) return dirs.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createDirMock();\n      dirs.set(name, next);\n      return next;\n    },\n    async getFileHandle(name: string, options?: { create?: boolean }) {\n      if (files.has(name)) return files.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createFileHandleMock({ text: '' });\n      files.set(name, next);\n      return next;\n    },\n  };\n}\n\ndescribe('project-meta.repository', () => {\n  it('returns null on missing file', async () => {\n    const projectDir = createDirMock();\n    const repo = createProjectMetaRepository({ projectDir: projectDir as any });\n\n    expect(await repo.load()).toBeNull();\n  });\n\n  it('returns null on invalid data', async () => {\n    const projectDir: any = createDirMock();\n\n    await projectDir.getDirectoryHandle('.gran', { create: true });\n    const granDir = await projectDir.getDirectoryHandle('.gran', { create: true });\n    const metaFile = await granDir.getFileHandle('project.meta.json', { create: true });\n    const writable = await metaFile.createWritable();\n    await writable.write('{\"id\": 123}');\n    await writable.close();\n\n    const repo = createProjectMetaRepository({ projectDir });\n    expect(await repo.load()).toBeNull();\n  });\n\n  it('saves and loads meta', async () => {\n    const projectDir = createDirMock();\n    const repo = createProjectMetaRepository({ projectDir: projectDir as any });\n\n    await repo.save({ id: 'abc' });\n    expect(await repo.load()).toEqual({ id: 'abc' });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/repositories/project-settings.repository.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":33,"messageId":"unexpectedAny","endLine":29,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[635,638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[635,638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":32,"messageId":"unexpectedAny","endLine":30,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[674,677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[674,677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":20,"messageId":"unexpectedAny","endLine":36,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[869,872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[869,872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":20,"messageId":"unexpectedAny","endLine":47,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1223,1226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1223,1226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":78,"messageId":"unexpectedAny","endLine":65,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1696,1699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1696,1699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":78,"messageId":"unexpectedAny","endLine":72,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1926,1929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1926,1929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":20,"messageId":"unexpectedAny","endLine":121,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3042,3045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3042,3045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":20,"messageId":"unexpectedAny","endLine":122,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3093,3096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3093,3096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, it, expect } from 'vitest';\nimport { createProjectSettingsRepository } from '../../../src/repositories/project-settings.repository';\n\nfunction createFileHandleMock(input: { text: string }) {\n  let text = input.text;\n  return {\n    async getFile() {\n      return {\n        async text() {\n          return text;\n        },\n      };\n    },\n    async createWritable() {\n      return {\n        async write(data: string) {\n          text = data;\n        },\n        async close() {\n          // no-op\n        },\n      };\n    },\n  };\n}\n\nfunction createDirMock() {\n  const files = new Map<string, any>();\n  const dirs = new Map<string, any>();\n\n  return {\n    async getDirectoryHandle(name: string, options?: { create?: boolean }) {\n      if (dirs.has(name)) return dirs.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createDirMock();\n      dirs.set(name, next);\n      return next;\n    },\n    async getFileHandle(name: string, options?: { create?: boolean }) {\n      if (files.has(name)) return files.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createFileHandleMock({ text: '' });\n      files.set(name, next);\n      return next;\n    },\n    __debug: {\n      files,\n      dirs,\n    },\n  };\n}\n\ndescribe('project-settings.repository', () => {\n  it('returns null on missing file', async () => {\n    const projectDir = createDirMock();\n    const repo = createProjectSettingsRepository({ projectDir: projectDir as any });\n\n    expect(await repo.load()).toBeNull();\n  });\n\n  it('saves and loads project settings', async () => {\n    const projectDir = createDirMock();\n    const repo = createProjectSettingsRepository({ projectDir: projectDir as any });\n\n    await repo.save({\n      project: {\n        width: 1920,\n        height: 1080,\n        fps: 25,\n        resolutionFormat: '1080p',\n        orientation: 'landscape',\n        aspectRatio: '16:9',\n        isCustomResolution: false,\n        audioChannels: 'stereo',\n        sampleRate: 48000,\n      },\n      exportDefaults: {\n        encoding: {\n          format: 'mp4',\n          videoCodec: 'avc1.640032',\n          bitrateMbps: 5,\n          excludeAudio: false,\n          audioCodec: 'aac',\n          audioBitrateKbps: 128,\n          bitrateMode: 'variable',\n          keyframeIntervalSec: 2,\n          exportAlpha: false,\n          metadata: {\n            title: '',\n            author: '',\n            tags: '',\n          },\n        },\n      },\n      monitor: {\n        previewResolution: 480,\n        useProxy: true,\n        panX: 0,\n        panY: 0,\n      },\n      timelines: {\n        openPaths: [],\n        lastOpenedPath: null,\n      },\n      transitions: {\n        defaultDurationUs: 2_000_000,\n      },\n    });\n\n    const raw = await repo.load();\n    expect(raw).toBeTruthy();\n    expect((raw as any).project.width).toBe(1920);\n    expect((raw as any).exportDefaults.encoding.metadata).toBeTruthy();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/repositories/workspace-handle.repository.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":58,"messageId":"unexpectedAny","endLine":7,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[346,349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[346,349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, it, expect } from 'vitest';\nimport { createInMemoryWorkspaceHandleStorage } from '../../../src/repositories/workspace-handle.repository';\n\ndescribe('workspace-handle.repository', () => {\n  it('in memory storage: set/get/clear', async () => {\n    const storage = createInMemoryWorkspaceHandleStorage<any>();\n\n    expect(await storage.get()).toBeNull();\n\n    await storage.set({ foo: 1 });\n    expect(await storage.get()).toEqual({ foo: 1 });\n\n    await storage.clear();\n    expect(await storage.get()).toBeNull();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/repositories/workspace-settings.repository.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":33,"messageId":"unexpectedAny","endLine":29,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":32,"messageId":"unexpectedAny","endLine":30,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[678,681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[678,681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":20,"messageId":"unexpectedAny","endLine":36,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[873,876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[873,876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":20,"messageId":"unexpectedAny","endLine":47,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1227,1230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1227,1230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":76,"messageId":"unexpectedAny","endLine":65,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1695,1698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1695,1698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":76,"messageId":"unexpectedAny","endLine":73,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1985,1988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1985,1988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":23,"messageId":"unexpectedAny","endLine":129,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3501,3504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3501,3504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, it, expect } from 'vitest';\nimport { createWorkspaceSettingsRepository } from '../../../src/repositories/workspace-settings.repository';\n\nfunction createFileHandleMock(input: { text: string }) {\n  let text = input.text;\n  return {\n    async getFile() {\n      return {\n        async text() {\n          return text;\n        },\n      };\n    },\n    async createWritable() {\n      return {\n        async write(data: string) {\n          text = data;\n        },\n        async close() {\n          // no-op\n        },\n      };\n    },\n  };\n}\n\nfunction createDirMock() {\n  const files = new Map<string, any>();\n  const dirs = new Map<string, any>();\n\n  return {\n    async getDirectoryHandle(name: string, options?: { create?: boolean }) {\n      if (dirs.has(name)) return dirs.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createDirMock();\n      dirs.set(name, next);\n      return next;\n    },\n    async getFileHandle(name: string, options?: { create?: boolean }) {\n      if (files.has(name)) return files.get(name);\n      if (!options?.create) {\n        const err: any = new Error('NotFound');\n        err.name = 'NotFoundError';\n        throw err;\n      }\n      const next = createFileHandleMock({ text: '' });\n      files.set(name, next);\n      return next;\n    },\n    __debug: {\n      files,\n      dirs,\n    },\n  };\n}\n\ndescribe('workspace-settings.repository', () => {\n  it('returns null on missing files', async () => {\n    const root = createDirMock();\n    const repo = createWorkspaceSettingsRepository({ workspaceDir: root as any });\n\n    expect(await repo.loadUserSettings()).toBeNull();\n    expect(await repo.loadWorkspaceSettings()).toBeNull();\n  });\n\n  it('saves and loads user settings', async () => {\n    const root = createDirMock();\n    const repo = createWorkspaceSettingsRepository({ workspaceDir: root as any });\n\n    await repo.saveUserSettings({\n      openLastProjectOnStart: true,\n      stopFrames: { qualityPercent: 85 },\n      hotkeys: { bindings: {} },\n      optimization: {\n        proxyResolution: '720p',\n        proxyVideoBitrateMbps: 2,\n        proxyAudioBitrateKbps: 128,\n        proxyCopyOpusAudio: true,\n        autoCreateProxies: true,\n        proxyConcurrency: 2,\n      },\n      projectDefaults: {\n        width: 1920,\n        height: 1080,\n        fps: 25,\n        resolutionFormat: '1080p',\n        orientation: 'landscape',\n        aspectRatio: '16:9',\n        isCustomResolution: false,\n        audioChannels: 'stereo',\n        sampleRate: 48000,\n      },\n      exportDefaults: {\n        encoding: {\n          format: 'mp4',\n          videoCodec: 'avc1.640032',\n          bitrateMbps: 5,\n          excludeAudio: false,\n          audioCodec: 'aac',\n          audioBitrateKbps: 128,\n          bitrateMode: 'variable',\n          keyframeIntervalSec: 2,\n          exportAlpha: false,\n        },\n      },\n      mouse: {\n        timeline: {\n          wheel: 'scroll_vertical',\n          wheelShift: 'scroll_horizontal',\n          wheelSecondary: 'scroll_horizontal',\n          wheelSecondaryShift: 'zoom_vertical',\n          middleClick: 'pan',\n        },\n        monitor: {\n          wheel: 'zoom',\n          wheelShift: 'scroll_horizontal',\n          middleClick: 'pan',\n        },\n      },\n    });\n\n    const loaded = await repo.loadUserSettings();\n    expect(loaded).toBeTruthy();\n    expect((loaded as any).openLastProjectOnStart).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/settings-normalization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/stores/focus.store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/stores/history.store.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'current' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":79,"column":11,"messageId":"unusedVar","endLine":79,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach } from 'vitest';\nimport { setActivePinia, createPinia } from 'pinia';\nimport { useHistoryStore } from '../../../src/stores/history.store';\nimport type { TimelineDocument } from '../../../src/timeline/types';\n\nfunction makeDoc(id: string): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id,\n    name: id,\n    timebase: { fps: 30 },\n    tracks: [],\n  } as unknown as TimelineDocument;\n}\n\ndescribe('HistoryStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia());\n  });\n\n  it('starts empty', () => {\n    const store = useHistoryStore();\n    expect(store.past).toHaveLength(0);\n    expect(store.future).toHaveLength(0);\n    expect(store.canUndo).toBe(false);\n    expect(store.canRedo).toBe(false);\n  });\n\n  it('push adds entry to past and clears future', () => {\n    const store = useHistoryStore();\n    const doc = makeDoc('doc-1');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, doc);\n\n    expect(store.past).toHaveLength(1);\n    expect(store.past[0]?.commandType).toBe('add_clip_to_track');\n    expect(store.past[0]?.label).toBe('Add clip');\n    expect(store.past[0]?.snapshot).toStrictEqual(doc);\n    expect(store.canUndo).toBe(true);\n    expect(store.canRedo).toBe(false);\n  });\n\n  it('push clears future (branching)', () => {\n    const store = useHistoryStore();\n    const doc1 = makeDoc('doc-1');\n    const doc2 = makeDoc('doc-2');\n    const doc3 = makeDoc('doc-3');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, doc1);\n    store.push({ type: 'remove_item', trackId: 't1', itemId: 'i1' }, doc2);\n\n    store.undo(doc3);\n    expect(store.future).toHaveLength(1);\n\n    store.push({ type: 'rename_item', trackId: 't1', itemId: 'i1', name: 'new' }, doc2);\n    expect(store.future).toHaveLength(0);\n  });\n\n  it('undo restores previous snapshot and moves entry to future', () => {\n    const store = useHistoryStore();\n    const snap1 = makeDoc('snap-1');\n    const current = makeDoc('current');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, snap1);\n\n    const restored = store.undo(current);\n\n    expect(restored).toStrictEqual(snap1);\n    expect(store.past).toHaveLength(0);\n    expect(store.future).toHaveLength(1);\n    expect(store.canUndo).toBe(false);\n    expect(store.canRedo).toBe(true);\n  });\n\n  it('redo restores future snapshot and moves entry back to past', () => {\n    const store = useHistoryStore();\n    const snap1 = makeDoc('snap-1');\n    const snap2 = makeDoc('snap-2');\n    const current = makeDoc('current');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, snap1);\n    store.undo(snap2);\n\n    const restored = store.redo(snap1);\n\n    expect(restored).toStrictEqual(snap2);\n    expect(store.past).toHaveLength(1);\n    expect(store.future).toHaveLength(0);\n    expect(store.canRedo).toBe(false);\n  });\n\n  it('undo returns null when no history', () => {\n    const store = useHistoryStore();\n    const result = store.undo(makeDoc('x'));\n    expect(result).toBeNull();\n  });\n\n  it('redo returns null when no future', () => {\n    const store = useHistoryStore();\n    const result = store.redo(makeDoc('x'));\n    expect(result).toBeNull();\n  });\n\n  it('clear resets all state', () => {\n    const store = useHistoryStore();\n    const doc = makeDoc('doc-1');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, doc);\n    store.push({ type: 'remove_item', trackId: 't1', itemId: 'i1' }, doc);\n\n    store.clear();\n\n    expect(store.past).toHaveLength(0);\n    expect(store.future).toHaveLength(0);\n    expect(store.canUndo).toBe(false);\n  });\n\n  it('limits history to MAX_HISTORY_SIZE (100)', () => {\n    const store = useHistoryStore();\n    const doc = makeDoc('doc');\n\n    for (let i = 0; i < 110; i++) {\n      store.push({ type: 'remove_item', trackId: 't1', itemId: `i${i}` }, doc);\n    }\n\n    expect(store.past.length).toBeLessThanOrEqual(100);\n  });\n\n  it('lastEntry reflects the most recent past entry', () => {\n    const store = useHistoryStore();\n    const doc = makeDoc('doc');\n\n    expect(store.lastEntry).toBeNull();\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'clip', path: '/a.mp4' }, doc);\n    store.push({ type: 'remove_item', trackId: 't1', itemId: 'i1' }, doc);\n\n    expect(store.lastEntry?.commandType).toBe('remove_item');\n  });\n\n  it('multiple undo/redo cycle preserves order', () => {\n    const store = useHistoryStore();\n    const snap1 = makeDoc('snap-1');\n    const snap2 = makeDoc('snap-2');\n    const snap3 = makeDoc('snap-3');\n\n    store.push({ type: 'add_clip_to_track', trackId: 't1', name: 'c1', path: '/a.mp4' }, snap1);\n    store.push({ type: 'remove_item', trackId: 't1', itemId: 'i1' }, snap2);\n\n    // Undo twice\n    const r1 = store.undo(snap3);\n    expect(r1).toStrictEqual(snap2);\n\n    const r2 = store.undo(snap2);\n    expect(r2).toStrictEqual(snap1);\n\n    // Redo once\n    const r3 = store.redo(snap1);\n    expect(r3).toStrictEqual(snap2);\n\n    expect(store.past).toHaveLength(1);\n    expect(store.future).toHaveLength(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/stores/timeline.store.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":10,"messageId":"unexpectedAny","endLine":144,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3987,3990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3987,3990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":40,"messageId":"unexpectedAny","endLine":149,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4143,4146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4143,4146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":71,"messageId":"unexpectedAny","endLine":149,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4174,4177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4174,4177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":182,"column":10,"messageId":"unexpectedAny","endLine":182,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5142,5145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5142,5145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":40,"messageId":"unexpectedAny","endLine":187,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5291,5294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5291,5294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":71,"messageId":"unexpectedAny","endLine":187,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5322,5325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5322,5325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":10,"messageId":"unexpectedAny","endLine":220,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6203,6206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6203,6206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":40,"messageId":"unexpectedAny","endLine":223,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6313,6316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6313,6316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":73,"messageId":"unexpectedAny","endLine":233,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6636,6639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6636,6639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":10,"messageId":"unexpectedAny","endLine":280,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7940,7943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7940,7943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":10,"messageId":"unexpectedAny","endLine":336,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9491,9494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9491,9494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":10,"messageId":"unexpectedAny","endLine":374,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10564,10567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10564,10567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":380,"column":41,"messageId":"unexpectedAny","endLine":380,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10718,10721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10718,10721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":12,"messageId":"unexpectedAny","endLine":381,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10758,10761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10758,10761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":414,"column":10,"messageId":"unexpectedAny","endLine":414,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11622,11625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11622,11625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":420,"column":45,"messageId":"unexpectedAny","endLine":420,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11787,11790],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11787,11790],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":421,"column":12,"messageId":"unexpectedAny","endLine":421,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11827,11830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11827,11830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":10,"messageId":"unexpectedAny","endLine":452,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12710,12713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12710,12713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":457,"column":46,"messageId":"unexpectedAny","endLine":457,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12876,12879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12876,12879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":458,"column":12,"messageId":"unexpectedAny","endLine":458,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12916,12919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12916,12919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":10,"messageId":"unexpectedAny","endLine":494,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13908,13911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13908,13911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":498,"column":38,"messageId":"unexpectedAny","endLine":498,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14027,14030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14027,14030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":498,"column":69,"messageId":"unexpectedAny","endLine":498,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14058,14061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14058,14061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":502,"column":34,"messageId":"unexpectedAny","endLine":502,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14195,14198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14195,14198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":502,"column":65,"messageId":"unexpectedAny","endLine":502,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14226,14229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14226,14229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":506,"column":34,"messageId":"unexpectedAny","endLine":506,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14361,14364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14361,14364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":506,"column":65,"messageId":"unexpectedAny","endLine":506,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14392,14395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14392,14395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":526,"column":10,"messageId":"unexpectedAny","endLine":526,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14860,14863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14860,14863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":548,"column":41,"messageId":"unexpectedAny","endLine":548,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15376,15379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15376,15379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":548,"column":62,"messageId":"unexpectedAny","endLine":548,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15397,15400],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15397,15400],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":10,"messageId":"unexpectedAny","endLine":573,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16050,16053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16050,16053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":601,"column":41,"messageId":"unexpectedAny","endLine":601,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16688,16691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16688,16691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":601,"column":62,"messageId":"unexpectedAny","endLine":601,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16709,16712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16709,16712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":626,"column":10,"messageId":"unexpectedAny","endLine":626,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17368,17371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17368,17371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":686,"column":41,"messageId":"unexpectedAny","endLine":686,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18996,18999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18996,18999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":686,"column":72,"messageId":"unexpectedAny","endLine":686,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19027,19030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19027,19030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":36,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { setActivePinia, createPinia } from 'pinia';\nimport { useTimelineStore } from '../../../src/stores/timeline.store';\nimport { useHistoryStore } from '../../../src/stores/history.store';\n\nconst projectStoreMock = {\n  currentProjectName: 'test',\n  currentTimelinePath: 'timeline.otio',\n  getFileHandleByPath: vi.fn(),\n  createFallbackTimelineDoc: () => ({\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc-1',\n    name: 'Default',\n    timebase: { fps: 30 },\n    tracks: [\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'Video 1',\n        items: [],\n      },\n    ],\n  }),\n};\n\nvi.mock('../../../src/stores/project.store', () => ({\n  useProjectStore: () => projectStoreMock,\n}));\n\nconst mediaStoreMock = {\n  mediaMetadata: { value: {} },\n  getOrFetchMetadataByPath: vi.fn(),\n  getOrFetchMetadata: vi.fn(),\n};\n\nvi.mock('../../../src/stores/media.store', () => ({\n  useMediaStore: () => mediaStoreMock,\n}));\n\ndescribe('TimelineStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia());\n    projectStoreMock.getFileHandleByPath.mockReset();\n    mediaStoreMock.getOrFetchMetadataByPath.mockReset();\n    mediaStoreMock.getOrFetchMetadata.mockReset();\n  });\n\n  it('initializes with default state', () => {\n    const store = useTimelineStore();\n    expect(store.timelineDoc).toBeNull();\n    expect(store.isPlaying).toBe(false);\n    expect(store.audioVolume).toBe(1);\n  });\n\n  it('manages item selection', () => {\n    const store = useTimelineStore();\n    store.toggleSelection('item-1');\n    expect(store.selectedItemIds).toEqual(['item-1']);\n\n    store.toggleSelection('item-2', { multi: true });\n    expect(store.selectedItemIds).toContain('item-1');\n    expect(store.selectedItemIds).toContain('item-2');\n\n    store.clearSelection();\n    expect(store.selectedItemIds).toEqual([]);\n  });\n\n  it('sets audio volume and unmutes when positive', () => {\n    const store = useTimelineStore();\n    store.audioMuted = true;\n    store.setAudioVolume(0.5);\n    expect(store.audioVolume).toBe(0.5);\n    expect(store.audioMuted).toBe(false);\n  });\n\n  it('toggles playback', () => {\n    const store = useTimelineStore();\n    const handler = vi.fn();\n    store.setPlaybackGestureHandler(handler);\n\n    store.togglePlayback();\n    expect(store.isPlaying).toBe(true);\n    expect(handler).toHaveBeenCalledWith(true);\n\n    store.togglePlayback();\n    expect(store.isPlaying).toBe(false);\n    expect(handler).toHaveBeenCalledWith(false);\n  });\n\n  it('allows negative playback speed and clamps magnitude', () => {\n    const store = useTimelineStore();\n\n    store.setPlaybackSpeed(-2);\n    expect(store.playbackSpeed).toBe(-2);\n\n    store.setPlaybackSpeed(-999);\n    expect(store.playbackSpeed).toBe(-10);\n\n    store.setPlaybackSpeed(-0.00001);\n    expect(store.playbackSpeed).toBe(-0.1);\n  });\n\n  it('resets state correctly', () => {\n    const store = useTimelineStore();\n    store.isPlaying = true;\n    store.currentTime = 100;\n    store.timelineZoom = 80;\n\n    store.resetTimelineState();\n\n    expect(store.isPlaying).toBe(false);\n    expect(store.currentTime).toBe(0);\n    expect(store.timelineZoom).toBe(50);\n  });\n\n  it('sets freeze frame from playhead when playhead is inside clip', () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 1_000_000, durationUs: 2_000_000 },\n              sourceRange: { startUs: 0, durationUs: 2_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.currentTime = 1_500_000;\n    store.setClipFreezeFrameFromPlayhead({ trackId: 'v1', itemId: 'c1' });\n\n    const clip = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.id === 'c1');\n    expect(typeof clip.freezeFrameSourceUs).toBe('number');\n    expect(clip.freezeFrameSourceUs).toBeGreaterThanOrEqual(0);\n  });\n\n  it('sets freeze frame to first frame when playhead is outside clip', () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 1_000_000, durationUs: 2_000_000 },\n              sourceRange: { startUs: 123_000, durationUs: 2_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.currentTime = 10;\n    store.setClipFreezeFrameFromPlayhead({ trackId: 'v1', itemId: 'c1' });\n\n    const clip = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.id === 'c1');\n    expect(clip.freezeFrameSourceUs).toBe(133_333);\n  });\n\n  it('resets freeze frame', () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 2_000_000 },\n              sourceRange: { startUs: 0, durationUs: 2_000_000 },\n              freezeFrameSourceUs: 1_000,\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.resetClipFreezeFrame({ trackId: 'v1', itemId: 'c1' });\n    const clip = (store.timelineDoc as any).tracks[0].items[0];\n    expect(clip.freezeFrameSourceUs).toBeUndefined();\n  });\n\n  it('debounces history entries when requested', () => {\n    vi.useFakeTimers();\n\n    const store = useTimelineStore();\n    const historyStore = useHistoryStore();\n\n    store.timelineDoc = projectStoreMock.createFallbackTimelineDoc() as any;\n\n    store.applyTimeline(\n      { type: 'add_track', kind: 'audio', name: 'Audio 1' },\n      { historyMode: 'debounced', historyDebounceMs: 100, saveMode: 'none' },\n    );\n    store.applyTimeline(\n      { type: 'add_track', kind: 'audio', name: 'Audio 2' },\n      { historyMode: 'debounced', historyDebounceMs: 100, saveMode: 'none' },\n    );\n\n    expect(historyStore.past).toHaveLength(0);\n\n    vi.advanceTimersByTime(110);\n    expect(historyStore.past).toHaveLength(1);\n\n    vi.useRealTimers();\n  });\n\n  it('jumps to previous/next clip boundary (all tracks)', () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 1_000_000, durationUs: 2_000_000 },\n              sourceRange: { startUs: 0, durationUs: 2_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.currentTime = 2_500_000;\n    store.jumpToPrevClipBoundary();\n    expect(store.currentTime).toBe(1_000_000);\n\n    store.jumpToNextClipBoundary();\n    expect(store.currentTime).toBe(3_000_000);\n  });\n\n  it('jumps to previous/next clip boundary (current track only)', () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 1_000_000, durationUs: 1_000_000 },\n              sourceRange: { startUs: 0, durationUs: 1_000_000 },\n            },\n          ],\n        },\n        {\n          id: 'a1',\n          kind: 'audio',\n          name: 'Audio 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'ac1',\n              trackId: 'a1',\n              name: 'Audio Clip 1',\n              source: { path: '/a.wav' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 5_000_000, durationUs: 1_000_000 },\n              sourceRange: { startUs: 0, durationUs: 1_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.selectTrack('v1');\n    store.currentTime = 5_500_000;\n    store.jumpToPrevClipBoundary({ currentTrackOnly: true });\n    expect(store.currentTime).toBe(2_000_000);\n    store.jumpToNextClipBoundary({ currentTrackOnly: true });\n    expect(store.currentTime).toBe(6_000_000);\n  });\n\n  it('splits a selected clip at playhead', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 3_000_000 },\n              sourceRange: { startUs: 0, durationUs: 3_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.toggleSelection('c1');\n    store.currentTime = 1_000_000;\n    await store.splitClipAtPlayhead();\n\n    const clips = (store.timelineDoc as any).tracks[0].items.filter(\n      (it: any) => it.kind === 'clip',\n    );\n    expect(clips).toHaveLength(2);\n  });\n\n  it('trims left/right to playhead without ripple', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 3_000_000 },\n              sourceRange: { startUs: 0, durationUs: 3_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.toggleSelection('c1');\n    store.currentTime = 1_000_000;\n    await store.trimToPlayheadLeftNoRipple();\n\n    const afterLeft = (store.timelineDoc as any).tracks[0].items.filter(\n      (it: any) => it.kind === 'clip',\n    );\n    expect(afterLeft).toHaveLength(1);\n    expect(afterLeft[0].timelineRange.durationUs).toBeGreaterThan(0);\n    expect(afterLeft[0].timelineRange.startUs).toBe(0);\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 3_000_000 },\n              sourceRange: { startUs: 0, durationUs: 3_000_000 },\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.toggleSelection('c1');\n    store.currentTime = 1_000_000;\n    await store.trimToPlayheadRightNoRipple();\n    const afterRight = (store.timelineDoc as any).tracks[0].items.filter(\n      (it: any) => it.kind === 'clip',\n    );\n    expect(afterRight).toHaveLength(1);\n    expect(afterRight[0].timelineRange.startUs).toBeGreaterThan(0);\n  });\n\n  it('toggles disable and mute on target clip', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              clipType: 'media',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip 1',\n              source: { path: '/a.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 3_000_000 },\n              sourceRange: { startUs: 0, durationUs: 3_000_000 },\n              audioGain: 1,\n              disabled: false,\n            },\n          ],\n        },\n      ],\n    } as any;\n\n    store.toggleSelection('c1');\n    await store.toggleDisableTargetClip();\n    let clip = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.id === 'c1');\n    expect(clip.disabled).toBe(true);\n\n    await store.toggleMuteTargetClip();\n    clip = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.id === 'c1');\n    expect(clip.audioGain).toBe(0);\n\n    await store.toggleMuteTargetClip();\n    clip = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.id === 'c1');\n    expect(clip.audioGain).toBe(1);\n  });\n\n  it('adds image source to video track with default image duration', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [],\n        },\n      ],\n    } as any;\n\n    projectStoreMock.getFileHandleByPath.mockResolvedValue({\n      getFile: vi.fn(async () => ({\n        type: 'image/png',\n        size: 123,\n        lastModified: 1,\n      })),\n    });\n\n    mediaStoreMock.getOrFetchMetadata.mockResolvedValue({\n      source: { size: 123, lastModified: 1 },\n      duration: 0,\n    });\n\n    await store.addClipToTimelineFromPath({\n      trackId: 'v1',\n      name: 'image.png',\n      path: '_images/image.png',\n      startUs: 0,\n    });\n\n    const track = (store.timelineDoc as any).tracks.find((t: any) => t.id === 'v1');\n    expect(track.items).toHaveLength(1);\n\n    const clip = track.items[0];\n    expect(clip.clipType).toBe('media');\n    expect(clip.timelineRange.durationUs).toBe(5_000_000);\n    expect(clip.sourceDurationUs).toBe(5_000_000);\n  });\n\n  it('adds audio source to audio track using metadata duration', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'a1',\n          kind: 'audio',\n          name: 'Audio 1',\n          items: [],\n        },\n      ],\n    } as any;\n\n    projectStoreMock.getFileHandleByPath.mockResolvedValue({\n      getFile: vi.fn(async () => ({\n        type: 'audio/mpeg',\n        size: 123,\n        lastModified: 1,\n      })),\n    });\n\n    mediaStoreMock.getOrFetchMetadata.mockResolvedValue({\n      source: { size: 123, lastModified: 1 },\n      duration: 3,\n      audio: {\n        codec: 'mp3',\n        parsedCodec: 'mp3',\n        sampleRate: 44100,\n        channels: 2,\n      },\n    });\n\n    await store.addClipToTimelineFromPath({\n      trackId: 'a1',\n      name: 'audio.mp3',\n      path: '_audio/audio.mp3',\n      startUs: 0,\n    });\n\n    const track = (store.timelineDoc as any).tracks.find((t: any) => t.id === 'a1');\n    expect(track.items).toHaveLength(1);\n\n    const clip = track.items[0];\n    expect(clip.clipType).toBe('media');\n    expect(clip.timelineRange.durationUs).toBe(3_000_000);\n    expect(clip.sourceDurationUs).toBe(3_000_000);\n  });\n\n  it('adds nested timeline clip from .otio path and blocks self-drop', async () => {\n    const store = useTimelineStore();\n\n    store.timelineDoc = {\n      OTIO_SCHEMA: 'Timeline.1',\n      id: 'doc-1',\n      name: 'Default',\n      timebase: { fps: 30 },\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [],\n        },\n      ],\n    } as any;\n\n    await expect(\n      store.addTimelineClipToTimelineFromPath({\n        trackId: 'v1',\n        name: 'Self',\n        path: 'timeline.otio',\n        startUs: 0,\n      }),\n    ).rejects.toThrow(/currently opened timeline/i);\n\n    const otio = JSON.stringify(\n      {\n        OTIO_SCHEMA: 'Timeline.1',\n        name: 'Nested',\n        tracks: {\n          OTIO_SCHEMA: 'Stack.1',\n          name: 'tracks',\n          children: [\n            {\n              OTIO_SCHEMA: 'Track.1',\n              name: 'Video 1',\n              kind: 'Video',\n              children: [\n                {\n                  OTIO_SCHEMA: 'Clip.1',\n                  name: 'X',\n                  media_reference: {\n                    OTIO_SCHEMA: 'ExternalReference.1',\n                    target_url: 'file.mp4',\n                  },\n                  source_range: {\n                    OTIO_SCHEMA: 'TimeRange.1',\n                    start_time: { OTIO_SCHEMA: 'RationalTime.1', value: 0, rate: 1000000 },\n                    duration: { OTIO_SCHEMA: 'RationalTime.1', value: 2000000, rate: 1000000 },\n                  },\n                },\n              ],\n            },\n          ],\n        },\n        metadata: { gran: { docId: 'nested', timebase: { fps: 25 } } },\n      },\n      null,\n      2,\n    );\n\n    projectStoreMock.getFileHandleByPath.mockResolvedValue({\n      getFile: async () => ({\n        text: async () => otio,\n      }),\n    });\n\n    await store.addTimelineClipToTimelineFromPath({\n      trackId: 'v1',\n      name: 'Nested.otio',\n      path: 'nested.otio',\n      startUs: 0,\n    });\n\n    const added = (store.timelineDoc as any).tracks[0].items.find((it: any) => it.kind === 'clip');\n    expect(added.clipType).toBe('timeline');\n    expect(added.source.path).toBe('nested.otio');\n    expect(added.timelineRange.durationUs).toBeGreaterThan(0);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/stores/ui.store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/stores/workspace.store.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":10,"messageId":"unexpectedAny","endLine":51,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1634,1637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1634,1637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { setActivePinia, createPinia } from 'pinia';\nimport { nextTick } from 'vue';\nimport { useWorkspaceStore } from '../../../src/stores/workspace.store';\n\ndescribe('WorkspaceStore', () => {\n  beforeEach(() => {\n    setActivePinia(createPinia());\n    vi.clearAllMocks();\n    localStorage.clear();\n  });\n\n  it('initializes with default settings', () => {\n    const store = useWorkspaceStore();\n    expect(store.workspaceHandle).toBeNull();\n    expect(store.projects).toEqual([]);\n    expect(store.userSettings.projectDefaults.width).toBe(1920);\n    expect(store.userSettings.exportDefaults.encoding.format).toBe('mp4');\n  });\n\n  it('updates lastProjectName in localStorage', async () => {\n    const store = useWorkspaceStore();\n    store.lastProjectName = 'test-project';\n    await nextTick();\n    expect(localStorage.getItem('gran-editor-last-project')).toBe('test-project');\n\n    store.lastProjectName = null;\n    await nextTick();\n    expect(localStorage.getItem('gran-editor-last-project')).toBeNull();\n  });\n\n  it('resets workspace state', () => {\n    const store = useWorkspaceStore();\n    store.projects = ['p1', 'p2'];\n    store.error = 'some error';\n\n    store.resetWorkspace();\n\n    expect(store.workspaceHandle).toBeNull();\n    expect(store.projects).toEqual([]);\n    expect(store.error).toBeNull();\n  });\n\n  it('setupWorkspace creates required directories', async () => {\n    const store = useWorkspaceStore();\n\n    const mockDirectoryHandle = {\n      getDirectoryHandle: vi.fn().mockResolvedValue({}),\n      name: 'root',\n      kind: 'directory',\n    } as any;\n\n    await store.setupWorkspace(mockDirectoryHandle);\n\n    expect(mockDirectoryHandle.getDirectoryHandle).toHaveBeenCalledWith('projects', {\n      create: true,\n    });\n    expect(mockDirectoryHandle.getDirectoryHandle).toHaveBeenCalledWith('vardata', {\n      create: true,\n    });\n    expect(store.workspaceHandle).toStrictEqual(mockDirectoryHandle);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-add-text-clip.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":40,"messageId":"unexpectedAny","endLine":34,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[900,903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[900,903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":71,"messageId":"unexpectedAny","endLine":34,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[931,934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[931,934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":37,"messageId":"unexpectedAny","endLine":61,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1599,1602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1599,1602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":58,"messageId":"unexpectedAny","endLine":61,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1620,1623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1620,1623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":89,"messageId":"unexpectedAny","endLine":61,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1651,1654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1651,1654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack } from '~/timeline/types';\n\nfunction makeDoc(track: TimelineTrack): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks: [track],\n  };\n}\n\ndescribe('timeline/commands add_virtual_clip_to_track (text)', () => {\n  it('adds a text clip to a video track with defaults', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'add_virtual_clip_to_track',\n      trackId: 'v1',\n      clipType: 'text',\n      name: 'Text',\n      durationUs: 5_000_000,\n      startUs: 0,\n    }).next;\n\n    const track = next.tracks[0]!;\n    const clip = track.items.find((it: any) => it.kind === 'clip') as any;\n\n    expect(clip).toBeTruthy();\n    expect(clip.clipType).toBe('text');\n    expect(typeof clip.text).toBe('string');\n    expect(clip.text.length).toBeGreaterThan(0);\n  });\n\n  it('respects provided text and style', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'add_virtual_clip_to_track',\n      trackId: 'v1',\n      clipType: 'text',\n      name: 'Title',\n      durationUs: 5_000_000,\n      startUs: 0,\n      text: 'Hello',\n      style: { fontSize: 80, color: '#ff0000', align: 'left' },\n    }).next;\n\n    const clip = (next.tracks[0] as any).items.find((it: any) => it.kind === 'clip') as any;\n    expect(clip.clipType).toBe('text');\n    expect(clip.text).toBe('Hello');\n    expect(clip.style).toEqual({ fontSize: 80, color: '#ff0000', align: 'left' });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-add-track.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-gap.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":92,"messageId":"unexpectedAny","endLine":90,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2637,2640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2637,2640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":92,"messageId":"unexpectedAny","endLine":91,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2733,2736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2733,2736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":92,"messageId":"unexpectedAny","endLine":284,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8388,8391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8388,8391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":285,"column":92,"messageId":"unexpectedAny","endLine":285,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8484,8487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8484,8487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":10,"messageId":"unexpectedAny","endLine":330,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9794,9797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9794,9797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":60,"messageId":"unexpectedAny","endLine":367,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10984,10987],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10984,10987],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":368,"column":10,"messageId":"unexpectedAny","endLine":368,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11011,11014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11011,11014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack, TimelineTrackItem } from '~/timeline/types';\n\nfunction makeDoc(track: TimelineTrack): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks: [track],\n  };\n}\n\ndescribe('timeline/commands gap behavior', () => {\n  it('move_item_to_track on same track behaves like move_item (does not remove clip)', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'move_item_to_track',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'c1',\n      startUs: 2_000_000,\n    });\n\n    const track = next.tracks[0] as TimelineTrack;\n    const clip = track.items.find((x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c1');\n\n    expect(clip).toBeTruthy();\n    expect(clip.timelineRange.startUs).toBe(2_000_000);\n  });\n\n  it('does not create a gap when moving clip to abut previous clip with rounding noise', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 999_999 },\n          sourceRange: { startUs: 0, durationUs: 999_999 },\n        },\n        {\n          kind: 'clip',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 2_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const moved = applyTimelineCommand(doc, {\n      type: 'move_item',\n      trackId: 'v1',\n      itemId: 'c2',\n      startUs: 1_000_000 + 1,\n    }).next;\n\n    const items = moved.tracks[0].items;\n    const gaps = items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n    expect(gaps.length).toBe(0);\n\n    const c1 = items.find((x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c1') as any;\n    const c2 = items.find((x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c2') as any;\n    const endC1 = c1.timelineRange.startUs + c1.timelineRange.durationUs;\n    expect(c2.timelineRange.startUs).toBe(endC1);\n  });\n\n  it('normalizes gaps after move_item (single gap between clips)', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 2_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'move_item',\n      trackId: 'v1',\n      itemId: 'c2',\n      startUs: 3_000_000,\n    });\n\n    const items = next.tracks[0].items;\n    const gaps = items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n\n    expect(gaps.length).toBe(1);\n    expect(gaps[0]?.timelineRange.startUs).toBe(1_000_000);\n    expect(gaps[0]?.timelineRange.durationUs).toBe(2_000_000);\n  });\n\n  it('deletes gap as ripple delete: shifts items to the left', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 2_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const normalized = applyTimelineCommand(doc, {\n      type: 'move_item',\n      trackId: 'v1',\n      itemId: 'c2',\n      startUs: 2_000_000,\n    }).next;\n\n    const gap = normalized.tracks[0].items.find((x: TimelineTrackItem) => x.kind === 'gap');\n    expect(gap?.kind).toBe('gap');\n\n    const { next } = applyTimelineCommand(normalized, {\n      type: 'remove_item',\n      trackId: 'v1',\n      itemId: String(gap?.id),\n    });\n\n    const c2 = next.tracks[0].items.find(\n      (x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c2',\n    );\n    expect(c2?.timelineRange.startUs).toBe(1_000_000);\n\n    const gapsAfter = next.tracks[0].items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n    expect(gapsAfter.length).toBe(0);\n  });\n\n  it('deletes clip without creating multiple gaps; recomputes single gap from clips', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 3_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          id: 'c3',\n          trackId: 'v1',\n          name: 'C3',\n          source: { path: 'c.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 5_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const { next: afterDelete } = applyTimelineCommand(doc, {\n      type: 'remove_item',\n      trackId: 'v1',\n      itemId: 'c2',\n    });\n\n    const items = afterDelete.tracks[0].items;\n    const gaps = items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n\n    expect(gaps.length).toBe(1);\n    expect(gaps[0]?.timelineRange.startUs).toBe(1_000_000);\n    expect(gaps[0]?.timelineRange.durationUs).toBe(4_000_000);\n  });\n\n  it('quantizes to frames and avoids micro-gaps (fps=30)', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 1_000_001, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const moved = applyTimelineCommand(doc, {\n      type: 'move_item',\n      trackId: 'v1',\n      itemId: 'c2',\n      startUs: 1_000_001,\n    }).next;\n\n    const items = moved.tracks[0].items;\n    const c1 = items.find((x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c1') as any;\n    const c2 = items.find((x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c2') as any;\n    expect(c1).toBeTruthy();\n    expect(c2).toBeTruthy();\n\n    const endC1 = c1.timelineRange.startUs + c1.timelineRange.durationUs;\n    expect(c2.timelineRange.startUs).toBeGreaterThanOrEqual(0);\n\n    // No micro-gaps: either abuts or has a full gap item.\n    const gaps = items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n    if (gaps.length === 0) {\n      expect(c2.timelineRange.startUs).toBe(endC1);\n    } else {\n      expect(gaps[0]?.timelineRange.durationUs).toBeGreaterThan(0);\n    }\n  });\n\n  it('trim end supports negative deltas and stays frame-accurate', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const trimmed = applyTimelineCommand(doc, {\n      type: 'trim_item',\n      trackId: 'v1',\n      itemId: 'c1',\n      edge: 'end',\n      deltaUs: -123_456,\n    }).next;\n\n    const c1 = trimmed.tracks[0].items.find(\n      (x: TimelineTrackItem) => x.kind === 'clip' && x.id === 'c1',\n    ) as any;\n    expect(c1.timelineRange.durationUs).toBeGreaterThan(0);\n    // Frame accurate at 30 fps: durationUs should be stable under frame round-trip quantization.\n    const fps = 30;\n    const frames = Math.round((c1.timelineRange.durationUs * fps) / 1_000_000);\n    const reconstructedUs = Math.round((frames * 1_000_000) / fps);\n    expect(c1.timelineRange.durationUs).toBe(reconstructedUs);\n  });\n\n  it('allows extending virtual clips beyond initial duration (no max clamp)', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'background',\n          id: 'b1',\n          trackId: 'v1',\n          name: 'Background',\n          backgroundColor: '#000000',\n          timelineRange: { startUs: 0, durationUs: 5_000_000 },\n          sourceRange: { startUs: 0, durationUs: 5_000_000 },\n        },\n      ],\n    });\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'trim_item',\n      trackId: 'v1',\n      itemId: 'b1',\n      edge: 'end',\n      deltaUs: 20_000_000,\n    });\n\n    const b1 = next.tracks[0].items.find(\n      (x: TimelineTrackItem) => x.kind === 'clip' && (x as any).id === 'b1',\n    ) as any;\n\n    expect(b1).toBeTruthy();\n    expect(b1.timelineRange.durationUs).toBeGreaterThan(5_000_000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-overlay-place.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":58,"messageId":"unexpectedAny","endLine":16,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":11,"messageId":"unexpectedAny","endLine":330,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9901,9904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9901,9904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":19,"messageId":"unexpectedAny","endLine":330,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9909,9912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9909,9912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack, TimelineTrackItem } from '~/timeline/types';\n\nfunction makeDoc(tracks: TimelineTrack[]): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks,\n  };\n}\n\nfunction clips(track: { items: TimelineTrackItem[] }) {\n  return track.items.filter((x) => x.kind === 'clip') as any[];\n}\n\ndescribe('timeline/commands overlay_place_item', () => {\n  it('moves clip to empty area without affecting others', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'c1',\n            trackId: 'v1',\n            name: 'C1',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'c2',\n            trackId: 'v1',\n            name: 'C2',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 3_000_000, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'c1',\n      startUs: 5_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n    expect(resultClips.length).toBe(2);\n\n    const movedClip = resultClips.find((x) => x.id === 'c1');\n    expect(movedClip).toBeTruthy();\n    expect(movedClip.timelineRange.startUs).toBe(5_000_000);\n\n    const otherClip = resultClips.find((x) => x.id === 'c2');\n    expect(otherClip).toBeTruthy();\n    expect(otherClip.timelineRange.startUs).toBe(3_000_000);\n  });\n\n  it('deletes a clip fully covered by the placed clip', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'big',\n            trackId: 'v1',\n            name: 'Big',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 5_000_000 },\n            sourceRange: { startUs: 0, durationUs: 5_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'small',\n            trackId: 'v1',\n            name: 'Small',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 7_000_000, durationUs: 500_000 },\n            sourceRange: { startUs: 0, durationUs: 500_000 },\n          },\n        ],\n      },\n    ]);\n\n    // Place 'big' at 6_000_000 â it will cover 'small' (7_000_000â7_500_000)\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'big',\n      startUs: 6_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    const smallClip = resultClips.find((x) => x.id === 'small');\n    expect(smallClip).toBeUndefined();\n\n    const movedClip = resultClips.find((x) => x.id === 'big');\n    expect(movedClip).toBeTruthy();\n    expect(movedClip.timelineRange.startUs).toBe(6_000_000);\n    expect(movedClip.timelineRange.durationUs).toBe(5_000_000);\n  });\n\n  it('trims end of clip that overlaps on the left', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'left',\n            trackId: 'v1',\n            name: 'Left',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 3_000_000 },\n            sourceRange: { startUs: 0, durationUs: 3_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'right',\n            trackId: 'v1',\n            name: 'Right',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 8_000_000, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    // 'right' clip (2s) placed at 2_000_000 â overlaps 'left' on the left side\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'right',\n      startUs: 2_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    const leftClip = resultClips.find((x) => x.id === 'left');\n    expect(leftClip).toBeTruthy();\n    // Should be trimmed to end at 2_000_000\n    expect(leftClip.timelineRange.durationUs).toBe(2_000_000);\n\n    const movedClip = resultClips.find((x) => x.id === 'right');\n    expect(movedClip).toBeTruthy();\n    expect(movedClip.timelineRange.startUs).toBe(2_000_000);\n  });\n\n  it('trims start of clip that overlaps on the right', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'mover',\n            trackId: 'v1',\n            name: 'Mover',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'existing',\n            trackId: 'v1',\n            name: 'Existing',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 3_000_000, durationUs: 3_000_000 },\n            sourceRange: { startUs: 0, durationUs: 3_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    // 'mover' (2s) placed at 4_000_000 â overlaps 'existing' on the right side\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'mover',\n      startUs: 4_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    const existingClip = resultClips.find((x) => x.id === 'existing');\n    expect(existingClip).toBeTruthy();\n    // Existing starts at 3_000_000, mover covers 4_000_000â6_000_000\n    // Existing should be trimmed to 3_000_000â4_000_000 (1s)\n    expect(existingClip.timelineRange.startUs).toBe(3_000_000);\n    expect(existingClip.timelineRange.durationUs).toBe(1_000_000);\n\n    const movedClip = resultClips.find((x) => x.id === 'mover');\n    expect(movedClip).toBeTruthy();\n    expect(movedClip.timelineRange.startUs).toBe(4_000_000);\n  });\n\n  it('splits a clip when placed fully inside it', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'long',\n            trackId: 'v1',\n            name: 'Long',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 10_000_000 },\n            sourceRange: { startUs: 0, durationUs: 10_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'short',\n            trackId: 'v1',\n            name: 'Short',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 20_000_000, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    // Place 'short' (2s) at 3_000_000 â fully inside 'long' (0â10s)\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'short',\n      startUs: 3_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    // 'long' should be split into two pieces around 3_000_000â5_000_000\n    const longPieces = resultClips.filter((x) => x.id !== 'short');\n    expect(longPieces.length).toBe(2);\n\n    const leftPiece = longPieces.find((x) => x.timelineRange.startUs === 0);\n    expect(leftPiece).toBeTruthy();\n    expect(leftPiece.timelineRange.durationUs).toBe(3_000_000);\n\n    const movedClip = resultClips.find((x) => x.id === 'short');\n    expect(movedClip).toBeTruthy();\n    expect(movedClip.timelineRange.startUs).toBe(3_000_000);\n  });\n\n  it('no gaps between clips after overlay placement', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'c1',\n            trackId: 'v1',\n            name: 'C1',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 4_000_000 },\n            sourceRange: { startUs: 0, durationUs: 4_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'c2',\n            trackId: 'v1',\n            name: 'C2',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 8_000_000, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    // Place c2 at 2_000_000 â overlaps c1 on the left side\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_place_item',\n      fromTrackId: 'v1',\n      toTrackId: 'v1',\n      itemId: 'c2',\n      startUs: 2_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track).sort(\n      (a: any, b: any) => a.timelineRange.startUs - b.timelineRange.startUs,\n    );\n\n    // Check no overlapping clips\n    for (let i = 1; i < resultClips.length; i++) {\n      const prev = resultClips[i - 1];\n      const curr = resultClips[i];\n      const prevEnd = prev.timelineRange.startUs + prev.timelineRange.durationUs;\n      expect(curr.timelineRange.startUs).toBeGreaterThanOrEqual(prevEnd);\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-overlay-trim.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":58,"messageId":"unexpectedAny","endLine":16,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack, TimelineTrackItem } from '~/timeline/types';\n\nfunction makeDoc(tracks: TimelineTrack[]): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks,\n  };\n}\n\nfunction clips(track: { items: TimelineTrackItem[] }) {\n  return track.items.filter((x) => x.kind === 'clip') as any[];\n}\n\ndescribe('timeline/commands overlay_trim_item', () => {\n  it('trims and removes clips fully covered by the trimmed range', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'mover',\n            trackId: 'v1',\n            name: 'Mover',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'victim',\n            trackId: 'v1',\n            name: 'Victim',\n            backgroundColor: '#fff',\n            timelineRange: { startUs: 2_500_000, durationUs: 200_000 },\n            sourceRange: { startUs: 0, durationUs: 200_000 },\n          },\n        ],\n      },\n    ]);\n\n    // Extend mover end to 3_000_000 to fully cover victim.\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_trim_item',\n      trackId: 'v1',\n      itemId: 'mover',\n      edge: 'end',\n      deltaUs: 1_000_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    expect(resultClips.find((x) => x.id === 'victim')).toBeUndefined();\n\n    const moved = resultClips.find((x) => x.id === 'mover');\n    expect(moved).toBeTruthy();\n    expect(moved.timelineRange.durationUs).toBe(3_000_000);\n  });\n\n  it('trims overlapping clip on the left side of trimmed range', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'left',\n            trackId: 'v1',\n            name: 'Left',\n            backgroundColor: '#000',\n            timelineRange: { startUs: 0, durationUs: 2_000_000 },\n            sourceRange: { startUs: 0, durationUs: 2_000_000 },\n          },\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'mover',\n            trackId: 'v1',\n            name: 'Mover',\n            backgroundColor: '#0f0',\n            timelineRange: { startUs: 3_000_000, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    // Trim mover start right to 3_500_000 (deltaUs = +500_000)\n    const { next } = applyTimelineCommand(doc, {\n      type: 'overlay_trim_item',\n      trackId: 'v1',\n      itemId: 'mover',\n      edge: 'start',\n      deltaUs: 500_000,\n    });\n\n    const track = next.tracks[0]!;\n    const resultClips = clips(track);\n\n    const left = resultClips.find((x) => x.id === 'left');\n    expect(left).toBeTruthy();\n    // Left should remain unchanged (no overlap after trimming start to the right)\n    expect(left.timelineRange.durationUs).toBe(2_000_000);\n\n    const mover = resultClips.find((x) => x.id === 'mover');\n    expect(mover).toBeTruthy();\n    expect(mover.timelineRange.startUs).toBe(3_500_000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-split.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":80,"messageId":"unexpectedAny","endLine":45,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1254,1257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1254,1257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":80,"messageId":"unexpectedAny","endLine":90,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2524,2527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2524,2527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":196,"column":82,"messageId":"unexpectedAny","endLine":196,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5557,5560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5557,5560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":82,"messageId":"unexpectedAny","endLine":202,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5788,5791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5788,5791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack, TimelineTrackItem } from '~/timeline/types';\n\nfunction makeDoc(tracks: TimelineTrack[]): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks,\n  };\n}\n\ndescribe('timeline/commands split_item', () => {\n  it('does not create overlap or gaps due to frame quantization', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'background',\n            id: 'img1',\n            trackId: 'v1',\n            name: 'Image',\n            backgroundColor: '#000000',\n            timelineRange: { startUs: 0, durationUs: 999_999 },\n            sourceRange: { startUs: 0, durationUs: 999_999 },\n          },\n        ],\n      },\n    ]);\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'split_item',\n      trackId: 'v1',\n      itemId: 'img1',\n      atUs: 333_333,\n    });\n\n    const items = next.tracks[0]?.items ?? [];\n    const clips = items.filter((x: TimelineTrackItem) => x.kind === 'clip') as any[];\n    expect(clips.length).toBe(2);\n\n    const ordered = [...clips].sort((a, b) => a.timelineRange.startUs - b.timelineRange.startUs);\n    const left = ordered[0];\n    const right = ordered[1];\n\n    expect(right.timelineRange.startUs).toBe(\n      left.timelineRange.startUs + left.timelineRange.durationUs,\n    );\n\n    const gaps = items.filter((x: TimelineTrackItem) => x.kind === 'gap');\n    expect(gaps.length).toBe(0);\n  });\n\n  it('splits a clip into two at playhead time', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'media',\n            id: 'c1',\n            trackId: 'v1',\n            name: 'C1',\n            source: { path: 'a.mp4' },\n            sourceDurationUs: 10_000_000,\n            timelineRange: { startUs: 0, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'split_item',\n      trackId: 'v1',\n      itemId: 'c1',\n      atUs: 500_000,\n    });\n\n    const items = next.tracks[0]?.items ?? [];\n    const clips = items.filter((x: TimelineTrackItem) => x.kind === 'clip') as any[];\n    expect(clips.length).toBe(2);\n\n    const left = clips.find((x) => x.id === 'c1');\n    const right = clips.find((x) => x.id !== 'c1');\n\n    expect(left.timelineRange.startUs).toBe(0);\n    expect(left.timelineRange.durationUs).toBeGreaterThan(0);\n\n    expect(right.timelineRange.startUs).toBe(left.timelineRange.durationUs);\n    expect(right.timelineRange.durationUs).toBeGreaterThan(0);\n\n    expect(left.sourceRange.startUs).toBe(0);\n    expect(left.sourceRange.durationUs + right.sourceRange.durationUs).toBe(1_000_000);\n    expect(right.sourceRange.startUs).toBe(left.sourceRange.durationUs);\n  });\n\n  it('does nothing when splitting at the clip boundary', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'media',\n            id: 'c1',\n            trackId: 'v1',\n            name: 'C1',\n            source: { path: 'a.mp4' },\n            sourceDurationUs: 10_000_000,\n            timelineRange: { startUs: 0, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    const atStart = applyTimelineCommand(doc, {\n      type: 'split_item',\n      trackId: 'v1',\n      itemId: 'c1',\n      atUs: 0,\n    }).next;\n\n    const atEnd = applyTimelineCommand(doc, {\n      type: 'split_item',\n      trackId: 'v1',\n      itemId: 'c1',\n      atUs: 1_000_000,\n    }).next;\n\n    expect(atStart.tracks[0]?.items.filter((x) => x.kind === 'clip').length).toBe(1);\n    expect(atEnd.tracks[0]?.items.filter((x) => x.kind === 'clip').length).toBe(1);\n  });\n\n  it('splits locked linked audio when splitting the linked video clip', () => {\n    const doc = makeDoc([\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'V1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'media',\n            id: 'vclip',\n            trackId: 'v1',\n            name: 'Video',\n            source: { path: 'a.mp4' },\n            sourceDurationUs: 10_000_000,\n            timelineRange: { startUs: 0, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n      {\n        id: 'a1',\n        kind: 'audio',\n        name: 'A1',\n        items: [\n          {\n            kind: 'clip',\n            clipType: 'media',\n            id: 'aclip',\n            trackId: 'a1',\n            name: 'Audio',\n            source: { path: 'a.mp4' },\n            sourceDurationUs: 10_000_000,\n            linkedVideoClipId: 'vclip',\n            lockToLinkedVideo: true,\n            timelineRange: { startUs: 0, durationUs: 1_000_000 },\n            sourceRange: { startUs: 0, durationUs: 1_000_000 },\n          },\n        ],\n      },\n    ]);\n\n    const { next } = applyTimelineCommand(doc, {\n      type: 'split_item',\n      trackId: 'v1',\n      itemId: 'vclip',\n      atUs: 500_000,\n    });\n\n    const videoClips = next.tracks[0]?.items.filter((x) => x.kind === 'clip') as any[];\n    expect(videoClips.length).toBe(2);\n\n    const rightVideo = videoClips.find((x) => x.id !== 'vclip');\n    expect(rightVideo).toBeTruthy();\n\n    const audioClips = next.tracks[1]?.items.filter((x) => x.kind === 'clip') as any[];\n    expect(audioClips.length).toBe(2);\n\n    const leftAudio = audioClips.find((x) => x.linkedVideoClipId === 'vclip');\n    const rightAudio = audioClips.find((x) => x.linkedVideoClipId === rightVideo.id);\n\n    expect(leftAudio).toBeTruthy();\n    expect(rightAudio).toBeTruthy();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-transition.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":64,"messageId":"unexpectedAny","endLine":38,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1121,1124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1121,1124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":64,"messageId":"unexpectedAny","endLine":53,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1657,1660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1657,1660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":64,"messageId":"unexpectedAny","endLine":71,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2253,2256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2253,2256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":62,"messageId":"unexpectedAny","endLine":91,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2913,2916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2913,2916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":88,"messageId":"unexpectedAny","endLine":127,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4068,4071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4068,4071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":62,"messageId":"unexpectedAny","endLine":136,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4342,4345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4342,4345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":88,"messageId":"unexpectedAny","endLine":168,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5737,5740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5737,5740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":62,"messageId":"unexpectedAny","endLine":177,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6011,6014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6011,6014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":81,"messageId":"unexpectedAny","endLine":192,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6717,6720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6717,6720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":201,"column":68,"messageId":"unexpectedAny","endLine":201,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6996,6999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6996,6999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":88,"messageId":"unexpectedAny","endLine":228,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8146,8149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8146,8149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":62,"messageId":"unexpectedAny","endLine":238,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8493,8496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8493,8496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack } from '~/timeline/types';\n\nfunction makeDoc(track: TimelineTrack): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks: [track],\n  };\n}\n\nconst baseClip = {\n  kind: 'clip' as const,\n  id: 'c1',\n  trackId: 'v1',\n  name: 'C1',\n  clipType: 'media' as const,\n  source: { path: 'a.mp4' },\n  sourceDurationUs: 10_000_000,\n  timelineRange: { startUs: 0, durationUs: 5_000_000 },\n  sourceRange: { startUs: 0, durationUs: 5_000_000 },\n};\n\ndescribe('timeline/commands update_clip_transition', () => {\n  it('sets transitionOut on a clip', () => {\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [baseClip] });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionOut: { type: 'dissolve', durationUs: 500_000 },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.transitionOut).toEqual({ type: 'dissolve', durationUs: 500_000 });\n    expect(clip.transitionIn).toBeUndefined();\n  });\n\n  it('sets transitionIn on a clip', () => {\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [baseClip] });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionIn: { type: 'dissolve', durationUs: 300_000 },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.transitionIn).toEqual({ type: 'dissolve', durationUs: 300_000 });\n  });\n\n  it('removes transitionOut when set to null', () => {\n    const clipWithTransition = {\n      ...baseClip,\n      transitionOut: { type: 'dissolve', durationUs: 500_000 },\n    };\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [clipWithTransition] });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionOut: null,\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.transitionOut).toBeUndefined();\n  });\n\n  it('does not modify unrelated clips', () => {\n    const otherClip = {\n      ...baseClip,\n      id: 'c2',\n      timelineRange: { startUs: 5_000_000, durationUs: 5_000_000 },\n      sourceRange: { startUs: 0, durationUs: 5_000_000 },\n    };\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [baseClip, otherClip] });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionOut: { type: 'dissolve', durationUs: 500_000 },\n    }).next;\n\n    const clips = (next.tracks[0] as TimelineTrack).items as any[];\n    const c2 = clips.find((c) => c.id === 'c2');\n    expect(c2?.transitionOut).toBeUndefined();\n  });\n\n  it('returns unchanged doc for missing item', () => {\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [baseClip] });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'nonexistent',\n      transitionOut: { type: 'dissolve', durationUs: 500_000 },\n    }).next;\n\n    expect(next).toBe(doc);\n  });\n\n  it('auto-overlaps adjacent clips when setting transitionOut on a cut', () => {\n    const left = {\n      ...baseClip,\n      id: 'c1',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 0, durationUs: 5_000_000 },\n      timelineRange: { startUs: 0, durationUs: 5_000_000 },\n    };\n    const right = {\n      ...baseClip,\n      id: 'c2',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 2_000_000, durationUs: 5_000_000 },\n      timelineRange: { startUs: 5_000_000, durationUs: 5_000_000 },\n    };\n\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [left, right] as any });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionOut: { type: 'dissolve', durationUs: 2_000_000 },\n    }).next;\n\n    const items = (next.tracks[0] as TimelineTrack).items as any[];\n    const nextLeft = items.find((it) => it.id === 'c1');\n    const nextRight = items.find((it) => it.id === 'c2');\n\n    // Overlap is limited by left clip tail handle. We extend the left clip into the right clip by 2s.\n    expect(nextLeft.timelineRange.durationUs).toBe(7_000_000);\n    expect(nextRight.timelineRange.startUs).toBe(5_000_000);\n    expect(nextRight.timelineRange.durationUs).toBe(5_000_000);\n    expect(nextLeft.transitionOut).toEqual({ type: 'dissolve', durationUs: 2_000_000 });\n    expect(nextRight.transitionIn).toEqual({ type: 'dissolve', durationUs: 2_000_000 });\n  });\n\n  it('does not collapse an existing overlap when updating transition duration', () => {\n    const left = {\n      ...baseClip,\n      id: 'c1',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 0, durationUs: 7_000_000 },\n      timelineRange: { startUs: 0, durationUs: 7_000_000 },\n      transitionOut: { type: 'dissolve', durationUs: 2_000_000 },\n    };\n    const right = {\n      ...baseClip,\n      id: 'c2',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 2_000_000, durationUs: 5_000_000 },\n      timelineRange: { startUs: 5_000_000, durationUs: 5_000_000 },\n      transitionIn: { type: 'dissolve', durationUs: 2_000_000 },\n    };\n\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [left, right] as any });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionOut: { type: 'dissolve', durationUs: 2_100_000 },\n    }).next;\n\n    const items = (next.tracks[0] as TimelineTrack).items as any[];\n    const nextLeft = items.find((it) => it.id === 'c1');\n    const nextRight = items.find((it) => it.id === 'c2');\n\n    expect(nextLeft.timelineRange.durationUs).toBeGreaterThan(0);\n    expect(nextLeft.transitionOut.durationUs).toBeGreaterThan(0);\n    expect(nextRight.transitionIn.durationUs).toBeGreaterThan(0);\n    expect(nextLeft.transitionOut.durationUs).toBe(nextRight.transitionIn.durationUs);\n  });\n\n  it('reduces opposite transition when adding a new transition to fit exactly within clip', () => {\n    const clip = {\n      ...baseClip,\n      transitionOut: { type: 'dissolve', durationUs: 3_000_000 },\n    };\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [clip] as any });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c1',\n      transitionIn: { type: 'dissolve', durationUs: 4_000_000 },\n    }).next;\n\n    const nextClip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(nextClip.transitionIn.durationUs).toBe(4_000_000);\n    expect(nextClip.transitionOut.durationUs).toBe(1_000_000);\n  });\n\n  it('grows an existing crossfade overlap when resize-dragging transition (simulates mousemove)', () => {\n    // State after initial 2s crossfade: left extended by 2s, source tail partially consumed.\n    // left: sourceDuration=10s, sourceRange={0..7s}, timelineRange={0..7s}, overlap=2s with right at 5s\n    const left = {\n      ...baseClip,\n      id: 'c1',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 0, durationUs: 7_000_000 },\n      timelineRange: { startUs: 0, durationUs: 7_000_000 },\n      transitionOut: { type: 'dissolve', durationUs: 2_000_000 },\n    };\n    const right = {\n      ...baseClip,\n      id: 'c2',\n      trackId: 'v1',\n      sourceDurationUs: 10_000_000,\n      sourceRange: { startUs: 2_000_000, durationUs: 5_000_000 },\n      timelineRange: { startUs: 5_000_000, durationUs: 5_000_000 },\n      transitionIn: { type: 'dissolve', durationUs: 2_000_000 },\n    };\n\n    const doc = makeDoc({ id: 'v1', kind: 'video', name: 'V1', items: [left, right] as any });\n\n    // Simulate dragging transitionIn of right clip to 3s (growing by 1s)\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_transition',\n      trackId: 'v1',\n      itemId: 'c2',\n      transitionIn: { type: 'dissolve', durationUs: 3_000_000 },\n    }).next;\n\n    const items = (next.tracks[0] as TimelineTrack).items as any[];\n    const nextLeft = items.find((it) => it.id === 'c1');\n    const nextRight = items.find((it) => it.id === 'c2');\n\n    // Overlap should grow from 2s to 3s\n    const overlapUs =\n      nextLeft.timelineRange.startUs +\n      nextLeft.timelineRange.durationUs -\n      nextRight.timelineRange.startUs;\n    expect(overlapUs).toBe(3_000_000);\n    expect(nextLeft.transitionOut.durationUs).toBe(3_000_000);\n    expect(nextRight.transitionIn.durationUs).toBe(3_000_000);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/commands-update-clip-properties.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":64,"messageId":"unexpectedAny","endLine":42,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1143,1146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1143,1146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":64,"messageId":"unexpectedAny","endLine":80,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2145,2148],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2145,2148],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":66,"messageId":"unexpectedAny","endLine":129,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3698,3701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3698,3701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":94,"messageId":"unexpectedAny","endLine":129,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3726,3729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3726,3729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":69,"messageId":"unexpectedAny","endLine":130,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3799,3802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3799,3802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":96,"messageId":"unexpectedAny","endLine":130,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3826,3829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3826,3829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":12,"messageId":"unexpectedAny","endLine":140,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4146,4149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4146,4149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":10,"messageId":"unexpectedAny","endLine":141,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4179,4182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4179,4182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":64,"messageId":"unexpectedAny","endLine":183,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5192,5195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5192,5195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":64,"messageId":"unexpectedAny","endLine":214,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6031,6034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6031,6034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":38,"messageId":"unexpectedAny","endLine":259,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7353,7356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7353,7356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":65,"messageId":"unexpectedAny","endLine":259,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7380,7383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7380,7383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":38,"messageId":"unexpectedAny","endLine":260,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7422,7425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7422,7425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":260,"column":65,"messageId":"unexpectedAny","endLine":260,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7449,7452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7449,7452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":282,"column":14,"messageId":"unexpectedAny","endLine":282,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8042,8045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8042,8045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":299,"column":14,"messageId":"unexpectedAny","endLine":299,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8456,8459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8456,8459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":64,"messageId":"unexpectedAny","endLine":303,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8547,8550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8547,8550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":14,"messageId":"unexpectedAny","endLine":329,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9239,9242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9239,9242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":344,"column":14,"messageId":"unexpectedAny","endLine":344,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9626,9629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9626,9629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":348,"column":64,"messageId":"unexpectedAny","endLine":348,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9717,9720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9717,9720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { applyTimelineCommand } from '~/timeline/commands';\nimport type { TimelineDocument, TimelineTrack } from '~/timeline/types';\n\nfunction makeDoc(track: TimelineTrack): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks: [track],\n  };\n}\n\ndescribe('timeline/commands update_clip_properties', () => {\n  it('updates opacity for a clip', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: { opacity: 0.25 },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.opacity).toBe(0.25);\n  });\n\n  it('updates transform for a clip and normalizes values', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'media',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: {\n        transform: {\n          scale: { x: 2, y: 3, linked: true },\n          rotationDeg: 45,\n          position: { x: 10, y: -20 },\n          anchor: { preset: 'custom', x: 2, y: -1 },\n        },\n      },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.transform).toBeDefined();\n    expect(clip.transform.scale.x).toBe(2);\n    expect(clip.transform.scale.y).toBe(3);\n    expect(clip.transform.scale.linked).toBe(true);\n    expect(clip.transform.rotationDeg).toBe(45);\n    expect(clip.transform.position).toEqual({ x: 10, y: -20 });\n    expect(clip.transform.anchor.preset).toBe('custom');\n    expect(clip.transform.anchor.x).toBe(2);\n    expect(clip.transform.anchor.y).toBe(-1);\n  });\n\n  it('updates backgroundColor for a background clip only', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'background',\n          id: 'bg1',\n          trackId: 'v1',\n          name: 'BG',\n          backgroundColor: '#000000',\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          clipType: 'media',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 1_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'bg1',\n      properties: { backgroundColor: '#112233' },\n    }).next;\n\n    const bg = (next.tracks[0] as TimelineTrack).items.find((it: any) => it.id === 'bg1') as any;\n    const media = (next.tracks[0] as TimelineTrack).items.find((it: any) => it.id === 'c1') as any;\n    expect(bg.backgroundColor).toBe('#112233');\n\n    const next2 = applyTimelineCommand(next, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: { backgroundColor: '#ff00ff' },\n    }).next;\n    const media2 = (next2.tracks[0] as TimelineTrack).items.find(\n      (it: any) => it.id === 'c1',\n    ) as any;\n    expect(media2.backgroundColor).toBeUndefined();\n    expect(media.backgroundColor).toBeUndefined();\n  });\n\n  it('updates effects list for a clip', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const effects = [\n      {\n        id: 'e1',\n        type: 'color-adjustment',\n        enabled: true,\n        brightness: 1,\n        contrast: 1,\n        saturation: 1,\n      },\n    ];\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: { effects },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.effects).toEqual(effects);\n  });\n\n  it('updates speed and recomputes timeline duration based on sourceRange duration', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'media',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: { speed: 2 },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.speed).toBe(2);\n    expect(clip.timelineRange.durationUs).toBeGreaterThan(0);\n    expect(clip.timelineRange.durationUs).toBeLessThan(1_000_000);\n  });\n\n  it('ripples subsequent clips when slowing down would cause overlap', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'media',\n          id: 'c1',\n          trackId: 'v1',\n          name: 'C1',\n          source: { path: 'a.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n        {\n          kind: 'clip',\n          clipType: 'media',\n          id: 'c2',\n          trackId: 'v1',\n          name: 'C2',\n          source: { path: 'b.mp4' },\n          sourceDurationUs: 10_000_000,\n          timelineRange: { startUs: 1_000_000, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        },\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 'c1',\n      properties: { speed: 0.5 },\n    }).next;\n\n    const track = next.tracks[0] as TimelineTrack;\n    const c1 = track.items.find((it: any) => it.id === 'c1') as any;\n    const c2 = track.items.find((it: any) => it.id === 'c2') as any;\n\n    expect(c1.speed).toBe(0.5);\n    expect(c1.timelineRange.durationUs).toBe(2_000_000);\n    expect(c2.timelineRange.startUs).toBe(2_000_000);\n  });\n\n  it('sanitizes style for a text clip', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'text',\n          id: 't1',\n          trackId: 'v1',\n          name: 'T1',\n          text: 'Hello',\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        } as any,\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 't1',\n      properties: {\n        style: {\n          fontSize: 12.4,\n          verticalAlign: 'bottom',\n          lineHeight: 2,\n          letterSpacing: 5,\n          backgroundColor: '  #112233  ',\n          padding: { x: 10, y: 20 },\n          unknown: 'x',\n        } as any,\n      },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.style).toEqual({\n      fontSize: 12,\n      verticalAlign: 'bottom',\n      lineHeight: 2,\n      letterSpacing: 5,\n      backgroundColor: '#112233',\n      padding: { top: 20, right: 10, bottom: 20, left: 10 },\n    });\n  });\n\n  it('drops invalid style fields for a text clip', () => {\n    const doc = makeDoc({\n      id: 'v1',\n      kind: 'video',\n      name: 'V1',\n      items: [\n        {\n          kind: 'clip',\n          clipType: 'text',\n          id: 't1',\n          trackId: 'v1',\n          name: 'T1',\n          text: 'Hello',\n          timelineRange: { startUs: 0, durationUs: 1_000_000 },\n          sourceRange: { startUs: 0, durationUs: 1_000_000 },\n        } as any,\n      ],\n    });\n\n    const next = applyTimelineCommand(doc, {\n      type: 'update_clip_properties',\n      trackId: 'v1',\n      itemId: 't1',\n      properties: {\n        style: {\n          verticalAlign: 'nope',\n          lineHeight: Infinity,\n          letterSpacing: 'a',\n          backgroundColor: '   ',\n          padding: { top: 0, left: 0, right: 0, bottom: 0 },\n        } as any,\n      },\n    }).next;\n\n    const clip = (next.tracks[0] as TimelineTrack).items[0] as any;\n    expect(clip.style).toBeUndefined();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/timeline/otio-transition.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":48,"messageId":"unexpectedAny","endLine":60,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1778,1781],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1778,1781],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":32,"messageId":"unexpectedAny","endLine":69,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2186,2189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2186,2189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":48,"messageId":"unexpectedAny","endLine":102,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3193,3196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3193,3196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport {\n  serializeTimelineToOtio,\n  parseTimelineFromOtio,\n} from '../../../src/timeline/otioSerializer';\nimport type { TimelineDocument } from '../../../src/timeline/types';\n\nfunction makeDoc(): TimelineDocument {\n  return {\n    OTIO_SCHEMA: 'Timeline.1',\n    id: 'doc1',\n    name: 'Test',\n    timebase: { fps: 30 },\n    tracks: [\n      {\n        id: 'v1',\n        kind: 'video',\n        name: 'Video 1',\n        items: [\n          {\n            kind: 'clip',\n            id: 'c1',\n            trackId: 'v1',\n            name: 'Clip1',\n            clipType: 'media',\n            disabled: true,\n            locked: true,\n            source: { path: 'file.mp4' },\n            sourceDurationUs: 10_000_000,\n            timelineRange: { startUs: 0, durationUs: 5_000_000 },\n            sourceRange: { startUs: 0, durationUs: 5_000_000 },\n            transitionIn: { type: 'dissolve', durationUs: 300_000 },\n            transitionOut: { type: 'dissolve', durationUs: 500_000 },\n            audioGain: 1.25,\n            audioFadeInUs: 200_000,\n            audioFadeOutUs: 400_000,\n          },\n        ],\n      },\n    ],\n    metadata: {\n      gran: {\n        docId: 'doc1',\n        timebase: { fps: 30 },\n        markers: [\n          { id: 'm1', timeUs: 1_000_000, text: 'Hello world' },\n          { id: 'm2', timeUs: 500_000, text: 'Second' },\n        ],\n      },\n    },\n  };\n}\n\ndescribe('timeline/otioSerializer: transitions', () => {\n  it('serializes and deserializes transitionIn and transitionOut', () => {\n    const doc = makeDoc();\n    const serialized = serializeTimelineToOtio(doc);\n    const parsed = parseTimelineFromOtio(serialized, { id: 'doc1', name: 'Test', fps: 30 });\n\n    const clip = parsed.tracks[0]?.items[0] as any;\n    expect(clip.disabled).toBe(true);\n    expect(clip.locked).toBe(true);\n    expect(clip.transitionIn).toEqual({ type: 'dissolve', durationUs: 300_000 });\n    expect(clip.transitionOut).toEqual({ type: 'dissolve', durationUs: 500_000 });\n    expect(clip.audioGain).toBe(1.25);\n    expect(clip.audioFadeInUs).toBe(200_000);\n    expect(clip.audioFadeOutUs).toBe(400_000);\n\n    expect((parsed.metadata as any)?.gran?.markers).toEqual([\n      { id: 'm2', timeUs: 500_000, text: 'Second' },\n      { id: 'm1', timeUs: 1_000_000, text: 'Hello world' },\n    ]);\n  });\n\n  it('omits transitions when not set', () => {\n    const doc: TimelineDocument = {\n      ...makeDoc(),\n      tracks: [\n        {\n          id: 'v1',\n          kind: 'video',\n          name: 'Video 1',\n          items: [\n            {\n              kind: 'clip',\n              id: 'c1',\n              trackId: 'v1',\n              name: 'Clip1',\n              clipType: 'media',\n              source: { path: 'file.mp4' },\n              sourceDurationUs: 10_000_000,\n              timelineRange: { startUs: 0, durationUs: 5_000_000 },\n              sourceRange: { startUs: 0, durationUs: 5_000_000 },\n            },\n          ],\n        },\n      ],\n    };\n    const serialized = serializeTimelineToOtio(doc);\n    const parsed = parseTimelineFromOtio(serialized, { id: 'doc1', name: 'Test', fps: 30 });\n\n    const clip = parsed.tracks[0]?.items[0] as any;\n    expect(clip.transitionIn).toBeUndefined();\n    expect(clip.transitionOut).toBeUndefined();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/hotkey-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/stop-frames.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":25,"messageId":"unexpectedAny","endLine":37,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1109,1112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1109,1112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":20,"messageId":"unexpectedAny","endLine":45,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1339,1342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1339,1342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":27,"messageId":"unexpectedAny","endLine":47,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1409,1412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1409,1412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":23,"messageId":"unexpectedAny","endLine":54,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1589,1592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1589,1592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":25,"messageId":"unexpectedAny","endLine":83,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2434,2437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2434,2437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":37,"messageId":"unexpectedAny","endLine":91,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2649,2652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2649,2652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from 'vitest';\n\nimport {\n  buildStopFrameBaseName,\n  formatStopFrameTimecode,\n  renderExportFrameBlob,\n} from '../../../src/utils/stop-frames';\n\ndescribe('stop-frames', () => {\n  it('formats timecode as HH-MM-SS-FF', () => {\n    expect(formatStopFrameTimecode({ timeUs: 0, fps: 30 })).toBe('00-00-00-00');\n    expect(formatStopFrameTimecode({ timeUs: 1_000_000, fps: 30 })).toBe('00-00-01-00');\n    expect(formatStopFrameTimecode({ timeUs: 1_500_000, fps: 30 })).toBe('00-00-01-15');\n  });\n\n  it('builds base name with sanitized timeline name and timecode', () => {\n    const base = buildStopFrameBaseName({\n      timelineName: 'My Timeline.otio',\n      timeUs: 1_000_000,\n      fps: 30,\n    });\n\n    expect(base).toBe('My_Timeline_00-00-01-00');\n  });\n\n  it('defaults to timeline base name if empty', () => {\n    const base = buildStopFrameBaseName({\n      timelineName: '',\n      timeUs: 0,\n      fps: 30,\n    });\n\n    expect(base).toBe('timeline_00-00-00-00');\n  });\n\n  it('renders export frame blob with given resolution and quality', async () => {\n    const sourceCanvas: any = { width: 100, height: 50 };\n\n    let capturedWidth = 0;\n    let capturedHeight = 0;\n    let capturedMime: string | undefined;\n    let capturedQuality: number | undefined;\n    let drawImageCalled = false;\n\n    const mockCtx: any = {\n      imageSmoothingEnabled: false,\n      drawImage: (canvas: any, x: number, y: number, w: number, h: number) => {\n        drawImageCalled = true;\n        capturedWidth = w;\n        capturedHeight = h;\n      },\n    };\n\n    const mockCanvas: any = {\n      width: 0,\n      height: 0,\n      getContext: () => mockCtx,\n      toBlob: (cb: (blob: Blob | null) => void, mime?: string, quality?: number) => {\n        capturedMime = mime;\n        capturedQuality = quality;\n        cb(new Blob(['x']));\n      },\n    };\n\n    const blob = await renderExportFrameBlob({\n      sourceCanvas,\n      exportWidth: 1920,\n      exportHeight: 1080,\n      quality: 0.5,\n      mimeType: 'image/webp',\n      createCanvas: () => mockCanvas,\n    });\n\n    expect(blob).toBeInstanceOf(Blob);\n    expect(drawImageCalled).toBe(true);\n    expect(capturedWidth).toBe(1920);\n    expect(capturedHeight).toBe(1080);\n    expect(capturedMime).toBe('image/webp');\n    expect(capturedQuality).toBeCloseTo(0.5);\n  });\n\n  it('clamps invalid resolution and throws for non-positive sizes', async () => {\n    const sourceCanvas: any = { width: 100, height: 50 };\n\n    await expect(\n      renderExportFrameBlob({\n        sourceCanvas,\n        exportWidth: 0,\n        exportHeight: 1080,\n        quality: 0.8,\n        createCanvas: () => ({}) as any,\n      }),\n    ).rejects.toThrow('Invalid export resolution');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/svg-dimensions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/timeline-media-usage.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":13,"messageId":"unexpectedAny","endLine":131,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3771,3774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3771,3774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":13,"messageId":"unexpectedAny","endLine":132,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3788,3791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3788,3791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":13,"messageId":"unexpectedAny","endLine":133,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3805,3808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3805,3808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from 'vitest';\n\nimport {\n  computeMediaUsageByTimelineDocs,\n  getTimelinesUsingMediaPath,\n} from '../../../src/utils/timeline-media-usage';\n\ndescribe('timeline-media-usage', () => {\n  it('collects unique media paths per timeline and returns sorted timeline refs', () => {\n    const t1 = {\n      timelinePath: 'timelines/A.otio',\n      timelineName: 'A',\n      timelineDoc: {\n        OTIO_SCHEMA: 'Timeline.1',\n        id: 't1',\n        name: 'A',\n        timebase: { fps: 25 },\n        tracks: [\n          {\n            id: 'v1',\n            kind: 'video',\n            name: 'V1',\n            items: [\n              {\n                kind: 'clip',\n                clipType: 'media',\n                id: 'c1',\n                trackId: 'v1',\n                name: 'clip1',\n                timelineRange: { startUs: 0, durationUs: 1_000_000 },\n                sourceRange: { startUs: 0, durationUs: 1_000_000 },\n                source: { path: 'video/x.mp4' },\n                sourceDurationUs: 1_000_000,\n              },\n              {\n                kind: 'clip',\n                clipType: 'media',\n                id: 'c2',\n                trackId: 'v1',\n                name: 'clip2',\n                timelineRange: { startUs: 1_000_000, durationUs: 1_000_000 },\n                sourceRange: { startUs: 0, durationUs: 1_000_000 },\n                source: { path: 'video/x.mp4' },\n                sourceDurationUs: 1_000_000,\n              },\n              {\n                kind: 'clip',\n                clipType: 'text',\n                id: 'txt1',\n                trackId: 'v1',\n                name: 'text',\n                timelineRange: { startUs: 0, durationUs: 1_000_000 },\n                sourceRange: { startUs: 0, durationUs: 1_000_000 },\n                text: 'hello',\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const t2 = {\n      timelinePath: 'timelines/B.otio',\n      timelineName: 'B',\n      timelineDoc: {\n        OTIO_SCHEMA: 'Timeline.1',\n        id: 't2',\n        name: 'B',\n        timebase: { fps: 25 },\n        tracks: [\n          {\n            id: 'a1',\n            kind: 'audio',\n            name: 'A1',\n            items: [\n              {\n                kind: 'clip',\n                clipType: 'media',\n                id: 'a1c1',\n                trackId: 'a1',\n                name: 'clip1',\n                timelineRange: { startUs: 0, durationUs: 1_000_000 },\n                sourceRange: { startUs: 0, durationUs: 1_000_000 },\n                source: { path: 'audio/y.mp3' },\n                sourceDurationUs: 1_000_000,\n              },\n              {\n                kind: 'gap',\n                id: 'g1',\n                trackId: 'a1',\n                timelineRange: { startUs: 0, durationUs: 1_000_000 },\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const t3 = {\n      timelinePath: 'timelines/C.otio',\n      timelineName: 'C',\n      timelineDoc: {\n        OTIO_SCHEMA: 'Timeline.1',\n        id: 't3',\n        name: 'C',\n        timebase: { fps: 25 },\n        tracks: [\n          {\n            id: 'v1',\n            kind: 'video',\n            name: 'V1',\n            items: [\n              {\n                kind: 'clip',\n                clipType: 'media',\n                id: 'c1',\n                trackId: 'v1',\n                name: 'clip1',\n                timelineRange: { startUs: 0, durationUs: 1_000_000 },\n                sourceRange: { startUs: 0, durationUs: 1_000_000 },\n                source: { path: 'video/x.mp4' },\n                sourceDurationUs: 1_000_000,\n              },\n            ],\n          },\n        ],\n      },\n    };\n\n    const { mediaPathToTimelines } = computeMediaUsageByTimelineDocs([\n      t2 as any,\n      t1 as any,\n      t3 as any,\n    ]);\n\n    expect(Object.keys(mediaPathToTimelines).sort()).toEqual(['audio/y.mp3', 'video/x.mp4']);\n\n    expect(mediaPathToTimelines['audio/y.mp3']).toEqual([\n      { timelinePath: 'timelines/B.otio', timelineName: 'B' },\n    ]);\n\n    expect(mediaPathToTimelines['video/x.mp4']).toEqual([\n      { timelinePath: 'timelines/A.otio', timelineName: 'A' },\n      { timelinePath: 'timelines/C.otio', timelineName: 'C' },\n    ]);\n\n    expect(getTimelinesUsingMediaPath(mediaPathToTimelines, 'video/x.mp4')).toHaveLength(2);\n    expect(getTimelinesUsingMediaPath(mediaPathToTimelines, 'missing.mp4')).toEqual([]);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/video-editor/AudioEngine.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":70,"messageId":"unexpectedAny","endLine":29,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[653,656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[653,656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":78,"messageId":"unexpectedAny","endLine":37,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[956,959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[956,959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":59,"messageId":"unexpectedAny","endLine":44,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1142,1145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1142,1145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-extraneous-class","severity":1,"message":"Unexpected class with only a constructor.","line":165,"column":7,"messageId":"onlyConstructor","endLine":170,"endColumn":8},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":36,"messageId":"unexpectedAny","endLine":168,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4112,4115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4112,4115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-extraneous-class","severity":1,"message":"Unexpected class with only a constructor.","line":175,"column":7,"messageId":"onlyConstructor","endLine":180,"endColumn":8},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":42,"messageId":"unexpectedAny","endLine":178,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4321,4324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4321,4324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\n\nimport { AudioEngine } from '../../../../src/utils/video-editor/AudioEngine';\n\ninterface WorkerMessageEvent<T> {\n  data: T;\n}\n\ninterface DecodeRequest {\n  type: 'decode';\n  id: number;\n  sourceKey: string;\n  arrayBuffer: ArrayBuffer;\n}\n\ninterface DecodeResponse {\n  type: 'decode-result';\n  id: number;\n  ok: boolean;\n  error?: { name?: string; message: string; stack?: string };\n  result?: {\n    sampleRate: number;\n    numberOfChannels: number;\n    channelBuffers: ArrayBuffer[];\n  };\n}\n\nclass WorkerMock {\n  private listeners: Record<string, Array<(event: WorkerMessageEvent<any>) => void>> = {};\n  public postMessage = vi.fn((payload: DecodeRequest) => {\n    const response = createWorkerResponse(payload.id);\n    queueMicrotask(() => {\n      this.emit('message', { data: response });\n    });\n  });\n\n  public addEventListener(event: string, handler: (event: WorkerMessageEvent<any>) => void) {\n    this.listeners[event] ??= [];\n    this.listeners[event].push(handler);\n  }\n\n  public terminate = vi.fn();\n\n  private emit(event: string, payload: WorkerMessageEvent<any>) {\n    for (const handler of this.listeners[event] ?? []) {\n      handler(payload);\n    }\n  }\n}\n\nclass GainNodeMock {\n  gain = { value: 1 };\n  connect = vi.fn();\n}\n\nclass AudioBufferMock {\n  public duration: number;\n  public numberOfChannels: number;\n  public length: number;\n  public sampleRate: number;\n  public copyToChannel = vi.fn();\n\n  constructor(numberOfChannels: number, length: number, sampleRate: number) {\n    this.numberOfChannels = numberOfChannels;\n    this.length = length;\n    this.sampleRate = sampleRate;\n    this.duration = length / sampleRate;\n  }\n}\n\nclass AudioBufferSourceNodeMock {\n  buffer: AudioBufferMock | null = null;\n  connect = vi.fn();\n  start = vi.fn();\n  stop = vi.fn();\n  disconnect = vi.fn();\n  onended: (() => void) | null = null;\n}\n\nclass AudioContextMock {\n  public currentTime = 0;\n  public state: 'running' | 'suspended' = 'running';\n  public resume = vi.fn(async () => {\n    this.state = 'running';\n  });\n  public close = vi.fn(async () => undefined);\n  public destination = {};\n  public createdSources: AudioBufferSourceNodeMock[] = [];\n  public createdGains: GainNodeMock[] = [];\n  public createdBuffers: AudioBufferMock[] = [];\n\n  createGain() {\n    const gain = new GainNodeMock();\n    this.createdGains.push(gain);\n    return gain;\n  }\n\n  createBuffer(numberOfChannels: number, length: number, sampleRate: number) {\n    const buffer = new AudioBufferMock(numberOfChannels, length, sampleRate);\n    this.createdBuffers.push(buffer);\n    return buffer;\n  }\n\n  createBufferSource() {\n    const source = new AudioBufferSourceNodeMock();\n    this.createdSources.push(source);\n    return source;\n  }\n}\n\nlet workerInstance: WorkerMock | null = null;\nlet audioContextInstance: AudioContextMock | null = null;\nlet workerOk = true;\n\nfunction createWorkerResponse(id: number): DecodeResponse {\n  if (!workerOk) {\n    return {\n      type: 'decode-result',\n      id,\n      ok: false,\n      error: { message: 'Decode failed' },\n    };\n  }\n  return {\n    type: 'decode-result',\n    id,\n    ok: true,\n    result: {\n      sampleRate: 48_000,\n      numberOfChannels: 1,\n      channelBuffers: [new Float32Array([0, 0, 0, 0]).buffer],\n    },\n  };\n}\n\nfunction createFileHandle() {\n  return {\n    getFile: vi.fn(async () => ({\n      arrayBuffer: vi.fn(async () => new ArrayBuffer(16)),\n    })),\n  } as unknown as FileSystemFileHandle;\n}\n\nfunction createClip(overrides: Partial<Parameters<AudioEngine['loadClips']>[0][number]> = {}) {\n  return {\n    id: 'clip-1',\n    sourcePath: 'audio.mp3',\n    fileHandle: createFileHandle(),\n    startUs: 0,\n    durationUs: 1_000_000,\n    sourceStartUs: 0,\n    sourceDurationUs: 1_000_000,\n    ...overrides,\n  };\n}\n\ndescribe('AudioEngine', () => {\n  beforeEach(() => {\n    workerOk = true;\n    workerInstance = null;\n    audioContextInstance = null;\n\n    vi.stubGlobal(\n      'Worker',\n      class {\n        constructor() {\n          workerInstance = new WorkerMock();\n          return workerInstance as any;\n        }\n      },\n    );\n\n    vi.stubGlobal(\n      'AudioContext',\n      class {\n        constructor() {\n          audioContextInstance = new AudioContextMock();\n          return audioContextInstance as any;\n        }\n      },\n    );\n  });\n\n  afterEach(() => {\n    vi.unstubAllGlobals();\n  });\n\n  it('initializes audio context and clamps volume', async () => {\n    const engine = new AudioEngine();\n    await engine.init();\n\n    expect(audioContextInstance).toBeTruthy();\n    engine.setVolume(2);\n    expect(audioContextInstance?.createdGains[0]?.gain.value).toBe(1);\n\n    engine.setVolume(-1);\n    expect(audioContextInstance?.createdGains[0]?.gain.value).toBe(0);\n  });\n\n  it('resumes suspended context on play', async () => {\n    const engine = new AudioEngine();\n    await engine.init();\n\n    if (!audioContextInstance) throw new Error('AudioContext not initialized');\n    audioContextInstance.state = 'suspended';\n\n    await engine.play(0);\n\n    expect(audioContextInstance.resume).toHaveBeenCalledTimes(1);\n  });\n\n  it('decodes a source only once for identical clips', async () => {\n    const engine = new AudioEngine();\n    await engine.init();\n\n    const clips = [createClip(), createClip({ id: 'clip-2' })];\n    await engine.loadClips(clips);\n\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n\n    expect(workerInstance?.postMessage).toHaveBeenCalledTimes(1);\n  });\n\n  it('schedules playback and stops nodes', async () => {\n    const engine = new AudioEngine();\n    await engine.init();\n\n    const clip = createClip();\n    await engine.loadClips([clip]);\n\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n\n    if (!audioContextInstance) throw new Error('AudioContext not initialized');\n    audioContextInstance.currentTime = 10;\n\n    await engine.play(0);\n\n    expect(audioContextInstance.createdSources.length).toBe(1);\n    const source = audioContextInstance.createdSources[0];\n    expect(source.start).toHaveBeenCalledTimes(1);\n\n    engine.stop();\n    expect(source.stop).toHaveBeenCalledTimes(1);\n  });\n\n  it('retries playback after seek when playing', async () => {\n    const engine = new AudioEngine();\n    await engine.init();\n\n    const clip = createClip();\n    await engine.loadClips([clip]);\n\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n\n    await engine.play(0);\n    const initialSources = audioContextInstance?.createdSources.length ?? 0;\n\n    engine.seek(500_000);\n\n    expect(audioContextInstance?.createdSources.length).toBeGreaterThan(initialSources);\n  });\n\n  it('keeps failed decode cached as null', async () => {\n    workerOk = false;\n    const engine = new AudioEngine();\n    await engine.init();\n\n    const clip = createClip();\n    await engine.loadClips([clip]);\n\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n\n    workerOk = true;\n    await engine.loadClips([clip]);\n\n    await new Promise<void>((resolve) => setTimeout(resolve, 0));\n\n    expect(workerInstance?.postMessage).toHaveBeenCalledTimes(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/utils/video-editor/TimelineActiveTracker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/video-compositor-render-optimization.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":49,"messageId":"unexpectedAny","endLine":8,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[297,300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[297,300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":25,"messageId":"unexpectedAny","endLine":12,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[382,385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[382,385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":45,"messageId":"unexpectedAny","endLine":20,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[524,527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[524,527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, expect, it, vi } from 'vitest';\n\nimport { VideoCompositor } from '../../src/utils/video-editor/VideoCompositor';\n\ndescribe('VideoCompositor render optimization', () => {\n  function createCompositor() {\n    const compositor = new VideoCompositor() as any;\n    const app = {\n      render: vi.fn(),\n      stage: {\n        children: [] as any[],\n      },\n      ticker: {\n        stop: vi.fn(),\n      },\n    };\n\n    compositor.app = app;\n    compositor.canvas = { id: 'canvas' } as any;\n    compositor.clips = [];\n    compositor.clipById = new Map();\n    compositor.lastRenderedTimeUs = 1_000;\n    compositor.stageSortDirty = false;\n    compositor.activeSortDirty = false;\n\n    return { compositor, app };\n  }\n\n  it('skips rendering when time is unchanged and no dirty flags', async () => {\n    const { compositor, app } = createCompositor();\n\n    const result = await compositor.renderFrame(1_000);\n\n    expect(result).toEqual({ id: 'canvas' });\n    expect(app.render).not.toHaveBeenCalled();\n  });\n\n  it('renders when stage sort is dirty even if time is unchanged', async () => {\n    const { compositor, app } = createCompositor();\n    compositor.stageSortDirty = true;\n\n    await compositor.renderFrame(1_000);\n\n    expect(app.render).toHaveBeenCalledTimes(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/video-compositor-zero-frame.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":65,"messageId":"unexpectedAny","endLine":12,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[477,480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[477,480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":65,"messageId":"unexpectedAny","endLine":24,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[931,934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[931,934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":65,"messageId":"unexpectedAny","endLine":37,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1471,1474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1471,1474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":65,"messageId":"unexpectedAny","endLine":50,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1930,1933],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1930,1933],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @vitest-environment node\nimport { describe, expect, it, vi } from 'vitest';\n\nimport { getVideoSampleWithZeroFallback } from '../../src/utils/video-editor/VideoCompositor';\n\ndescribe('getVideoSampleWithZeroFallback', () => {\n  it('returns sample at non-zero time without retry', async () => {\n    const sink = {\n      getSample: vi.fn(async (timeS: number) => (timeS === 0.5 ? { id: 'frame' } : null)),\n    };\n\n    const sample = await getVideoSampleWithZeroFallback(sink as any, 0.5);\n\n    expect(sample).toEqual({ id: 'frame' });\n    expect(sink.getSample).toHaveBeenCalledTimes(1);\n    expect(sink.getSample).toHaveBeenCalledWith(0.5);\n  });\n\n  it('falls back to firstTimestampS when requested time is before first sample', async () => {\n    const sink = {\n      getSample: vi.fn(async (timeS: number) => (timeS >= 0.04 ? { id: 'first-frame' } : null)),\n    };\n\n    const sample = await getVideoSampleWithZeroFallback(sink as any, 0, 0.04);\n\n    expect(sample).toEqual({ id: 'first-frame' });\n    expect(sink.getSample).toHaveBeenCalledTimes(2);\n    expect(sink.getSample).toHaveBeenNthCalledWith(1, 0);\n    expect(sink.getSample).toHaveBeenNthCalledWith(2, 0.04);\n  });\n\n  it('retries with epsilon when time is exactly 0 and no firstTimestampS fallback is provided', async () => {\n    const sink = {\n      getSample: vi.fn(async (timeS: number) => (timeS > 0 ? { id: 'first-frame' } : null)),\n    };\n\n    const sample = await getVideoSampleWithZeroFallback(sink as any, 0);\n\n    expect(sample).toEqual({ id: 'first-frame' });\n    expect(sink.getSample).toHaveBeenCalledTimes(2);\n    expect(sink.getSample).toHaveBeenNthCalledWith(1, 0);\n    expect(sink.getSample).toHaveBeenNthCalledWith(2, 1e-6);\n  });\n\n  it('does not retry when time is non-zero and primary sample is null', async () => {\n    const sink = {\n      getSample: vi.fn(async () => null),\n    };\n\n    const sample = await getVideoSampleWithZeroFallback(sink as any, 1);\n\n    expect(sample).toBeNull();\n    expect(sink.getSample).toHaveBeenCalledTimes(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/workers/core/AudioMixer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/unit/workers/core/export-helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/test/vitest.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":47,"messageId":"unexpectedAny","endLine":13,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[466,469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[466,469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":33,"messageId":"unexpectedAny","endLine":50,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1346,1349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1346,1349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":56,"messageId":"unexpectedAny","endLine":89,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2489,2492],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2489,2492],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":57,"messageId":"unexpectedAny","endLine":94,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2635,2638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2635,2638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":55,"messageId":"unexpectedAny","endLine":99,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2780,2783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2780,2783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":56,"messageId":"unexpectedAny","endLine":104,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2924,2927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2924,2927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Vitest setup for Nuxt test environment\n\n// @nuxtjs/color-mode expects a global helper object at window[globalName].\n// In unit tests (jsdom/happy-dom), that helper may be missing or incomplete.\n// Provide a minimal implementation to avoid unhandled rejections during mount.\n\nimport { vi } from 'vitest';\nimport { config } from '@vue/test-utils';\nimport { ref } from 'vue';\n\nconst globalName = '__NUXT_COLOR_MODE__';\n\nconst w = globalThis as unknown as { window?: any };\nif (w.window) {\n  const helper = (w.window[globalName] ??= {});\n\n  helper.preference ??= 'dark';\n  helper.value ??= 'dark';\n\n  helper.getColorScheme ??= () => 'dark';\n  helper.addColorScheme ??= () => {};\n  helper.removeColorScheme ??= () => {};\n}\n\nvi.mock('vue-i18n', () => ({\n  useI18n: () => ({\n    t: (key: string, fallback?: string) => fallback ?? key,\n    locale: ref('en'),\n  }),\n  createI18n: () => ({\n    mode: 'composition',\n    mergeLocaleMessage: () => {},\n    setLocaleMessage: () => {},\n    locale: ref('en'),\n    global: {\n      t: (key: string) => key,\n      locale: ref('en'),\n      mergeLocaleMessage: () => {},\n      setLocaleMessage: () => {},\n    },\n    install: () => {},\n  }),\n}));\n\nvi.mock('#i18n', () => ({\n  useI18n: () => ({\n    t: (key: string, fallback?: string) => fallback ?? key,\n    locale: ref('en'),\n  }),\n  useLocaleRoute: () => (route: any) => route,\n  useRouteBaseName: () => () => '',\n  useLocalePath: () => (path: string) => path,\n  useSwitchLocalePath: () => (locale: string) => locale,\n}));\n\nvi.stubGlobal('useColorMode', () => ({\n  preference: 'dark',\n  value: 'dark',\n}));\n\nvi.stubGlobal('useHead', () => {});\nvi.stubGlobal('useRuntimeConfig', () => ({\n  public: {},\n}));\n\nconfig.global.config.warnHandler = (msg) => {\n  if (typeof msg === 'string' && msg.includes('<Suspense> is an experimental feature')) return;\n};\n\nfunction shouldIgnoreConsoleMessage(args: unknown[]) {\n  const parts = args.map((a) => {\n    if (typeof a === 'string') return a;\n    if (a instanceof Error) return a.message;\n    return '';\n  });\n\n  const msg = parts.join(' ');\n\n  if (msg.includes('i18n.mergeLocaleMessage is not a function')) return true;\n  if (msg.includes('<Suspense> is an experimental feature')) return true;\n  return false;\n}\n\nconst originalWarn = console.warn.bind(console);\nconst originalError = console.error.bind(console);\nconst originalLog = console.log.bind(console);\nconst originalInfo = console.info.bind(console);\n\nvi.spyOn(console, 'warn').mockImplementation((...args: any[]) => {\n  if (shouldIgnoreConsoleMessage(args)) return;\n  originalWarn(...args);\n});\n\nvi.spyOn(console, 'error').mockImplementation((...args: any[]) => {\n  if (shouldIgnoreConsoleMessage(args)) return;\n  originalError(...args);\n});\n\nvi.spyOn(console, 'log').mockImplementation((...args: any[]) => {\n  if (shouldIgnoreConsoleMessage(args)) return;\n  originalLog(...args);\n});\n\nvi.spyOn(console, 'info').mockImplementation((...args: any[]) => {\n  if (shouldIgnoreConsoleMessage(args)) return;\n  originalInfo(...args);\n});\n","usedDeprecatedRules":[]},{"filePath":"/mnt/disk2/workspace/gran-video-editor/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]